---
title: 5.2 Robot Control Implementation
sidebar_position: 11
---

# 5.2 Robot Control Implementation

## Learning Objectives
- Implement PID controllers for humanoid robot joints
- Design whole-body control systems using operational space control
- Apply feedback linearization techniques for robot dynamics
- Integrate perception with control systems for real-time operation
- Implement safety and constraint handling in control systems

## Introduction

Robot control implementation transforms theoretical control concepts into executable code that drives physical humanoid robots. This process involves translating mathematical control laws into real-time algorithms that can operate at the required frequencies while handling the computational constraints of embedded systems. The implementation must also address practical issues such as sensor noise, actuator limitations, and communication delays that affect real-world performance.

Effective control implementation requires careful consideration of software architecture, real-time performance requirements, and integration with other robotic systems. The control system must interface with low-level hardware drivers, high-level planning systems, and perception modules to create a cohesive robotic system. Implementation choices significantly impact the stability, performance, and safety of the resulting robot system.

This section provides practical examples of control implementation using common frameworks and programming languages used in robotics, with a focus on humanoid-specific challenges such as balance maintenance, multi-task coordination, and real-time performance requirements.

## 2. PID Controller Implementation

### Basic PID Implementation

A proportional-integral-derivative (PID) controller is fundamental to most robotic control systems. Here's a practical implementation:

```python
import numpy as np
import time

class PIDController:
    def __init__(self, kp=1.0, ki=0.0, kd=0.0, dt=0.001):
        self.kp = kp  # Proportional gain
        self.ki = ki  # Integral gain
        self.kd = kd  # Derivative gain
        self.dt = dt  # Time step

        # Internal state
        self.error_sum = 0.0
        self.error_prev = 0.0
        self.last_time = time.time()

        # Integral windup protection
        self.integral_limit = 10.0

        # Derivative filtering
        self.alpha = 0.1  # Low-pass filter coefficient
        self.filtered_derivative = 0.0

    def update(self, setpoint, measurement):
        """
        Update PID controller with new measurement
        """
        current_time = time.time()
        dt = current_time - self.last_time

        # Use provided dt if available, otherwise use time difference
        if dt > 0:
            self.dt = dt
        self.last_time = current_time

        # Calculate error
        error = setpoint - measurement

        # Proportional term
        p_term = self.kp * error

        # Integral term with windup protection
        self.error_sum += error * self.dt
        # Apply integral limit to prevent windup
        self.error_sum = np.clip(self.error_sum, -self.integral_limit, self.integral_limit)
        i_term = self.ki * self.error_sum

        # Derivative term with filtering to reduce noise
        if self.dt > 0:
            raw_derivative = (error - self.error_prev) / self.dt
            # Low-pass filter the derivative to reduce noise
            self.filtered_derivative = (1 - self.alpha) * self.filtered_derivative + self.alpha * raw_derivative
        else:
            self.filtered_derivative = 0.0

        d_term = self.kd * self.filtered_derivative

        # Store current error for next iteration
        self.error_prev = error

        # Calculate output
        output = p_term + i_term + d_term

        return output

    def reset(self):
        """
        Reset internal state of the PID controller
        """
        self.error_sum = 0.0
        self.error_prev = 0.0
        self.filtered_derivative = 0.0
```

### Joint Position Control Example

```python
class JointPositionController:
    def __init__(self, joint_name, kp=100.0, ki=10.0, kd=15.0, max_torque=100.0):
        self.joint_name = joint_name
        self.max_torque = max_torque
        self.pid_controller = PIDController(kp, ki, kd, dt=0.001)

        # Joint state variables
        self.current_position = 0.0
        self.current_velocity = 0.0
        self.desired_position = 0.0

        # Safety limits
        self.position_limits = (-np.pi, np.pi)  # Example limits
        self.velocity_limit = 5.0  # rad/s

    def update(self, current_position, current_velocity, desired_position):
        """
        Update joint position control
        """
        self.current_position = current_position
        self.current_velocity = current_velocity
        self.desired_position = desired_position

        # Calculate control effort
        control_effort = self.pid_controller.update(desired_position, current_position)

        # Apply torque limits
        control_effort = np.clip(control_effort, -self.max_torque, self.max_torque)

        # Check for safety violations
        if abs(current_velocity) > self.velocity_limit:
            # Reduce control effort if velocity limit is exceeded
            control_effort *= 0.5

        return control_effort

    def set_gains(self, kp, ki, kd):
        """
        Update PID gains dynamically
        """
        self.pid_controller.kp = kp
        self.pid_controller.ki = ki
        self.pid_controller.kd = kd
```

## 3. Whole-Body Control Implementation

### Operational Space Control

Operational space control allows direct control of end-effector behavior while maintaining stability of the entire robot:

```python
import numpy as np
from scipy.spatial.transform import Rotation as R

class OperationalSpaceController:
    def __init__(self, robot_model, joint_names):
        self.robot_model = robot_model
        self.joint_names = joint_names
        self.n_joints = len(joint_names)

        # Task space dimensions (position + orientation)
        self.task_dim = 6  # 3 for position, 3 for orientation

        # Controller gains
        self.kp_pos = 100.0  # Position gain
        self.kp_ori = 50.0   # Orientation gain
        self.kd_pos = 20.0   # Position damping
        self.kd_ori = 10.0   # Orientation damping

        # Mass matrix and its inverse
        self.M = np.zeros((self.n_joints, self.n_joints))
        self.M_inv = np.zeros((self.n_joints, self.n_joints))

        # Jacobian matrices
        self.J_pos = np.zeros((3, self.n_joints))  # Position Jacobian
        self.J_ori = np.zeros((3, self.n_joints))  # Orientation Jacobian
        self.J_task = np.zeros((self.task_dim, self.n_joints))  # Combined Jacobian

        # Task space mass matrix
        self.M_task = np.zeros((self.task_dim, self.task_dim))

    def compute_task_control(self, current_pose, desired_pose,
                           current_vel, desired_vel, current_q, current_qdot):
        """
        Compute operational space control for end-effector task
        """
        # Extract position and orientation
        current_pos = current_pose[:3]
        current_quat = current_pose[3:]
        desired_pos = desired_pose[:3]
        desired_quat = desired_pose[3:]

        # Position error
        pos_error = desired_pos - current_pos

        # Orientation error (using quaternion difference)
        quat_error = self.compute_quaternion_error(current_quat, desired_quat)

        # Combined task error
        task_error = np.hstack([pos_error, quat_error])

        # Compute Jacobians
        self.J_pos = self.compute_position_jacobian(current_q)
        self.J_ori = self.compute_orientation_jacobian(current_q)
        self.J_task = np.vstack([self.J_pos, self.J_ori])

        # Compute joint mass matrix
        self.M = self.compute_mass_matrix(current_q)
        self.M_inv = np.linalg.inv(self.M)

        # Compute task space mass matrix
        self.M_task = np.linalg.inv(self.J_task @ self.M_inv @ self.J_task.T)

        # Desired task acceleration
        pos_acc_des = self.kp_pos * pos_error - self.kd_pos * (current_vel[:3] - desired_vel[:3])
        ori_acc_des = self.kp_ori * quat_error - self.kd_ori * (current_vel[3:] - desired_vel[3:])
        task_acc_des = np.hstack([pos_acc_des, ori_acc_des])

        # Compute operational space control force
        lambda_inv = self.J_task @ self.M_inv @ self.J_task.T
        lambda_task = np.linalg.inv(lambda_inv)

        F_task = lambda_task @ task_acc_des

        # Convert to joint torques
        torques = self.J_task.T @ F_task

        return torques

    def compute_quaternion_error(self, quat_current, quat_desired):
        """
        Compute orientation error in axis-angle representation
        """
        # Convert to rotation matrices
        R_current = R.from_quat(quat_current).as_matrix()
        R_desired = R.from_quat(quat_desired).as_matrix()

        # Relative rotation
        R_rel = R_desired @ R_current.T

        # Convert to axis-angle
        angle_axis = R.from_matrix(R_rel).as_rotvec()

        return angle_axis

    def compute_position_jacobian(self, q):
        """
        Compute position Jacobian (simplified - in practice use robot model)
        """
        # This would use the actual robot kinematics model
        # For demonstration, returning a placeholder
        J_pos = np.zeros((3, self.n_joints))

        # In real implementation, this would compute Jacobian based on current joint angles
        # using the robot's kinematic model

        return J_pos

    def compute_orientation_jacobian(self, q):
        """
        Compute orientation Jacobian (simplified)
        """
        J_ori = np.zeros((3, self.n_joints))

        # In real implementation, this would compute orientation Jacobian
        # based on the robot's kinematic model

        return J_ori

    def compute_mass_matrix(self, q):
        """
        Compute joint space mass matrix (simplified)
        """
        # In real implementation, this would use the robot dynamics model
        M = np.eye(self.n_joints) * 0.1  # Placeholder values

        return M
```

## 4. Balance Control Implementation

### Zero Moment Point (ZMP) Controller

```python
class ZMPBalanceController:
    def __init__(self, robot_height=0.8, gravity=9.81):
        self.robot_height = robot_height
        self.gravity = gravity
        self.omega = np.sqrt(gravity / robot_height)

        # Controller gains
        self.kp = 100.0  # Proportional gain
        self.kd = 10.0   # Derivative gain

        # State estimation
        self.com_position = np.zeros(2)  # x, y
        self.com_velocity = np.zeros(2)
        self.zmp_reference = np.zeros(2)
        self.zmp_actual = np.zeros(2)

        # Support polygon vertices (simplified as rectangle)
        self.support_polygon = np.array([
            [-0.1, -0.05],  # front left
            [-0.1, 0.05],   # front right
            [0.1, 0.05],    # back right
            [0.1, -0.05]    # back left
        ])

    def compute_zmp(self, com_pos, com_acc):
        """
        Compute Zero Moment Point from CoM state
        """
        # Simplified ZMP calculation assuming constant CoM height
        zmp_x = com_pos[0] - self.robot_height / self.gravity * com_acc[0]
        zmp_y = com_pos[1] - self.robot_height / self.gravity * com_acc[1]

        return np.array([zmp_x, zmp_y])

    def balance_control(self, current_state, support_polygon=None):
        """
        Compute balance control corrections
        """
        if support_polygon is not None:
            self.support_polygon = support_polygon

        # Extract CoM position and acceleration
        com_pos = current_state['com_position'][:2]  # x, y only
        com_acc = current_state['com_acceleration'][:2]

        # Compute current ZMP
        current_zmp = self.compute_zmp(com_pos, com_acc)

        # Compute desired ZMP (typically center of support polygon)
        desired_zmp = self.compute_desired_zmp()

        # ZMP error
        zmp_error = desired_zmp - current_zmp

        # Compute corrective CoM acceleration using inverted pendulum model
        com_acc_correction = self.omega**2 * (desired_zmp - com_pos) + self.kd * zmp_error

        # Check if ZMP is within support polygon
        is_stable = self.is_zmp_stable(current_zmp)

        return {
            'com_acc_correction': com_acc_correction,
            'zmp_error': zmp_error,
            'is_stable': is_stable,
            'current_zmp': current_zmp,
            'desired_zmp': desired_zmp
        }

    def compute_desired_zmp(self):
        """
        Compute desired ZMP (typically center of support polygon)
        """
        # For double support, use center of support polygon
        desired_zmp = np.mean(self.support_polygon, axis=0)
        return desired_zmp

    def is_zmp_stable(self, zmp):
        """
        Check if ZMP is within support polygon
        """
        # Simple point-in-polygon test for convex polygon
        # In practice, use a more robust algorithm
        return self.point_in_polygon(zmp, self.support_polygon)

    def point_in_polygon(self, point, polygon):
        """
        Simple point-in-polygon test using ray casting
        """
        x, y = point
        n = len(polygon)
        inside = False

        p1x, p1y = polygon[0]
        for i in range(1, n + 1):
            p2x, p2y = polygon[i % n]
            if y > min(p1y, p2y):
                if y <= max(p1y, p2y):
                    if x <= max(p1x, p2x):
                        if p1y != p2y:
                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                        if p1x == p2x or x <= xinters:
                            inside = not inside
            p1x, p1y = p2x, p2y

        return inside
```

## 5. Real-Time Control Architecture

### ROS-Based Control Node

```python
#!/usr/bin/env python3
import rospy
import numpy as np
from sensor_msgs.msg import JointState
from std_msgs.msg import Float64MultiArray
from control_msgs.msg import JointTrajectoryControllerState
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
import threading
import time

class RobotControllerNode:
    def __init__(self):
        rospy.init_node('robot_controller', anonymous=True)

        # Robot parameters
        self.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6']  # Example joints
        self.n_joints = len(self.joint_names)

        # Current state
        self.current_positions = np.zeros(self.n_joints)
        self.current_velocities = np.zeros(self.n_joints)
        self.current_efforts = np.zeros(self.n_joints)

        # Desired state
        self.desired_positions = np.zeros(self.n_joints)
        self.desired_velocities = np.zeros(self.n_joints)

        # Control parameters
        self.control_freq = 1000  # Hz
        self.dt = 1.0 / self.control_freq

        # PID controllers for each joint
        self.pid_controllers = [PIDController(100.0, 10.0, 15.0, self.dt)
                               for _ in range(self.n_joints)]

        # Publishers and subscribers
        self.joint_state_sub = rospy.Subscriber('/joint_states', JointState, self.joint_state_callback)
        self.command_pub = rospy.Publisher('/joint_group_position_controller/command',
                                         Float64MultiArray, queue_size=10)
        self.trajectory_sub = rospy.Subscriber('/joint_trajectory', JointTrajectory, self.trajectory_callback)

        # Threading for real-time control
        self.control_thread = None
        self.running = False

        # Safety parameters
        self.max_torque = 100.0
        self.safety_enabled = True

    def joint_state_callback(self, msg):
        """
        Callback for joint state messages
        """
        for i, joint_name in enumerate(self.joint_names):
            try:
                idx = msg.name.index(joint_name)
                self.current_positions[i] = msg.position[idx]
                if idx < len(msg.velocity):
                    self.current_velocities[i] = msg.velocity[idx]
                if idx < len(msg.effort):
                    self.current_efforts[i] = msg.effort[idx]
            except ValueError:
                rospy.logwarn(f"Joint {joint_name} not found in joint state message")

    def trajectory_callback(self, msg):
        """
        Callback for trajectory commands
        """
        if len(msg.points) > 0:
            # Get the first point as the desired state
            point = msg.points[0]

            # Map to our joint order
            for i, joint_name in enumerate(self.joint_names):
                try:
                    idx = msg.joint_names.index(joint_name)
                    if idx < len(point.positions):
                        self.desired_positions[i] = point.positions[idx]
                    if idx < len(point.velocities):
                        self.desired_velocities[i] = point.velocities[idx]
                except ValueError:
                    rospy.logwarn(f"Joint {joint_name} not found in trajectory message")

    def control_loop(self):
        """
        Main control loop running at specified frequency
        """
        rate = rospy.Rate(self.control_freq)

        while not rospy.is_shutdown() and self.running:
            try:
                # Compute control commands
                control_commands = self.compute_control()

                # Publish commands
                cmd_msg = Float64MultiArray()
                cmd_msg.data = control_commands.tolist()
                self.command_pub.publish(cmd_msg)

                rate.sleep()

            except Exception as e:
                rospy.logerr(f"Error in control loop: {e}")
                self.emergency_stop()
                break

    def compute_control(self):
        """
        Compute control commands using PID controllers
        """
        commands = np.zeros(self.n_joints)

        for i in range(self.n_joints):
            # Compute control effort using PID
            effort = self.pid_controllers[i].update(
                self.desired_positions[i],
                self.current_positions[i]
            )

            # Apply safety limits
            effort = np.clip(effort, -self.max_torque, self.max_torque)

            # Check for safety violations
            if abs(self.current_velocities[i]) > 10.0:  # Example velocity limit
                effort *= 0.1  # Reduce effort if velocity limit exceeded

            commands[i] = effort

        return commands

    def start_control(self):
        """
        Start the real-time control loop
        """
        self.running = True
        self.control_thread = threading.Thread(target=self.control_loop)
        self.control_thread.start()
        rospy.loginfo("Robot control started")

    def stop_control(self):
        """
        Stop the control loop
        """
        self.running = False
        if self.control_thread:
            self.control_thread.join()
        rospy.loginfo("Robot control stopped")

    def emergency_stop(self):
        """
        Emergency stop function
        """
        rospy.logerr("Emergency stop activated!")
        self.stop_control()

        # Publish zero commands
        zero_cmd = Float64MultiArray()
        zero_cmd.data = [0.0] * self.n_joints
        self.command_pub.publish(zero_cmd)

def main():
    controller = RobotControllerNode()

    try:
        controller.start_control()
        rospy.spin()
    except KeyboardInterrupt:
        rospy.loginfo("Shutting down robot controller")
        controller.stop_control()

if __name__ == '__main__':
    main()
```

## 6. Sensor Integration and State Estimation

### Kalman Filter for State Estimation

```python
class KalmanFilter:
    def __init__(self, n_states, n_observations):
        self.n_states = n_states
        self.n_observations = n_observations

        # State vector: [position, velocity]
        self.x = np.zeros(n_states)

        # State covariance matrix
        self.P = np.eye(n_states) * 1000.0  # Initial uncertainty

        # Process noise covariance
        self.Q = np.eye(n_states) * 0.1

        # Measurement noise covariance
        self.R = np.eye(n_observations) * 1.0

        # State transition matrix (for constant velocity model)
        self.F = np.eye(n_states)
        self.F[0, 1] = 0.001  # Assuming dt = 0.001s

        # Observation matrix
        self.H = np.zeros((n_observations, n_states))
        self.H[0, 0] = 1.0  # We observe position

    def predict(self, dt):
        """
        Prediction step of Kalman filter
        """
        # Update state transition matrix with actual dt
        self.F[0, 1] = dt

        # Predict state
        self.x = self.F @ self.x

        # Predict covariance
        self.P = self.F @ self.P @ self.F.T + self.Q

    def update(self, z):
        """
        Update step of Kalman filter
        """
        # Innovation
        y = z - self.H @ self.x

        # Innovation covariance
        S = self.H @ self.P @ self.H.T + self.R

        # Kalman gain
        K = self.P @ self.H.T @ np.linalg.inv(S)

        # Update state
        self.x = self.x + K @ y

        # Update covariance
        I_KH = np.eye(self.n_states) - K @ self.H
        self.P = I_KH @ self.P

class RobotStateEstimator:
    def __init__(self):
        # Create Kalman filters for each joint
        self.kalman_filters = {}

        # For each joint, estimate position and velocity
        for joint_idx in range(6):  # Example: 6 joints
            self.kalman_filters[joint_idx] = KalmanFilter(n_states=2, n_observations=1)

    def update_state(self, joint_idx, measurement, dt=0.001):
        """
        Update state estimate for a specific joint
        """
        kf = self.kalman_filters[joint_idx]

        # Prediction step
        kf.predict(dt)

        # Update step with measurement
        kf.update(np.array([measurement]))

        # Return estimated state [position, velocity]
        return kf.x
```

## 7. Safety and Constraint Handling

### Safety Controller Implementation

```python
class SafetyController:
    def __init__(self, robot_limits):
        self.limits = robot_limits
        self.emergency_active = False
        self.last_safe_state = None

        # Safety parameters
        self.velocity_threshold = 10.0  # rad/s
        self.torque_threshold = 200.0   # Nm
        self.position_threshold = 0.1   # rad from limit
        self.collision_threshold = 0.1  # m from obstacle

    def check_safety(self, joint_positions, joint_velocities, joint_torques, obstacles=None):
        """
        Check if current robot state is safe
        """
        safety_report = {
            'position_safe': True,
            'velocity_safe': True,
            'torque_safe': True,
            'collision_safe': True,
            'overall_safe': True
        }

        # Check position limits
        for i, pos in enumerate(joint_positions):
            if pos > (self.limits['position'][i][1] - self.position_threshold) or \
               pos < (self.limits['position'][i][0] + self.position_threshold):
                safety_report['position_safe'] = False
                safety_report['overall_safe'] = False

        # Check velocity limits
        for i, vel in enumerate(joint_velocities):
            if abs(vel) > self.velocity_threshold:
                safety_report['velocity_safe'] = False
                safety_report['overall_safe'] = False

        # Check torque limits
        for i, torque in enumerate(joint_torques):
            if abs(torque) > self.torque_threshold:
                safety_report['torque_safe'] = False
                safety_report['overall_safe'] = False

        # Check collision if obstacles provided
        if obstacles is not None:
            for obstacle in obstacles:
                if self.check_collision(obstacle):
                    safety_report['collision_safe'] = False
                    safety_report['overall_safe'] = False

        return safety_report

    def check_collision(self, obstacle):
        """
        Check for collision with obstacle (simplified)
        """
        # In practice, use collision checking library like FCL
        return False

    def apply_safety_constraints(self, control_commands, safety_report):
        """
        Apply safety constraints to control commands
        """
        constrained_commands = control_commands.copy()

        if not safety_report['velocity_safe']:
            # Reduce control effort to decrease velocity
            constrained_commands *= 0.5

        if not safety_report['torque_safe']:
            # Clip torques to safe limits
            constrained_commands = np.clip(constrained_commands,
                                         -self.torque_threshold,
                                         self.torque_threshold)

        if not safety_report['position_safe']:
            # Generate restoring force toward safe position
            restoring_force = self.compute_restoring_force()
            constrained_commands += restoring_force

        return constrained_commands

    def compute_restoring_force(self):
        """
        Compute restoring force to move away from limits
        """
        # Simplified implementation
        return np.zeros(len(self.limits['position']))
```

## 8. Performance Optimization

### Optimized Control Implementation

```python
import numba
from numba import jit
import numpy as np

class OptimizedRobotController:
    def __init__(self, n_joints):
        self.n_joints = n_joints

        # Pre-allocate arrays to avoid memory allocation during control
        self.control_commands = np.zeros(n_joints)
        self.error_buffer = np.zeros(n_joints)
        self.integral_buffer = np.zeros(n_joints)
        self.derivative_buffer = np.zeros(n_joints)

        # Control parameters
        self.kp = np.full(n_joints, 100.0)
        self.ki = np.full(n_joints, 10.0)
        self.kd = np.full(n_joints, 15.0)

        # Time step
        self.dt = 0.001

    @staticmethod
    @jit(nopython=True)
    def fast_pid_control(setpoints, measurements, kp, ki, kd, dt,
                        error_sum, error_prev, commands):
        """
        Fast PID control using Numba JIT compilation
        """
        n = len(setpoints)

        for i in range(n):
            error = setpoints[i] - measurements[i]

            # Update integral with anti-windup
            error_sum[i] += error * dt
            # Simple anti-windup - limit integral term
            if abs(error_sum[i]) > 10.0:
                error_sum[i] = np.sign(error_sum[i]) * 10.0

            # Compute derivative
            derivative = (error - error_prev[i]) / dt
            error_prev[i] = error

            # Compute PID output
            commands[i] = kp[i] * error + ki[i] * error_sum[i] + kd[i] * derivative

        return commands

    def update_control(self, setpoints, measurements):
        """
        Update control using optimized PID
        """
        self.control_commands = self.fast_pid_control(
            setpoints, measurements, self.kp, self.ki, self.kd,
            self.dt, self.integral_buffer, self.derivative_buffer,
            self.control_commands
        )

        # Apply safety limits
        self.control_commands = np.clip(self.control_commands, -100.0, 100.0)

        return self.control_commands.copy()
```

## 9. Integration with Planning and Perception

### Control-Planning Interface

```python
class ControlPlanningInterface:
    def __init__(self, robot_controller):
        self.controller = robot_controller
        self.trajectory_queue = []
        self.current_trajectory = None
        self.trajectory_idx = 0

    def execute_trajectory(self, trajectory):
        """
        Execute a planned trajectory
        """
        self.trajectory_queue.append(trajectory)

    def update(self, current_state):
        """
        Update control based on trajectory tracking
        """
        if self.current_trajectory is None and len(self.trajectory_queue) > 0:
            self.current_trajectory = self.trajectory_queue.pop(0)
            self.trajectory_idx = 0

        if self.current_trajectory is not None:
            # Get next trajectory point
            if self.trajectory_idx < len(self.current_trajectory.points):
                target_point = self.current_trajectory.points[self.trajectory_idx]

                # Check if we've reached the current target
                if self.has_reached_target(current_state, target_point):
                    self.trajectory_idx += 1

                # Generate control command
                if self.trajectory_idx < len(self.current_trajectory.points):
                    next_point = self.current_trajectory.points[self.trajectory_idx]
                    control_cmd = self.controller.compute_control(
                        current_state, next_point
                    )

                    return control_cmd
            else:
                # Trajectory completed
                self.current_trajectory = None

        return np.zeros(self.controller.n_joints)

    def has_reached_target(self, current_state, target_point):
        """
        Check if target has been reached
        """
        position_error = np.linalg.norm(
            current_state['positions'] - target_point.positions
        )
        return position_error < 0.01  # 1cm tolerance
```

## 10. Testing and Validation

### Control System Testing

```python
class ControlTester:
    def __init__(self, controller):
        self.controller = controller
        self.test_results = {}

    def test_step_response(self, joint_idx, step_size=0.1):
        """
        Test step response of control system
        """
        initial_pos = self.controller.current_positions[joint_idx]
        target_pos = initial_pos + step_size

        # Apply step input
        start_time = time.time()
        response_data = []

        for i in range(1000):  # 1 second at 1000 Hz
            current_pos = self.controller.current_positions[joint_idx]
            control_output = self.controller.pid_controllers[joint_idx].update(
                target_pos, current_pos
            )

            # Simulate system response (simplified)
            acceleration = control_output / 1.0  # Assume mass = 1
            velocity = 0.0  # Simplified
            new_pos = current_pos + velocity * 0.001

            response_data.append({
                'time': time.time() - start_time,
                'position': new_pos,
                'target': target_pos,
                'error': abs(target_pos - new_pos)
            })

            time.sleep(0.001)  # Simulate real-time

        return response_data

    def test_stability(self):
        """
        Test control system stability
        """
        # Apply random disturbances and check for bounded response
        pass

    def test_tracking_performance(self):
        """
        Test tracking performance with various trajectories
        """
        # Test with sinusoidal, polynomial, and step trajectories
        pass
```

This implementation section provides practical examples of robot control systems for humanoid robots, including PID controllers, whole-body control, balance control, real-time architecture, sensor integration, safety systems, and performance optimization techniques. The code demonstrates how theoretical control concepts are translated into executable implementations that can run on real robotic systems.