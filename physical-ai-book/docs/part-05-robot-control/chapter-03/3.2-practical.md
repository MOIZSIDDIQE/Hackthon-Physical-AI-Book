---
title: 5.8 Control System Integration Implementation
sidebar_position: 17
---

# 5.8 Control System Integration Implementation

## Learning Objectives
- Implement hierarchical control architectures for humanoid robots
- Design multi-rate control systems with proper synchronization
- Integrate sensor fusion and state estimation systems
- Apply middleware technologies for system integration
- Implement safety and fault tolerance mechanisms

## Introduction

Control system integration implementation requires translating architectural concepts into executable code that coordinates multiple control components while maintaining real-time performance and safety requirements. This process involves not only implementing individual control modules but also creating the communication infrastructure, synchronization mechanisms, and error handling that enable seamless operation of the integrated system. The implementation must balance theoretical performance with practical constraints such as computational resources, communication bandwidth, and system reliability.

Effective integration implementation requires careful consideration of software architecture, real-time performance, and system modularity. The control system must interface with various hardware components, handle sensor noise and delays, and maintain stability in the presence of component failures. Implementation choices significantly impact the maintainability, scalability, and reliability of the resulting integrated system.

This section provides practical examples of control system integration using common frameworks and tools in robotics, with a focus on humanoid-specific challenges such as multi-rate control, sensor fusion, and safety-critical operation.

## 2. Hierarchical Control Implementation

### Three-Tier Control Architecture

A hierarchical control system organizes control functions into three distinct tiers:

```python
import threading
import time
import numpy as np
from collections import deque
import queue

class HierarchicalControlSystem:
    def __init__(self, robot_model):
        self.robot_model = robot_model

        # Communication queues between tiers
        self.high_to_mid_queue = queue.Queue(maxsize=10)
        self.mid_to_low_queue = queue.Queue(maxsize=10)

        # State storage
        self.current_state = {
            'q': np.zeros(robot_model.n_joints),
            'q_dot': np.zeros(robot_model.n_joints),
            'com': np.zeros(3),
            'zmp': np.zeros(2)
        }

        # Control threads
        self.high_level_thread = None
        self.mid_level_thread = None
        self.low_level_thread = None

        # Control flags
        self.running = False
        self.emergency_stop = False

class HighLevelController:
    def __init__(self, system_state, communication_queue):
        self.system_state = system_state
        self.communication_queue = communication_queue
        self.planning_frequency = 10  # Hz
        self.dt = 1.0 / self.planning_frequency

        # Task planning components
        self.task_queue = deque()
        self.current_task = None
        self.task_parameters = {}

    def run(self):
        """
        High-level task planning and motion planning
        """
        while self.running:
            start_time = time.time()

            # Update system state (simplified)
            current_state = self.system_state

            # Plan next trajectory based on current task
            if self.current_task:
                trajectory = self.plan_trajectory(current_state, self.current_task)

                # Send trajectory to mid-level controller
                message = {
                    'type': 'trajectory',
                    'trajectory': trajectory,
                    'timestamp': time.time()
                }

                try:
                    self.communication_queue.put(message, block=False)
                except queue.Full:
                    print("High-to-mid queue full, skipping message")

            # Sleep to maintain frequency
            elapsed = time.time() - start_time
            sleep_time = max(0, self.dt - elapsed)
            time.sleep(sleep_time)

    def plan_trajectory(self, state, task):
        """
        Plan trajectory based on current task
        """
        if task == 'walk_forward':
            # Generate walking trajectory
            trajectory = self.generate_walking_trajectory(state)
        elif task == 'reach_target':
            # Generate reaching trajectory
            trajectory = self.generate_reaching_trajectory(state, self.task_parameters.get('target'))
        else:
            # Default trajectory
            trajectory = self.generate_default_trajectory(state)

        return trajectory

    def generate_walking_trajectory(self, state):
        """
        Generate walking trajectory with ZMP planning
        """
        # Simplified walking trajectory generation
        n_points = 50  # Number of trajectory points
        trajectory = []

        for i in range(n_points):
            t = i * 0.02  # 20ms between points

            # Generate CoM trajectory
            com_x = state['com'][0] + 0.1 * t  # Move forward
            com_y = state['com'][1] + 0.02 * np.sin(2 * np.pi * t)  # Lateral sway
            com_z = state['com'][2]  # Maintain height

            # Generate ZMP trajectory
            zmp_x = com_x - 0.05  # ZMP slightly behind CoM
            zmp_y = com_y

            trajectory_point = {
                'com': np.array([com_x, com_y, com_z]),
                'zmp': np.array([zmp_x, zmp_y]),
                'time': t
            }

            trajectory.append(trajectory_point)

        return trajectory

class MidLevelController:
    def __init__(self, system_state, high_to_mid_queue, mid_to_low_queue):
        self.system_state = system_state
        self.high_to_mid_queue = high_to_mid_queue
        self.mid_to_low_queue = mid_to_low_queue
        self.control_frequency = 200  # Hz
        self.dt = 1.0 / self.control_frequency

        # Balance control
        self.balance_controller = ZMPBalanceController()

        # Trajectory following
        self.current_trajectory = []
        self.trajectory_index = 0

        # Whole-body control
        self.whole_body_controller = OperationalSpaceController()

    def run(self):
        """
        Mid-level coordination and balance control
        """
        while self.running:
            start_time = time.time()

            # Check for new trajectories from high-level
            try:
                message = self.high_to_mid_queue.get_nowait()
                if message['type'] == 'trajectory':
                    self.current_trajectory = message['trajectory']
                    self.trajectory_index = 0
            except queue.Empty:
                pass

            # Update system state
            current_state = self.system_state

            # Generate control commands based on current trajectory
            if self.current_trajectory and self.trajectory_index < len(self.current_trajectory):
                target_point = self.current_trajectory[self.trajectory_index]

                # Balance control
                balance_control = self.balance_controller.balance_control(
                    current_state, target_point['zmp']
                )

                # Whole-body control
                wb_control = self.whole_body_controller.compute_task_control(
                    current_state, target_point
                )

                # Combine controls
                control_command = {
                    'balance': balance_control,
                    'whole_body': wb_control,
                    'trajectory_point': target_point,
                    'timestamp': time.time()
                }

                # Send to low-level controller
                try:
                    self.mid_to_low_queue.put(control_command, block=False)
                except queue.Full:
                    print("Mid-to-low queue full, skipping message")

                # Move to next trajectory point
                self.trajectory_index += 1
            else:
                # Send zero commands if no trajectory
                control_command = {
                    'balance': np.zeros(2),
                    'whole_body': np.zeros(self.system_state['q'].shape[0]),
                    'trajectory_point': None,
                    'timestamp': time.time()
                }

                try:
                    self.mid_to_low_queue.put(control_command, block=False)
                except queue.Full:
                    print("Mid-to-low queue full, skipping message")

            # Sleep to maintain frequency
            elapsed = time.time() - start_time
            sleep_time = max(0, self.dt - elapsed)
            time.sleep(sleep_time)

class LowLevelController:
    def __init__(self, robot_hardware, mid_to_low_queue):
        self.robot_hardware = robot_hardware
        self.mid_to_low_queue = mid_to_low_queue
        self.control_frequency = 1000  # Hz
        self.dt = 1.0 / self.control_frequency

        # Joint controllers
        self.joint_controllers = [
            PIDController(kp=100, ki=10, kd=15, dt=self.dt)
            for _ in range(robot_hardware.n_joints)
        ]

        # Current state
        self.current_positions = np.zeros(robot_hardware.n_joints)
        self.current_velocities = np.zeros(robot_hardware.n_joints)

    def run(self):
        """
        Low-level joint control and hardware interface
        """
        while self.running:
            start_time = time.time()

            # Read current state from hardware
            self.current_positions = self.robot_hardware.get_joint_positions()
            self.current_velocities = self.robot_hardware.get_joint_velocities()

            # Check for new control commands
            try:
                control_command = self.mid_to_low_queue.get_nowait()

                # Apply balance and whole-body control to joint commands
                if control_command['trajectory_point']:
                    # Generate joint-space control commands
                    joint_commands = self.compute_joint_commands(
                        control_command, self.current_positions, self.current_velocities
                    )
                else:
                    # Zero commands
                    joint_commands = np.zeros(self.robot_hardware.n_joints)

                # Apply joint limits and safety checks
                joint_commands = self.apply_safety_limits(joint_commands)

                # Send commands to hardware
                self.robot_hardware.send_joint_commands(joint_commands)

            except queue.Empty:
                # No new commands, continue with previous commands
                pass

            # Sleep to maintain frequency
            elapsed = time.time() - start_time
            sleep_time = max(0, self.dt - elapsed)
            time.sleep(sleep_time)

    def compute_joint_commands(self, control_command, current_pos, current_vel):
        """
        Compute joint commands from high-level control commands
        """
        # This would involve inverse kinematics, inverse dynamics, etc.
        # For this example, we'll use a simplified approach

        # Extract desired joint positions from trajectory
        # In practice, this would involve whole-body control calculations
        desired_positions = current_pos + 0.01 * np.random.randn(len(current_pos))  # Placeholder

        # Compute joint control commands using PID
        commands = np.zeros(len(current_pos))
        for i in range(len(current_pos)):
            commands[i] = self.joint_controllers[i].update(
                desired_positions[i], current_pos[i]
            )

        return commands

    def apply_safety_limits(self, commands):
        """
        Apply safety limits to joint commands
        """
        # Joint position limits
        commands = np.clip(commands,
                          self.robot_hardware.joint_limits_min,
                          self.robot_hardware.joint_limits_max)

        # Joint velocity limits
        # (Would involve checking rate of change of commands)

        # Torque limits
        commands = np.clip(commands,
                          -self.robot_hardware.torque_limits,
                          self.robot_hardware.torque_limits)

        return commands
```

## 3. Multi-Rate Control Implementation

### Rate-Synchronized Control System

```python
import time
from collections import defaultdict, deque

class MultiRateControlSystem:
    def __init__(self):
        self.controllers = {}
        self.synchronization_manager = RateSynchronizer()
        self.state_buffers = defaultdict(lambda: deque(maxlen=100))

    def add_controller(self, name, controller, rate_hz):
        """
        Add a controller with specified rate
        """
        self.controllers[name] = {
            'controller': controller,
            'rate': rate_hz,
            'period': 1.0 / rate_hz,
            'last_update': 0,
            'enabled': True
        }

        # Register with synchronizer
        self.synchronization_manager.register_rate(name, rate_hz)

    def update(self, current_time):
        """
        Update controllers based on their rates
        """
        for name, config in self.controllers.items():
            if not config['enabled']:
                continue

            # Check if it's time to update this controller
            time_since_last = current_time - config['last_update']

            if time_since_last >= config['period']:
                # Update controller
                output = config['controller'].update(current_time)

                # Store in state buffer
                self.state_buffers[name].append({
                    'time': current_time,
                    'output': output
                })

                # Update last update time
                config['last_update'] = current_time

class RateSynchronizer:
    def __init__(self):
        self.rates = {}
        self.phase_offsets = {}
        self.base_rate = 1000  # Base rate in Hz

    def register_rate(self, name, rate_hz, phase_offset=0):
        """
        Register a rate with potential phase offset
        """
        self.rates[name] = rate_hz
        self.phase_offsets[name] = phase_offset

    def is_update_time(self, name, current_time):
        """
        Check if it's time to update the specified controller
        """
        rate = self.rates[name]
        period = 1.0 / rate
        phase_offset = self.phase_offsets[name]

        # Calculate expected update time
        expected_update = (current_time - phase_offset) // period
        last_update = getattr(self, f'last_{name}_update', -1)

        if expected_update > last_update:
            setattr(self, f'last_{name}_update', expected_update)
            return True
        return False

class MultiRateController:
    def __init__(self, system_state):
        self.system_state = system_state

        # Different controllers for different rates
        self.joint_control = JointController(dt=0.001)      # 1000 Hz
        self.balance_control = BalanceController(dt=0.005)  # 200 Hz
        self.task_control = TaskController(dt=0.02)         # 50 Hz
        self.planning_control = Planner(dt=0.1)             # 10 Hz

        # Timing management
        self.last_joint_update = 0
        self.last_balance_update = 0
        self.last_task_update = 0
        self.last_planning_update = 0

    def update_multi_rate(self, current_time):
        """
        Update different controllers at their respective rates
        """
        # Joint control (1000 Hz)
        if current_time - self.last_joint_update >= 0.001:
            joint_commands = self.joint_control.update(
                self.system_state['q'],
                self.system_state['q_dot'],
                self.system_state['desired_joint_positions']
            )
            self.last_joint_update = current_time

        # Balance control (200 Hz)
        if current_time - self.last_balance_update >= 0.005:
            balance_corrections = self.balance_control.update(
                self.system_state['com'],
                self.system_state['zmp'],
                self.system_state['support_polygon']
            )
            self.last_balance_update = current_time

        # Task control (50 Hz)
        if current_time - self.last_task_update >= 0.02:
            task_commands = self.task_control.update(
                self.system_state['task_reference'],
                self.system_state['current_task_state']
            )
            self.last_task_update = current_time

        # Planning control (10 Hz)
        if current_time - self.last_planning_update >= 0.1:
            planning_commands = self.planning_control.update(
                self.system_state['environment'],
                self.system_state['goals']
            )
            self.last_planning_update = current_time

        # Combine all commands appropriately
        return {
            'joint': joint_commands if 'joint_commands' in locals() else None,
            'balance': balance_corrections if 'balance_corrections' in locals() else None,
            'task': task_commands if 'task_commands' in locals() else None,
            'planning': planning_commands if 'planning_commands' in locals() else None
        }
```

## 4. Sensor Fusion and State Estimation Implementation

### Extended Kalman Filter for State Estimation

```python
import numpy as np
from scipy.linalg import block_diag

class ExtendedKalmanFilter:
    def __init__(self, n_states, n_observations):
        self.n_states = n_states
        self.n_observations = n_observations

        # State vector: [joint_positions, joint_velocities, com_position, com_velocity, orientation, angular_velocity]
        self.x = np.zeros(n_states)

        # State covariance matrix
        self.P = np.eye(n_states) * 1.0

        # Process noise covariance
        self.Q = np.eye(n_states) * 0.1

        # Measurement noise covariance
        self.R = np.eye(n_observations) * 1.0

        # Control input matrix (if applicable)
        self.B = None

    def predict(self, u=None, dt=0.001):
        """
        Prediction step of EKF
        """
        # State transition (simplified - in practice, use robot dynamics model)
        # x(k+1) = f(x(k), u(k))
        if u is not None and self.B is not None:
            self.x = self.state_transition_function(self.x, u) + self.B @ u
        else:
            self.x = self.state_transition_function(self.x)

        # Jacobian of state transition function
        F = self.jacobian_state_transition(self.x, u, dt)

        # Predict covariance
        self.P = F @ self.P @ F.T + self.Q

    def update(self, z):
        """
        Update step of EKF
        """
        # Measurement function: z = h(x)
        h_x = self.measurement_function(self.x)

        # Jacobian of measurement function
        H = self.jacobian_measurement(self.x)

        # Innovation
        y = z - h_x

        # Innovation covariance
        S = H @ self.P @ H.T + self.R

        # Kalman gain
        K = self.P @ H.T @ np.linalg.inv(S)

        # Update state
        self.x = self.x + K @ y

        # Update covariance (Joseph form for numerical stability)
        I_KH = np.eye(self.n_states) - K @ H
        self.P = I_KH @ self.P @ I_KH.T + K @ self.R @ K.T

    def state_transition_function(self, x, u=None):
        """
        Nonlinear state transition function
        """
        # Simplified example - in practice, use robot dynamics
        x_new = x.copy()

        # For joint positions: integrate velocities
        n_joints = len(x) // 2  # Assuming equal positions and velocities
        x_new[:n_joints] += x[n_joints:2*n_joints] * 0.001  # positions += velocities * dt

        # For velocities: integrate accelerations (simplified)
        # This would use robot dynamics model in practice

        return x_new

    def jacobian_state_transition(self, x, u, dt):
        """
        Jacobian of state transition function
        """
        F = np.eye(self.n_states)

        # Simplified Jacobian - in practice, derive from robot dynamics
        n_joints = len(x) // 2
        for i in range(n_joints):
            F[i, i + n_joints] = dt  # Partial derivative of position w.r.t. velocity

        return F

    def measurement_function(self, x):
        """
        Nonlinear measurement function
        """
        # Return only observable states
        # This is a simplified example
        return x[:self.n_observations]  # Return first n_observations elements

    def jacobian_measurement(self, x):
        """
        Jacobian of measurement function
        """
        H = np.zeros((self.n_observations, self.n_states))
        for i in range(self.n_observations):
            H[i, i] = 1.0  # Direct observation of first n_observations states

        return H

class SensorFusionSystem:
    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.n_joints = robot_model.n_joints

        # State dimension: positions + velocities + CoM + orientation
        self.state_dim = 2 * self.n_joints + 3 + 4  # +4 for quaternion
        self.obs_dim = self.n_joints * 2 + 6  # joint encoders + IMU

        # Extended Kalman Filter
        self.ekf = ExtendedKalmanFilter(self.state_dim, self.obs_dim)

        # Sensor buffers
        self.encoder_buffer = deque(maxlen=10)
        self.imu_buffer = deque(maxlen=10)
        self.force_buffer = deque(maxlen=10)

        # Timing
        self.last_update = time.time()

    def integrate_sensors(self, encoder_data, imu_data, force_data=None):
        """
        Integrate multiple sensor inputs using EKF
        """
        current_time = time.time()
        dt = current_time - self.last_update
        self.last_update = current_time

        # Prepare measurement vector
        z = self.prepare_measurement(encoder_data, imu_data, force_data)

        # Prediction step
        self.ekf.predict(dt=dt)

        # Update step
        self.ekf.update(z)

        # Return estimated state
        return self.ekf.x

    def prepare_measurement(self, encoder_data, imu_data, force_data):
        """
        Prepare measurement vector from sensor data
        """
        # Combine encoder and IMU data
        measurements = np.hstack([
            encoder_data['positions'],  # Joint positions
            encoder_data['velocities'], # Joint velocities (if available)
            imu_data['orientation'],    # IMU orientation
            imu_data['angular_velocity'], # IMU angular velocity
            imu_data['linear_acceleration'] # IMU linear acceleration
        ])

        return measurements

    def get_fused_state(self):
        """
        Get the current fused state estimate
        """
        return {
            'joint_positions': self.ekf.x[:self.n_joints],
            'joint_velocities': self.ekf.x[self.n_joints:2*self.n_joints],
            'com_position': self.ekf.x[2*self.n_joints:2*self.n_joints+3],
            'orientation': self.ekf.x[2*self.n_joints+3:2*self.n_joints+7],  # quaternion
            'confidence': np.diag(self.ekf.P)  # Uncertainty estimates
        }
```

## 5. Communication and Middleware Implementation

### ROS-Based Integration Framework

```python
#!/usr/bin/env python3
import rospy
import numpy as np
from std_msgs.msg import Float64MultiArray, Bool
from sensor_msgs.msg import JointState, Imu
from geometry_msgs.msg import Vector3, Pose
from control_msgs.msg import JointTrajectoryControllerState
import threading
import time

class ROSControlIntegration:
    def __init__(self):
        rospy.init_node('control_integration_node', anonymous=True)

        # Robot parameters
        self.joint_names = [
            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',
            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',
            'left_shoulder_joint', 'left_elbow_joint', 'right_shoulder_joint', 'right_elbow_joint'
        ]
        self.n_joints = len(self.joint_names)

        # State variables
        self.current_positions = np.zeros(self.n_joints)
        self.current_velocities = np.zeros(self.n_joints)
        self.current_efforts = np.zeros(self.n_joints)
        self.imu_data = {'orientation': [0, 0, 0, 1], 'angular_velocity': [0, 0, 0], 'linear_acceleration': [0, 0, 0]}

        # Control commands
        self.desired_positions = np.zeros(self.n_joints)
        self.desired_velocities = np.zeros(self.n_joints)

        # Publishers and subscribers
        self.joint_state_sub = rospy.Subscriber('/joint_states', JointState, self.joint_state_callback)
        self.imu_sub = rospy.Subscriber('/imu/data', Imu, self.imu_callback)
        self.command_pub = rospy.Publisher('/joint_group_position_controller/command', Float64MultiArray, queue_size=10)
        self.emergency_stop_pub = rospy.Publisher('/emergency_stop', Bool, queue_size=1)

        # Control system components
        self.hierarchical_controller = HierarchicalControlSystem(self.n_joints)
        self.state_estimator = SensorFusionSystem(self.n_joints)

        # Threading
        self.control_thread = None
        self.running = False
        self.emergency_stop_active = False

        # Control frequencies
        self.high_level_freq = 10   # Hz
        self.mid_level_freq = 200   # Hz
        self.low_level_freq = 1000  # Hz

    def joint_state_callback(self, msg):
        """
        Callback for joint state messages
        """
        for i, joint_name in enumerate(self.joint_names):
            try:
                idx = msg.name.index(joint_name)
                if idx < len(msg.position):
                    self.current_positions[i] = msg.position[idx]
                if idx < len(msg.velocity):
                    self.current_velocities[i] = msg.velocity[idx]
                if idx < len(msg.effort):
                    self.current_efforts[i] = msg.effort[idx]
            except ValueError:
                rospy.logwarn(f"Joint {joint_name} not found in joint state message")

    def imu_callback(self, msg):
        """
        Callback for IMU data
        """
        self.imu_data = {
            'orientation': [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w],
            'angular_velocity': [msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z],
            'linear_acceleration': [msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z]
        }

    def start_control(self):
        """
        Start the integrated control system
        """
        self.running = True

        # Start control threads
        self.control_thread = threading.Thread(target=self.control_loop)
        self.control_thread.start()

        rospy.loginfo("Control integration system started")

    def control_loop(self):
        """
        Main control integration loop
        """
        rate = rospy.Rate(self.low_level_freq)  # Use highest frequency

        while not rospy.is_shutdown() and self.running:
            try:
                if not self.emergency_stop_active:
                    # Integrate sensor data
                    sensor_data = {
                        'encoder': {'positions': self.current_positions, 'velocities': self.current_velocities},
                        'imu': self.imu_data
                    }

                    # Update state estimate
                    estimated_state = self.state_estimator.integrate_sensors(
                        sensor_data['encoder'], sensor_data['imu']
                    )

                    # Run hierarchical control
                    control_commands = self.hierarchical_controller.update_multi_rate(
                        time.time(), estimated_state
                    )

                    # Publish control commands
                    cmd_msg = Float64MultiArray()
                    cmd_msg.data = control_commands['joint'].tolist()
                    self.command_pub.publish(cmd_msg)

                rate.sleep()

            except Exception as e:
                rospy.logerr(f"Error in control loop: {e}")
                self.emergency_stop()
                break

    def emergency_stop(self):
        """
        Emergency stop function
        """
        rospy.logerr("Emergency stop activated!")
        self.emergency_stop_active = True

        # Publish zero commands
        zero_cmd = Float64MultiArray()
        zero_cmd.data = [0.0] * self.n_joints
        self.command_pub.publish(zero_cmd)

        # Publish emergency stop signal
        stop_msg = Bool()
        stop_msg.data = True
        self.emergency_stop_pub.publish(stop_msg)

class ControlIntegrationNode:
    def __init__(self):
        # Initialize the ROS integration system
        self.ros_integration = ROSControlIntegration()

        # Initialize other integration components
        self.safety_manager = SafetyManager()
        self.performance_monitor = PerformanceMonitor()

    def run(self):
        """
        Run the complete integration system
        """
        # Start ROS integration
        self.ros_integration.start_control()

        # Main loop for monitoring and management
        rate = rospy.Rate(1)  # 1 Hz for monitoring

        while not rospy.is_shutdown():
            # Monitor system performance
            performance_data = self.performance_monitor.get_performance_data()

            # Check safety conditions
            safety_status = self.safety_manager.check_safety()

            if not safety_status['safe']:
                rospy.logerr("Safety violation detected, initiating safe shutdown")
                self.ros_integration.emergency_stop()
                break

            rate.sleep()
```

## 6. Safety and Fault Tolerance Implementation

### Safety Manager and Fault Detection

```python
class SafetyManager:
    def __init__(self):
        # Safety limits
        self.joint_position_limits = {
            'min': np.full(10, -3.14),  # Example: 10 joints
            'max': np.full(10, 3.14)
        }
        self.joint_velocity_limits = np.full(10, 10.0)  # rad/s
        self.joint_torque_limits = np.full(10, 100.0)   # Nm
        self.com_limits = {
            'x': (-0.5, 0.5),
            'y': (-0.3, 0.3),
            'z': (0.5, 1.5)
        }

        # Safety state
        self.safety_violations = []
        self.emergency_active = False
        self.last_safe_state = None

        # Fault detection
        self.fault_detectors = {
            'joint_limits': JointLimitDetector(),
            'balance': BalanceDetector(),
            'communication': CommunicationDetector(),
            'hardware': HardwareDetector()
        }

    def check_safety(self, robot_state):
        """
        Check if current robot state is safe
        """
        safety_report = {
            'joint_position_safe': True,
            'joint_velocity_safe': True,
            'joint_torque_safe': True,
            'balance_safe': True,
            'communication_safe': True,
            'hardware_safe': True,
            'overall_safe': True
        }

        # Check joint positions
        for i, pos in enumerate(robot_state['positions']):
            if (pos < self.joint_position_limits['min'][i] or
                pos > self.joint_position_limits['max'][i]):
                safety_report['joint_position_safe'] = False
                safety_report['overall_safe'] = False
                self.safety_violations.append(f'Joint {i} position limit violation')

        # Check joint velocities
        for i, vel in enumerate(robot_state['velocities']):
            if abs(vel) > self.joint_velocity_limits[i]:
                safety_report['joint_velocity_safe'] = False
                safety_report['overall_safe'] = False
                self.safety_violations.append(f'Joint {i} velocity limit violation')

        # Check joint torques
        if 'torques' in robot_state:
            for i, torque in enumerate(robot_state['torques']):
                if abs(torque) > self.joint_torque_limits[i]:
                    safety_report['joint_torque_safe'] = False
                    safety_report['overall_safe'] = False
                    self.safety_violations.append(f'Joint {i} torque limit violation')

        # Check balance (CoM within limits)
        com = robot_state.get('com', [0, 0, 0])
        if (com[0] < self.com_limits['x'][0] or com[0] > self.com_limits['x'][1] or
            com[1] < self.com_limits['y'][0] or com[1] > self.com_limits['y'][1] or
            com[2] < self.com_limits['z'][0] or com[2] > self.com_limits['z'][1]):
            safety_report['balance_safe'] = False
            safety_report['overall_safe'] = False
            self.safety_violations.append('Center of mass out of safe limits')

        return safety_report

    def handle_safety_violation(self, violation_type, severity='medium'):
        """
        Handle safety violations with appropriate response
        """
        if severity == 'critical':
            self.emergency_stop()
        elif severity == 'high':
            self.safe_stop()
        elif severity == 'medium':
            self.log_violation(violation_type)
        # Low severity: just log

    def emergency_stop(self):
        """
        Immediate emergency stop
        """
        self.emergency_active = True
        self.last_safe_state = None
        # Implementation would send immediate stop commands to hardware

    def safe_stop(self):
        """
        Controlled safe stop
        """
        # Gradually reduce control commands to zero
        pass

    def log_violation(self, violation_type):
        """
        Log safety violation for analysis
        """
        timestamp = time.time()
        self.safety_violations.append({
            'type': violation_type,
            'time': timestamp,
            'handled': False
        })

class FaultDetector:
    def __init__(self):
        self.fault_history = deque(maxlen=1000)
        self.last_detection_time = time.time()

    def detect_fault(self, sensor_data, control_data):
        """
        Detect faults in the system
        """
        raise NotImplementedError

class JointLimitDetector(FaultDetector):
    def detect_fault(self, sensor_data, control_data):
        """
        Detect joint limit violations
        """
        fault_detected = False
        fault_details = []

        positions = sensor_data.get('positions', [])
        position_limits = control_data.get('position_limits', {})

        for i, pos in enumerate(positions):
            if i in position_limits:
                if pos < position_limits[i]['min'] * 0.95 or pos > position_limits[i]['max'] * 0.95:
                    fault_detected = True
                    fault_details.append({
                        'joint': i,
                        'type': 'approaching_limit',
                        'position': pos,
                        'limit': (position_limits[i]['min'], position_limits[i]['max'])
                    })

        if fault_detected:
            self.fault_history.append({
                'type': 'joint_limit',
                'details': fault_details,
                'time': time.time()
            })

        return fault_detected, fault_details

class BalanceDetector(FaultDetector):
    def __init__(self, stability_threshold=0.1):
        super().__init__()
        self.stability_threshold = stability_threshold

    def detect_fault(self, sensor_data, control_data):
        """
        Detect balance stability issues
        """
        com = sensor_data.get('com', [0, 0, 0])
        zmp = sensor_data.get('zmp', [0, 0])
        support_polygon = control_data.get('support_polygon', [])

        # Calculate distance from ZMP to support polygon
        zmp_distance = self.distance_to_polygon(zmp, support_polygon)

        fault_detected = zmp_distance > self.stability_threshold
        fault_details = {
            'zmp_distance': zmp_distance,
            'stability_threshold': self.stability_threshold,
            'zmp': zmp,
            'com': com
        }

        if fault_detected:
            self.fault_history.append({
                'type': 'balance',
                'details': fault_details,
                'time': time.time()
            })

        return fault_detected, fault_details

    def distance_to_polygon(self, point, polygon):
        """
        Calculate distance from point to polygon (simplified)
        """
        # This is a simplified implementation
        # In practice, use computational geometry libraries
        if len(polygon) == 0:
            return float('inf')

        min_distance = float('inf')
        for vertex in polygon:
            distance = np.linalg.norm(np.array(point) - np.array(vertex))
            min_distance = min(min_distance, distance)

        return min_distance
```

## 7. Performance Monitoring and Optimization

### Performance Monitoring System

```python
import psutil
import time
from collections import deque

class PerformanceMonitor:
    def __init__(self):
        self.metrics = {
            'cpu_usage': deque(maxlen=100),
            'memory_usage': deque(maxlen=100),
            'control_loop_times': deque(maxlen=100),
            'communication_delays': deque(maxlen=100),
            'task_completion_rates': deque(maxlen=100)
        }

        self.start_time = time.time()
        self.control_loop_count = 0
        self.last_metrics_time = time.time()

    def start_monitoring(self):
        """
        Start performance monitoring
        """
        self.start_time = time.time()

    def record_control_loop_time(self, loop_time):
        """
        Record control loop execution time
        """
        self.metrics['control_loop_times'].append(loop_time)
        self.control_loop_count += 1

    def record_communication_delay(self, delay):
        """
        Record communication delay
        """
        self.metrics['communication_delays'].append(delay)

    def get_performance_data(self):
        """
        Get current performance metrics
        """
        current_time = time.time()

        # CPU and memory usage
        cpu_percent = psutil.cpu_percent()
        memory_percent = psutil.virtual_memory().percent

        self.metrics['cpu_usage'].append(cpu_percent)
        self.metrics['memory_usage'].append(memory_percent)

        # Calculate derived metrics
        avg_loop_time = np.mean(self.metrics['control_loop_times']) if self.metrics['control_loop_times'] else 0
        max_loop_time = np.max(self.metrics['control_loop_times']) if self.metrics['control_loop_times'] else 0
        deadline_misses = sum(1 for t in self.metrics['control_loop_times'] if t > 0.001)  # Assuming 1kHz control

        performance_data = {
            'cpu_usage_percent': cpu_percent,
            'memory_usage_percent': memory_percent,
            'average_loop_time_ms': avg_loop_time * 1000,
            'max_loop_time_ms': max_loop_time * 1000,
            'deadline_misses': deadline_misses,
            'loop_frequency_actual': self.control_loop_count / (current_time - self.start_time),
            'uptime_seconds': current_time - self.start_time,
            'total_control_loops': self.control_loop_count
        }

        return performance_data

    def check_performance_degradation(self):
        """
        Check if performance is degrading
        """
        if len(self.metrics['control_loop_times']) < 10:
            return False

        recent_avg = np.mean(list(self.metrics['control_loop_times'])[-10:])
        historical_avg = np.mean(list(self.metrics['control_loop_times'])[:-10]) if len(self.metrics['control_loop_times']) > 10 else recent_avg

        # If recent performance is significantly worse than historical
        degradation_threshold = 1.5  # 50% slower
        return recent_avg > degradation_threshold * historical_avg

class ResourceOptimizer:
    def __init__(self):
        self.performance_monitor = PerformanceMonitor()
        self.resource_allocation = {}
        self.optimization_enabled = True

    def optimize_resources(self):
        """
        Optimize resource allocation based on performance
        """
        if not self.optimization_enabled:
            return

        performance_data = self.performance_monitor.get_performance_data()

        # Adjust control frequencies based on resource usage
        if performance_data['cpu_usage_percent'] > 80:
            # Reduce control frequencies to save CPU
            self.throttle_control_rates()
        elif performance_data['cpu_usage_percent'] < 50:
            # Increase control frequencies if CPU available
            self.increase_control_rates()

        # Memory optimization
        if performance_data['memory_usage_percent'] > 85:
            self.reduce_memory_footprint()

    def throttle_control_rates(self):
        """
        Reduce control update rates to save resources
        """
        # Implementation would adjust controller frequencies
        pass

    def increase_control_rates(self):
        """
        Increase control update rates when resources available
        """
        # Implementation would increase controller frequencies
        pass

    def reduce_memory_footprint(self):
        """
        Reduce memory usage by clearing unnecessary buffers
        """
        # Clear old data from buffers
        for metric_name, buffer in self.performance_monitor.metrics.items():
            if hasattr(buffer, 'maxlen'):
                # Keep only recent data
                recent_data = list(buffer)[-int(buffer.maxlen * 0.5):]
                buffer.clear()
                buffer.extend(recent_data)
```

## 8. Testing and Validation Framework

### Integration Testing Framework

```python
import unittest
import numpy as np

class ControlIntegrationTester:
    def __init__(self, control_system):
        self.control_system = control_system
        self.test_results = {}

    def run_integration_tests(self):
        """
        Run comprehensive integration tests
        """
        test_suite = [
            self.test_hierarchical_control,
            self.test_multi_rate_synchronization,
            self.test_sensor_fusion,
            self.test_safety_system,
            self.test_communication,
            self.test_performance
        ]

        results = {}
        for test_func in test_suite:
            try:
                result = test_func()
                results[test_func.__name__] = {
                    'status': 'PASS' if result else 'FAIL',
                    'details': result if isinstance(result, dict) else {}
                }
            except Exception as e:
                results[test_func.__name__] = {
                    'status': 'ERROR',
                    'details': {'error': str(e)}
                }

        self.test_results = results
        return results

    def test_hierarchical_control(self):
        """
        Test hierarchical control functionality
        """
        # Simulate system state
        test_state = {
            'q': np.zeros(self.control_system.n_joints),
            'q_dot': np.zeros(self.control_system.n_joints),
            'com': np.array([0, 0, 0.8]),
            'zmp': np.array([0, 0])
        }

        # Test control integration
        try:
            control_output = self.control_system.hierarchical_controller.update_multi_rate(
                time.time(), test_state
            )

            # Check if control output is reasonable
            if control_output is not None:
                return {'success': True, 'output_shape': control_output['joint'].shape}
            else:
                return {'success': False, 'error': 'No control output'}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def test_multi_rate_synchronization(self):
        """
        Test multi-rate control synchronization
        """
        # Test rate synchronization
        synchronizer = self.control_system.synchronization_manager

        # Check if rates are properly registered
        expected_rates = {'high': 1000, 'mid': 200, 'low': 50}

        for name, expected_rate in expected_rates.items():
            if name in synchronizer.rates:
                actual_rate = synchronizer.rates[name]
                if abs(actual_rate - expected_rate) < 1:  # Allow 1Hz tolerance
                    continue
                else:
                    return {'success': False, 'error': f'Rate mismatch for {name}'}
            else:
                return {'success': False, 'error': f'Rate {name} not registered'}

        return {'success': True, 'rates': dict(synchronizer.rates)}

    def test_safety_system(self):
        """
        Test safety system functionality
        """
        safety_manager = self.control_system.safety_manager

        # Test safety check with safe state
        safe_state = {
            'positions': np.zeros(self.control_system.n_joints),
            'velocities': np.zeros(self.control_system.n_joints),
            'com': np.array([0, 0, 0.8])
        }

        safety_report = safety_manager.check_safety(safe_state)

        if safety_report['overall_safe']:
            return {'success': True, 'safety_report': safety_report}
        else:
            return {'success': False, 'safety_report': safety_report}

class IntegrationTestSuite(unittest.TestCase):
    def setUp(self):
        # Setup test environment
        self.control_system = HierarchicalControlSystem(robot_model=None)
        self.tester = ControlIntegrationTester(self.control_system)

    def test_end_to_end_integration(self):
        """
        Test end-to-end integration
        """
        results = self.tester.run_integration_tests()

        # Check that all tests passed
        all_passed = all(result['status'] == 'PASS' for result in results.values())

        self.assertTrue(all_passed, f"Some integration tests failed: {results}")

    def test_real_time_performance(self):
        """
        Test real-time performance requirements
        """
        start_time = time.time()

        # Run control loop for 1 second
        for i in range(1000):  # 1000 iterations at 1kHz
            # Simulate control update
            loop_start = time.time()
            # Control logic would go here
            loop_time = time.time() - loop_start

            # Check if loop meets timing requirement (should be < 1ms for 1kHz)
            self.assertLess(loop_time, 0.002, f"Loop {i} took too long: {loop_time*1000:.2f}ms")

        total_time = time.time() - start_time
        self.assertLess(total_time, 1.1, f"1000 loops took too long: {total_time:.2f}s")

# Run tests if this file is executed directly
if __name__ == '__main__':
    unittest.main()
```

This implementation section provides practical examples of control system integration for humanoid robots, including hierarchical control architectures, multi-rate control systems, sensor fusion, communication frameworks, safety systems, and performance monitoring. The code demonstrates how theoretical integration concepts are translated into executable implementations that can coordinate multiple control components in real robotic systems.