---
title: 2.2 Whole-Body Motion Planning Implementation and Practical Applications
sidebar_position: 5
---

# 2.2 Whole-Body Motion Planning Implementation and Practical Applications

## Learning Objectives
- Implement whole-body motion planning algorithms for real humanoid robots
- Understand multi-task optimization and hierarchical control
- Apply whole-body planning methods using ROS and Python
- Integrate planning with perception and control systems
- Develop practical implementations for manipulation and locomotion

## Introduction

Implementing whole-body motion planning for humanoid robots requires sophisticated integration of multiple control and planning components to coordinate all degrees of freedom simultaneously. Unlike single-limb planning, whole-body planning must consider the complex interdependencies between all joints, maintain dynamic balance, and coordinate multiple tasks such as manipulation, locomotion, and balance. This section provides practical guidance on implementing whole-body motion planning systems, with specific focus on software frameworks, optimization techniques, and real-world deployment considerations.

The implementation of whole-body motion planning involves several key components: hierarchical task controllers, optimization solvers, kinematic and dynamic models, and integration with perception and control systems. Modern humanoid robots like Atlas, HRP-4, and NAO demonstrate successful implementation of complex whole-body planning algorithms for tasks ranging from dynamic walking to dual-arm manipulation.

## 1. Mathematical Framework Implementation

### Task-Based Control Implementation

```python
import numpy as np
import scipy.optimize
from scipy.spatial.transform import Rotation as R

class TaskBasedController:
    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.n_joints = robot_model.n_joints
        self.tasks = []
        self.weights = []

    def add_task(self, task_jacobian, task_desired, weight=1.0, priority=0):
        """
        Add a task to the controller
        """
        task = {
            'jacobian': task_jacobian,
            'desired': task_desired,
            'weight': weight,
            'priority': priority
        }
        self.tasks.append(task)
        self.weights.append(weight)

        # Sort tasks by priority
        sorted_indices = sorted(range(len(self.tasks)),
                               key=lambda i: self.tasks[i]['priority'])
        self.tasks = [self.tasks[i] for i in sorted_indices]
        self.weights = [self.weights[i] for i in sorted_indices]

    def compute_null_space_projection(self, jacobian):
        """
        Compute null space projection matrix
        """
        # P = I - J⁺J where J⁺ is pseudoinverse
        j_pinv = np.linalg.pinv(jacobian)
        identity = np.eye(self.n_joints)
        return identity - np.dot(j_pinv, jacobian)

    def solve_multi_task(self, current_joints):
        """
        Solve multi-task optimization problem
        """
        # Initialize joint velocity
        q_dot = np.zeros(self.n_joints)

        # Process tasks in order of priority
        for i, task in enumerate(self.tasks):
            jacobian = task['jacobian']
            desired = task['desired']
            weight = task['weight']

            # Compute task error
            error = desired - np.dot(jacobian, q_dot)

            # Apply task in current null space
            if i == 0:
                # First task: no null space constraint
                j_pinv = np.linalg.pinv(jacobian)
                q_dot_task = np.dot(j_pinv, desired)
            else:
                # Subsequent tasks: apply in null space of previous tasks
                # Compute null space projection
                j_pinv = np.linalg.pinv(jacobian)
                q_dot_task = np.dot(j_pinv, error)

                # Apply null space projection
                for prev_task in self.tasks[:i]:
                    prev_jacobian = prev_task['jacobian']
                    null_proj = self.compute_null_space_projection(prev_jacobian)
                    q_dot_task = np.dot(null_proj, q_dot_task)

            # Add weighted contribution to total velocity
            q_dot += weight * q_dot_task

        return q_dot

# Example: End-effector position task
def create_end_effector_task(robot_model, joint_angles, target_position, link_name):
    """
    Create a task for end-effector positioning
    """
    # Compute forward kinematics
    ee_position, ee_orientation = robot_model.forward_kinematics(
        joint_angles, link_name
    )

    # Compute Jacobian for end-effector
    jacobian = robot_model.compute_jacobian(joint_angles, link_name)

    # Extract position part of Jacobian (first 3 rows)
    position_jacobian = jacobian[:3, :]

    # Compute desired velocity to reach target
    position_error = target_position - ee_position
    desired_velocity = position_error * 0.1  # Proportional control gain

    return position_jacobian, desired_velocity
```

### Whole-Body Optimization Implementation

```python
import cvxpy as cp

class WholeBodyOptimizer:
    def __init__(self, robot_model, dt=0.01):
        self.robot_model = robot_model
        self.dt = dt
        self.n_joints = robot_model.n_joints

    def optimize_motion(self, current_state, tasks, constraints=None):
        """
        Optimize whole-body motion using quadratic programming
        """
        # Decision variables: joint accelerations
        q_ddot = cp.Variable(self.n_joints)

        # Cost function components
        cost_terms = []

        # Task tracking costs
        for task in tasks:
            jacobian = task['jacobian']
            desired_accel = task['desired_acceleration']
            weight = task['weight']

            task_accel = jacobian @ q_ddot
            cost_terms.append(weight * cp.sum_squares(task_accel - desired_accel))

        # Regularization: minimize joint accelerations
        cost_terms.append(0.01 * cp.sum_squares(q_ddot))

        # Joint limit costs
        joint_limits = self.robot_model.joint_limits
        for i in range(self.n_joints):
            # Penalize approaching joint limits
            if current_state['position'][i] < joint_limits[i][0] + 0.1:
                cost_terms.append(100 * cp.max([0, joint_limits[i][0] - current_state['position'][i] - q_ddot[i] * self.dt**2]))
            elif current_state['position'][i] > joint_limits[i][1] - 0.1:
                cost_terms.append(100 * cp.max([0, current_state['position'][i] + q_ddot[i] * self.dt**2 - joint_limits[i][1]]))

        # Formulate and solve optimization problem
        objective = cp.Minimize(cp.sum(cost_terms))

        # Constraints
        constraints_list = []

        # If provided, add additional constraints
        if constraints:
            constraints_list.extend(constraints)

        # Solve the problem
        problem = cp.Problem(objective, constraints_list)
        problem.solve()

        if problem.status not in ["infeasible", "unbounded"]:
            return q_ddot.value
        else:
            # Return zero acceleration if optimization fails
            return np.zeros(self.n_joints)

# Balance maintenance task
class BalanceTask:
    def __init__(self, robot_model):
        self.robot_model = robot_model

    def compute_balance_jacobian(self, joint_angles):
        """
        Compute Jacobian for center of mass control
        """
        # Compute CoM position and Jacobian
        com_pos, com_jacobian = self.robot_model.compute_com_jacobian(joint_angles)
        return com_jacobian[:2, :]  # Only x, y components for balance

    def compute_desired_com_motion(self, current_com, support_polygon):
        """
        Compute desired CoM motion for balance maintenance
        """
        # Simple balance control: keep CoM within support polygon
        # Find closest point in support polygon
        closest_point = self.find_closest_point_in_polygon(
            current_com[:2], support_polygon
        )

        # Compute desired velocity toward stable point
        desired_velocity = 2.0 * (closest_point - current_com[:2])
        return desired_velocity

    def find_closest_point_in_polygon(self, point, polygon):
        """
        Find closest point to polygon (simplified implementation)
        """
        # For now, return centroid of polygon as approximation
        if len(polygon) > 0:
            centroid = np.mean(polygon, axis=0)
            return centroid
        else:
            return point  # Return original point if no polygon
```

## 2. Model Predictive Control Implementation

### Whole-Body MPC Framework

```python
class WholeBodyMPC:
    def __init__(self, robot_model, horizon=10, dt=0.01):
        self.robot_model = robot_model
        self.horizon = horizon
        self.dt = dt
        self.n_joints = robot_model.n_joints

    def solve_mpc_problem(self, current_state, reference_trajectory):
        """
        Solve whole-body MPC optimization problem
        """
        # Create optimization variables for entire horizon
        q = cp.Variable((self.n_joints, self.horizon))
        q_dot = cp.Variable((self.n_joints, self.horizon))
        q_ddot = cp.Variable((self.n_joints, self.horizon))

        # Cost function
        cost = 0

        # Tracking costs for each time step
        for k in range(self.horizon):
            # Task tracking
            for task_idx, task in enumerate(reference_trajectory['tasks'][k]):
                jacobian = task['jacobian']
                desired = task['desired']
                weight = task['weight']

                task_value = jacobian @ q[:, k]
                cost += weight * cp.sum_squares(task_value - desired)

            # Regularization
            cost += 0.01 * cp.sum_squares(q_ddot[:, k])
            cost += 0.001 * cp.sum_squares(q_dot[:, k])

        # Dynamics constraints
        constraints = []

        # Initial state constraints
        constraints.append(q[:, 0] == current_state['position'])
        constraints.append(q_dot[:, 0] == current_state['velocity'])

        # Dynamics integration
        for k in range(self.horizon - 1):
            # Simple Euler integration
            constraints.append(q[:, k+1] == q[:, k] + q_dot[:, k] * self.dt)
            constraints.append(q_dot[:, k+1] == q_dot[:, k] + q_ddot[:, k] * self.dt)

        # Joint limits
        joint_limits = self.robot_model.joint_limits
        for k in range(self.horizon):
            for j in range(self.n_joints):
                constraints.append(q[j, k] >= joint_limits[j][0])
                constraints.append(q[j, k] <= joint_limits[j][1])

        # Formulate and solve problem
        problem = cp.Problem(cp.Minimize(cost), constraints)
        problem.solve()

        if problem.status == cp.OPTIMAL:
            # Return first control action
            return q_ddot[:, 0].value
        else:
            return np.zeros(self.n_joints)
```

## 3. ROS Implementation for Whole-Body Planning

### Whole-Body Planning Node

```python
#!/usr/bin/env python3

import rospy
import numpy as np
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Pose, Twist
from std_msgs.msg import Float64MultiArray
from humanoid_wholebody_planning.msg import WholeBodyCommand
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint

class WholeBodyPlanningNode:
    def __init__(self):
        rospy.init_node('wholebody_planning_node')

        # Initialize components
        self.task_controller = TaskBasedController(robot_model=self.load_robot_model())
        self.wholebody_optimizer = WholeBodyOptimizer(robot_model=self.load_robot_model())
        self.mpc_controller = WholeBodyMPC(robot_model=self.load_robot_model())

        # Publishers
        self.command_pub = rospy.Publisher('/wholebody/command', WholeBodyCommand, queue_size=10)
        self.joint_trajectory_pub = rospy.Publisher('/joint_trajectory', JointTrajectory, queue_size=10)

        # Subscribers
        self.joint_state_sub = rospy.Publisher('/joint_states', JointState, self.joint_state_callback)
        self.task_sub = rospy.Publisher('/wholebody/tasks', Float64MultiArray, self.task_callback)
        self.balance_sub = rospy.Publisher('/balance/reference', Pose, self.balance_callback)

        # Current state
        self.current_joints = None
        self.current_tasks = []
        self.current_balance_ref = None

        # Control parameters
        self.control_rate = rospy.Rate(100)  # 100 Hz control
        self.integration_dt = 0.01  # 10ms integration step

    def load_robot_model(self):
        """
        Load robot kinematic and dynamic model
        """
        # This would typically load from URDF or other robot description
        # For this example, we'll create a mock robot model
        class MockRobotModel:
            def __init__(self):
                self.n_joints = 28  # Example for humanoid
                self.joint_limits = [(-3.14, 3.14)] * 28  # Example limits

            def forward_kinematics(self, joint_angles, link_name):
                # Mock implementation
                return np.zeros(3), np.eye(3)  # position, orientation

            def compute_jacobian(self, joint_angles, link_name):
                # Mock implementation
                return np.random.rand(6, 28)  # 6x28 Jacobian

            def compute_com_jacobian(self, joint_angles):
                # Mock implementation
                return np.zeros(3), np.random.rand(3, 28)

        return MockRobotModel()

    def joint_state_callback(self, msg):
        """
        Update current joint state
        """
        self.current_joints = np.array(msg.position)

    def task_callback(self, msg):
        """
        Receive task specifications
        """
        # Parse task information from message
        # Format: [task_type, link_index, x, y, z, weight, priority, ...]
        self.current_tasks = self.parse_tasks(msg.data)

    def balance_callback(self, msg):
        """
        Receive balance reference
        """
        self.current_balance_ref = np.array([
            msg.position.x, msg.position.y, msg.position.z
        ])

    def parse_tasks(self, task_data):
        """
        Parse task specification from message data
        """
        tasks = []
        i = 0
        while i < len(task_data):
            task_type = int(task_data[i])
            link_idx = int(task_data[i+1])
            desired_pos = np.array([task_data[i+2], task_data[i+3], task_data[i+4]])
            weight = task_data[i+5]
            priority = int(task_data[i+6])

            tasks.append({
                'type': task_type,
                'link_idx': link_idx,
                'desired_pos': desired_pos,
                'weight': weight,
                'priority': priority
            })

            i += 7  # Move to next task

        return tasks

    def compute_wholebody_motion(self):
        """
        Compute whole-body motion based on current tasks
        """
        if self.current_joints is None:
            return None

        # Create tasks for controller
        controller_tasks = []

        # Add balance task if available
        if self.current_balance_ref is not None:
            balance_task = BalanceTask(self.task_controller.robot_model)
            balance_jac = balance_task.compute_balance_jacobian(self.current_joints)
            balance_desired = balance_task.compute_desired_com_motion(
                self.current_balance_ref, []
            )

            controller_tasks.append({
                'jacobian': balance_jac,
                'desired': balance_desired,
                'weight': 10.0,
                'priority': 0
            })

        # Add other tasks
        for task in self.current_tasks:
            # Create Jacobian based on task type
            if task['type'] == 0:  # Position task
                link_name = f"link_{task['link_idx']}"
                jacobian, desired_vel = create_end_effector_task(
                    self.task_controller.robot_model,
                    self.current_joints,
                    task['desired_pos'],
                    link_name
                )

                controller_tasks.append({
                    'jacobian': jacobian,
                    'desired': desired_vel,
                    'weight': task['weight'],
                    'priority': task['priority']
                })

        # Solve multi-task optimization
        joint_velocities = self.task_controller.solve_multi_task(self.current_joints)

        # Integrate to get new positions
        new_positions = self.current_joints + joint_velocities * self.integration_dt

        return new_positions

    def publish_trajectory(self, positions):
        """
        Publish joint trajectory command
        """
        trajectory = JointTrajectory()
        trajectory.joint_names = [f'joint_{i}' for i in range(len(positions))]

        point = JointTrajectoryPoint()
        point.positions = positions.tolist()
        point.time_from_start = rospy.Duration(self.integration_dt)

        trajectory.points.append(point)

        self.joint_trajectory_pub.publish(trajectory)

    def run(self):
        """
        Main control loop
        """
        rospy.loginfo("Whole-body planning node started")

        while not rospy.is_shutdown():
            # Compute whole-body motion
            new_positions = self.compute_wholebody_motion()

            if new_positions is not None:
                # Publish trajectory command
                self.publish_trajectory(new_positions)

            self.control_rate.sleep()

if __name__ == '__main__':
    try:
        wb_planner = WholeBodyPlanningNode()
        wb_planner.run()
    except rospy.ROSInterruptException:
        pass
```

## 4. Balance and Locomotion Integration

### Balance Controller Implementation

```python
class BalanceController:
    def __init__(self, robot_model, control_frequency=100):
        self.robot_model = robot_model
        self.control_frequency = control_frequency
        self.dt = 1.0 / control_frequency

        # ZMP controller gains
        self.kp_zmp = 100.0
        self.kd_zmp = 10.0

        # State estimation
        self.com_filter = self.initialize_com_filter()
        self.zmp_filter = self.initialize_zmp_filter()

    def initialize_com_filter(self):
        """
        Initialize filter for center of mass estimation
        """
        # Simple low-pass filter or Kalman filter
        return {
            'position': np.zeros(3),
            'velocity': np.zeros(3),
            'acceleration': np.zeros(3)
        }

    def compute_zmp(self, com_pos, com_acc, gravity=9.81):
        """
        Compute Zero Moment Point from CoM state
        """
        zmp_x = com_pos[0] - (com_acc[0] * com_pos[2]) / gravity
        zmp_y = com_pos[1] - (com_acc[1] * com_pos[2]) / gravity

        return np.array([zmp_x, zmp_y])

    def compute_balance_control(self, current_state, support_polygon):
        """
        Compute balance control torques
        """
        # Get current CoM
        com_pos = self.estimate_com_position(current_state)
        com_vel = self.estimate_com_velocity(current_state)
        com_acc = self.estimate_com_acceleration(current_state)

        # Compute current ZMP
        current_zmp = self.compute_zmp(com_pos, com_acc)

        # Compute ZMP error
        desired_zmp = self.compute_desired_zmp(support_polygon)
        zmp_error = desired_zmp - current_zmp

        # Compute corrective CoM acceleration
        com_acc_correction = (
            self.kp_zmp * zmp_error +
            self.kd_zmp * (np.zeros(2) - com_vel[:2])  # Zero desired velocity
        ) / com_pos[2] * 9.81  # Scale by height

        # Create balance task
        balance_task = {
            'type': 'balance',
            'jacobian': self.compute_com_jacobian(current_state),
            'desired_acceleration': np.hstack([com_acc_correction, np.array([0])]),  # Only x,y correction
            'weight': 100.0
        }

        return balance_task

    def estimate_com_position(self, joint_state):
        """
        Estimate center of mass position from joint configuration
        """
        # This would use the robot model to compute CoM
        # For now, return a mock implementation
        return np.array([0.0, 0.0, 0.8])  # Example CoM at 80cm height

    def compute_com_jacobian(self, joint_state):
        """
        Compute CoM Jacobian matrix
        """
        # This would use the robot model to compute CoM Jacobian
        # For now, return a mock implementation
        return np.random.rand(3, self.robot_model.n_joints)

# Walking pattern generator
class WalkingPatternGenerator:
    def __init__(self, step_length=0.3, step_height=0.05, step_time=0.8):
        self.step_length = step_length
        self.step_height = step_height
        self.step_time = step_time
        self.foot_separation = 0.2  # Distance between feet

    def generate_footsteps(self, start_pos, goal_pos, step_size=0.3):
        """
        Generate sequence of footsteps from start to goal
        """
        footsteps = []

        # Calculate number of steps needed
        distance = np.linalg.norm(goal_pos[:2] - start_pos[:2])
        n_steps = int(np.ceil(distance / step_size))

        # Generate intermediate positions
        for i in range(n_steps):
            alpha = (i + 1) / n_steps
            pos = start_pos + alpha * (goal_pos - start_pos)

            # Alternate feet
            foot_offset = self.foot_separation / 2 if i % 2 == 0 else -self.foot_separation / 2
            pos[1] += foot_offset  # Lateral offset for alternating feet

            footsteps.append({
                'position': pos,
                'step_time': self.step_time,
                'step_idx': i
            })

        return footsteps

    def generate_com_trajectory(self, footsteps):
        """
        Generate CoM trajectory for stable walking
        """
        # Generate smooth CoM trajectory that maintains balance
        # This would implement inverted pendulum model or similar
        com_trajectory = []

        for i, step in enumerate(footsteps):
            # Simple model: CoM follows a smooth path
            com_pos = np.copy(step['position'])
            com_pos[2] = 0.8  # Maintain constant height

            com_trajectory.append({
                'position': com_pos,
                'time': i * step['step_time']
            })

        return com_trajectory
```

## 5. Performance Optimization

### Efficient Computation Techniques

```python
import multiprocessing as mp
from concurrent.futures import ThreadPoolExecutor
import time

class OptimizedWholeBodyPlanner:
    def __init__(self, num_threads=4):
        self.executor = ThreadPoolExecutor(max_workers=num_threads)
        self.task_controller = TaskBasedController(robot_model=None)  # Will be set later

    def parallel_task_processing(self, tasks, current_joints):
        """
        Process tasks in parallel when possible
        """
        # Group tasks by independence
        independent_tasks = self.group_independent_tasks(tasks)

        results = []
        for task_group in independent_tasks:
            # Process each group in parallel
            futures = []
            for task in task_group:
                future = self.executor.submit(
                    self.process_single_task, task, current_joints
                )
                futures.append(future)

            # Collect results
            for future in futures:
                results.append(future.result())

        return results

    def group_independent_tasks(self, tasks):
        """
        Group tasks that can be processed independently
        """
        # For now, return all tasks in one group
        # In practice, this would analyze task dependencies
        return [tasks]

    def process_single_task(self, task, current_joints):
        """
        Process a single task (placeholder implementation)
        """
        # Compute task-specific solution
        return np.zeros(self.task_controller.n_joints)

# Caching for repeated computations
class CachedWholeBodyPlanner:
    def __init__(self, cache_size=100):
        self.cache = {}
        self.cache_order = []
        self.cache_size = cache_size

    def plan_with_cache(self, state, tasks, plan_func):
        """
        Plan motion with caching of previous results
        """
        # Create cache key from state and tasks
        cache_key = self.create_cache_key(state, tasks)

        if cache_key in self.cache:
            return self.cache[cache_key]

        # Plan new motion
        result = plan_func(state, tasks)

        # Store in cache with LRU eviction
        if len(self.cache) >= self.cache_size:
            oldest_key = self.cache_order.pop(0)
            del self.cache[oldest_key]

        self.cache[cache_key] = result
        self.cache_order.append(cache_key)

        return result

    def create_cache_key(self, state, tasks):
        """
        Create cache key from state and tasks
        """
        # Discretize state for cache key
        state_key = tuple(np.round(state, decimals=2))
        task_key = tuple([task['type'] for task in tasks])
        return (state_key, task_key)
```

## 6. Integration with Control Systems

### Planning-Control Interface

```python
import actionlib
from control_msgs.msg import FollowJointTrajectoryAction, FollowJointTrajectoryGoal
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint

class WholeBodyControlInterface:
    def __init__(self):
        # Action clients for different control modes
        self.joint_trajectory_client = actionlib.SimpleActionClient(
            '/joint_trajectory_controller/follow_joint_trajectory',
            FollowJointTrajectoryAction
        )
        self.impedance_client = actionlib.SimpleActionClient(
            '/impedance_controller/follow_cartesian_trajectory',
            FollowJointTrajectoryAction  # Simplified for example
        )

        # Wait for servers
        self.joint_trajectory_client.wait_for_server()
        self.impedance_client.wait_for_server()

    def execute_wholebody_trajectory(self, trajectory, control_mode='position'):
        """
        Execute whole-body trajectory with appropriate control mode
        """
        if control_mode == 'position':
            return self.execute_position_trajectory(trajectory)
        elif control_mode == 'impedance':
            return self.execute_impedance_trajectory(trajectory)
        else:
            raise ValueError(f"Unknown control mode: {control_mode}")

    def execute_position_trajectory(self, trajectory):
        """
        Execute trajectory using position control
        """
        joint_trajectory = JointTrajectory()
        joint_trajectory.joint_names = [f'joint_{i}' for i in range(len(trajectory[0]['positions']))]

        for point_data in trajectory:
            point = JointTrajectoryPoint()
            point.positions = point_data['positions']
            point.velocities = point_data.get('velocities', [0.0] * len(point_data['positions']))
            point.accelerations = point_data.get('accelerations', [0.0] * len(point_data['positions']))
            point.time_from_start = rospy.Duration(point_data['time'])

            joint_trajectory.points.append(point)

        goal = FollowJointTrajectoryGoal()
        goal.trajectory = joint_trajectory

        self.joint_trajectory_client.send_goal(goal)
        return self.joint_trajectory_client.wait_for_result()

    def execute_impedance_trajectory(self, trajectory):
        """
        Execute trajectory using impedance control for compliant behavior
        """
        # Implementation for impedance control
        # This would send Cartesian space commands with impedance parameters
        pass
```

## Conclusion

Implementing whole-body motion planning for humanoid robots requires sophisticated integration of multiple control and optimization techniques. The examples provided demonstrate practical approaches to building robust whole-body planning systems that can handle the challenges of coordinating multiple limbs while maintaining balance and achieving complex tasks.

Success depends on balancing computational efficiency with solution quality, managing high-dimensional optimization problems, and ensuring safe operation in dynamic environments. Modern tools like ROS, CVXPY, and specialized whole-body control frameworks provide the foundation for building sophisticated planning systems, while careful system design ensures they operate reliably on physical robots.

The field continues to evolve with advances in optimization methods, machine learning, and real-time computing, enabling increasingly capable whole-body motion planning systems for humanoid robots.