---
title: 1.2 Motion Planning Implementation and Practical Applications
sidebar_position: 2
---

# 1.2 Motion Planning Implementation and Practical Applications

## Learning Objectives
- Implement motion planning algorithms for real humanoid robots
- Understand collision detection and configuration space representation
- Apply sampling-based and optimization-based planning methods
- Develop practical implementations using ROS and Python
- Integrate planning with control and perception systems

## Introduction

Implementing motion planning for humanoid robots requires careful consideration of computational constraints, real-time performance requirements, and system integration. Unlike theoretical planning algorithms, practical implementation must handle high-dimensional configuration spaces efficiently while providing collision-free trajectories in dynamic environments. This section provides practical guidance on implementing motion planning systems for humanoid robots, with specific focus on software frameworks, collision detection, and real-world deployment considerations.

The implementation of motion planning for humanoid robots involves several key components: collision detection systems, sampling algorithms, optimization routines, and integration with robot control and perception systems. Modern humanoid robots like Atlas, HRP-4, and NAO demonstrate successful implementation of complex planning algorithms for tasks ranging from navigation to manipulation.

## 1. Collision Detection and Environment Representation

### Collision Detection Implementation

```python
import numpy as np
import fcl  # Flexible Collision Library
from geometry_msgs.msg import Point, Pose
from visualization_msgs.msg import Marker

class CollisionDetector:
    def __init__(self):
        # Initialize FCL collision manager
        self.collision_manager = fcl.DynamicAABBTreeCollisionManager()
        self.objects = {}  # Dictionary to store collision objects
        self.robot_model = None  # Robot URDF model

    def add_robot_collision_mesh(self, joint_angles):
        """
        Add robot collision geometry based on current joint configuration
        """
        # Forward kinematics to get link positions
        link_poses = self.compute_link_poses(joint_angles)

        # Clear existing robot objects
        for obj_name in [name for name in self.objects.keys() if name.startswith('robot_')]:
            del self.objects[obj_name]

        # Add each link as collision object
        for link_name, pose in link_poses.items():
            if self.has_collision_geometry(link_name):
                collision_obj = self.create_collision_object(link_name, pose)
                self.objects[f'robot_{link_name}'] = collision_obj
                self.collision_manager.registerObject(collision_obj)

    def add_environment_object(self, obj_name, geometry_type, dimensions, pose):
        """
        Add environment object to collision detection
        """
        if geometry_type == 'box':
            shape = fcl.Box(dimensions[0], dimensions[1], dimensions[2])
        elif geometry_type == 'sphere':
            shape = fcl.Sphere(dimensions[0])
        elif geometry_type == 'cylinder':
            shape = fcl.Cylinder(dimensions[0], dimensions[1])  # radius, height
        else:
            raise ValueError(f"Unsupported geometry type: {geometry_type}")

        # Create collision object
        collision_obj = fcl.CollisionObject(shape)
        collision_obj.setTransform(self.pose_to_transform(pose))

        # Store and register
        self.objects[obj_name] = collision_obj
        self.collision_manager.registerObject(collision_obj)

        # Update collision manager
        self.collision_manager.update()

    def check_collision(self, joint_angles):
        """
        Check if current robot configuration is in collision
        """
        # Update robot collision geometry
        self.add_robot_collision_mesh(joint_angles)

        # Perform collision check
        request = fcl.CollisionRequest()
        result = fcl.CollisionResult()

        # Check robot vs environment
        for obj_name, obj in self.objects.items():
            if obj_name.startswith('robot_'):
                continue

            fcl.collide(self.objects[obj_name], obj, request, result)
            if result.is_collision:
                return True, obj_name

        return False, None

    def compute_link_poses(self, joint_angles):
        """
        Compute forward kinematics to get link poses
        """
        # This would typically use a kinematics library like KDL or PyKDL
        # For simplicity, returning mock data
        link_poses = {}
        for i, joint_name in enumerate(self.joint_names):
            # Compute transformation based on joint angles
            # This is a simplified example
            link_poses[f'link_{i}'] = Pose()

        return link_poses

    def has_collision_geometry(self, link_name):
        """
        Check if link has collision geometry defined
        """
        # Check URDF for collision geometry
        return True  # Simplified implementation

# Alternative collision detection using Open3D for point cloud collision
class PointCloudCollisionDetector:
    def __init__(self):
        self.robot_pcd = None
        self.env_pcd = None
        self.collision_threshold = 0.02  # 2cm threshold

    def check_collision_pointcloud(self, robot_points, env_points):
        """
        Check collision using point cloud distance
        """
        # Convert to Open3D point clouds
        robot_pcd = o3d.geometry.PointCloud()
        robot_pcd.points = o3d.utility.Vector3dVector(robot_points)

        env_pcd = o3d.geometry.PointCloud()
        env_pcd.points = o3d.utility.Vector3dVector(env_points)

        # Compute minimum distance
        distances = env_pcd.compute_point_cloud_distance(robot_pcd)
        min_distance = min(distances)

        return min_distance < self.collision_threshold
```

### Environment Representation

```python
import numpy as np
from scipy.spatial import cKDTree
import rospy

class EnvironmentRepresentation:
    def __init__(self):
        self.occupancy_grid = None
        self.point_cloud = None
        self.obstacles = []
        self.resolution = 0.05  # 5cm resolution

    def build_occupancy_grid(self, point_cloud_data, grid_size=(10, 10, 2)):
        """
        Build 3D occupancy grid from point cloud data
        """
        # Determine grid dimensions
        grid_shape = (
            int(grid_size[0] / self.resolution),
            int(grid_size[1] / self.resolution),
            int(grid_size[2] / self.resolution)
        )

        self.occupancy_grid = np.zeros(grid_shape, dtype=bool)

        # Convert point cloud to grid coordinates
        for point in point_cloud_data:
            grid_x = int((point[0] + grid_size[0]/2) / self.resolution)
            grid_y = int((point[1] + grid_size[1]/2) / self.resolution)
            grid_z = int((point[2]) / self.resolution)

            # Check bounds
            if (0 <= grid_x < grid_shape[0] and
                0 <= grid_y < grid_shape[1] and
                0 <= grid_z < grid_shape[2]):
                self.occupancy_grid[grid_x, grid_y, grid_z] = True

    def is_occupied(self, position):
        """
        Check if a position is occupied in the grid
        """
        x, y, z = position
        grid_x = int((x + self.grid_size[0]/2) / self.resolution)
        grid_y = int((y + self.grid_size[1]/2) / self.resolution)
        grid_z = int(z / self.resolution)

        if (0 <= grid_x < self.occupancy_grid.shape[0] and
            0 <= grid_y < self.occupancy_grid.shape[1] and
            0 <= grid_z < self.occupancy_grid.shape[2]):
            return self.occupancy_grid[grid_x, grid_y, grid_z]
        else:
            # Outside grid is considered occupied
            return True
```

## 2. Sampling-Based Planning Implementation

### RRT Implementation

```python
import numpy as np
import random
from scipy.spatial.distance import euclidean
from sklearn.neighbors import NearestNeighbors

class RRTPlanner:
    def __init__(self, start_config, goal_config, joint_limits, step_size=0.1):
        self.start_config = np.array(start_config)
        self.goal_config = np.array(goal_config)
        self.joint_limits = joint_limits  # [(min1, max1), (min2, max2), ...]
        self.step_size = step_size
        self.nodes = [self.start_config]
        self.parent_indices = [-1]  # Root has no parent
        self.goal_bias = 0.1  # 10% chance to sample goal

    def sample_free_space(self):
        """
        Sample a random configuration in joint limits
        """
        if random.random() < self.goal_bias:
            # Bias toward goal
            return self.goal_config

        config = []
        for min_val, max_val in self.joint_limits:
            config.append(random.uniform(min_val, max_val))

        return np.array(config)

    def nearest_node(self, config):
        """
        Find the nearest node in the tree to the given configuration
        """
        distances = [euclidean(config, node) for node in self.nodes]
        nearest_idx = np.argmin(distances)
        return nearest_idx

    def extend_toward(self, from_config, to_config):
        """
        Extend from from_config toward to_config by step_size
        """
        direction = to_config - from_config
        distance = np.linalg.norm(direction)

        if distance <= self.step_size:
            return to_config

        # Normalize direction and scale by step size
        normalized_direction = direction / distance
        new_config = from_config + normalized_direction * self.step_size

        return new_config

    def is_collision_free(self, config1, config2, collision_checker):
        """
        Check if path between two configurations is collision-free
        """
        # Sample intermediate points along the path
        steps = int(np.linalg.norm(config2 - config1) / (self.step_size / 2))
        for i in range(steps + 1):
            alpha = i / steps
            intermediate_config = (1 - alpha) * config1 + alpha * config2

            # Check collision for intermediate configuration
            in_collision, _ = collision_checker.check_collision(intermediate_config)
            if in_collision:
                return False

        return True

    def plan(self, collision_checker, max_iterations=10000):
        """
        Plan path using RRT algorithm
        """
        for iteration in range(max_iterations):
            # Sample random configuration
            random_config = self.sample_free_space()

            # Find nearest node in tree
            nearest_idx = self.nearest_node(random_config)
            nearest_config = self.nodes[nearest_idx]

            # Extend toward random configuration
            new_config = self.extend_toward(nearest_config, random_config)

            # Check collision
            if self.is_collision_free(nearest_config, new_config, collision_checker):
                # Add new node to tree
                self.nodes.append(new_config)
                self.parent_indices.append(nearest_idx)

                # Check if goal is reached
                if np.linalg.norm(new_config - self.goal_config) < self.step_size:
                    # Extract path
                    path = self.extract_path(len(self.nodes) - 1)
                    return path

        # No path found
        return None

    def extract_path(self, goal_node_idx):
        """
        Extract path from start to goal node
        """
        path = []
        current_idx = goal_node_idx

        while current_idx != -1:
            path.append(self.nodes[current_idx])
            current_idx = self.parent_indices[current_idx]

        # Reverse to get path from start to goal
        path.reverse()
        return path

# RRT* Implementation for optimal paths
class RRTStarPlanner(RRTPlanner):
    def __init__(self, start_config, goal_config, joint_limits, step_size=0.1,
                 rewire_radius=1.0):
        super().__init__(start_config, goal_config, joint_limits, step_size)
        self.rewire_radius = rewire_radius

    def find_nearby_nodes(self, config, radius):
        """
        Find all nodes within radius of config
        """
        nearby_indices = []
        for i, node in enumerate(self.nodes):
            if euclidean(config, node) <= radius:
                nearby_indices.append(i)
        return nearby_indices

    def choose_parent(self, nearby_indices, new_config, collision_checker):
        """
        Choose parent for new configuration that minimizes path cost
        """
        min_cost = float('inf')
        best_parent_idx = -1

        for idx in nearby_indices:
            parent_config = self.nodes[idx]
            if self.is_collision_free(parent_config, new_config, collision_checker):
                cost = self.calculate_cost(idx) + euclidean(parent_config, new_config)
                if cost < min_cost:
                    min_cost = cost
                    best_parent_idx = idx

        return best_parent_idx, min_cost

    def rewire(self, new_node_idx, nearby_indices, collision_checker):
        """
        Rewire nearby nodes if going through new node is better
        """
        new_config = self.nodes[new_node_idx]

        for idx in nearby_indices:
            if idx == new_node_idx:
                continue

            current_parent_idx = self.parent_indices[idx]
            if current_parent_idx == new_node_idx:
                continue  # Already connected

            current_config = self.nodes[idx]
            current_cost = self.calculate_cost(idx)
            new_cost = self.calculate_cost(new_node_idx) + euclidean(new_config, current_config)

            if (new_cost < current_cost and
                self.is_collision_free(new_config, current_config, collision_checker)):
                # Rewire
                self.parent_indices[idx] = new_node_idx

    def calculate_cost(self, node_idx):
        """
        Calculate path cost from start to given node
        """
        if node_idx == 0:
            return 0.0

        cost = 0.0
        current_idx = node_idx
        parent_idx = self.parent_indices[current_idx]

        while parent_idx != -1:
            cost += euclidean(self.nodes[current_idx], self.nodes[parent_idx])
            current_idx = parent_idx
            parent_idx = self.parent_indices[current_idx]

        return cost
```

## 3. Optimization-Based Planning Implementation

### Trajectory Optimization

```python
import numpy as np
from scipy.optimize import minimize
import cvxpy as cp

class TrajectoryOptimizer:
    def __init__(self, robot_model, start_config, goal_config, num_waypoints=20):
        self.robot_model = robot_model
        self.start_config = np.array(start_config)
        self.goal_config = np.array(goal_config)
        self.num_waypoints = num_waypoints
        self.n_joints = len(start_config)

    def optimize_trajectory(self, collision_checker, initial_guess=None):
        """
        Optimize trajectory using constrained optimization
        """
        if initial_guess is None:
            # Create straight-line initial guess
            initial_guess = np.zeros((self.num_waypoints, self.n_joints))
            for i in range(self.num_waypoints):
                alpha = i / (self.num_waypoints - 1)
                initial_guess[i] = (1 - alpha) * self.start_config + alpha * self.goal_config

        # Reshape for optimization
        initial_flat = initial_guess.flatten()

        # Define optimization problem
        def objective_function(flat_trajectory):
            """
            Minimize trajectory length and smoothness
            """
            trajectory = flat_trajectory.reshape((self.num_waypoints, self.n_joints))

            # Length cost
            length_cost = 0
            for i in range(1, self.num_waypoints):
                length_cost += np.sum((trajectory[i] - trajectory[i-1])**2)

            # Smoothness cost (acceleration)
            smoothness_cost = 0
            for i in range(1, self.num_waypoints - 1):
                velocity_diff = (trajectory[i+1] - trajectory[i]) - (trajectory[i] - trajectory[i-1])
                smoothness_cost += np.sum(velocity_diff**2)

            return length_cost + 0.1 * smoothness_cost

        def collision_constraint(flat_trajectory):
            """
            Constraint function for collision avoidance
            """
            trajectory = flat_trajectory.reshape((self.num_waypoints, self.n_joints))

            # Check collision for each waypoint
            for config in trajectory:
                in_collision, _ = collision_checker.check_collision(config)
                if in_collision:
                    return -1  # Violation (negative value)

            return 1  # Satisfied (positive value)

        # Define bounds (joint limits)
        bounds = []
        for i in range(self.n_joints):
            for j in range(self.num_waypoints):
                bounds.append(self.robot_model.joint_limits[i])

        # Define constraints
        constraints = [
            {'type': 'eq', 'fun': lambda x: x[:self.n_joints] - self.start_config},  # Start constraint
            {'type': 'eq', 'fun': lambda x: x[-self.n_joints:] - self.goal_config},  # Goal constraint
            {'type': 'ineq', 'fun': collision_constraint}  # Collision constraint
        ]

        # Optimize
        result = minimize(
            objective_function,
            initial_flat,
            method='SLSQP',
            bounds=bounds,
            constraints=constraints,
            options={'maxiter': 1000, 'disp': True}
        )

        if result.success:
            optimized_trajectory = result.x.reshape((self.num_waypoints, self.n_joints))
            return optimized_trajectory
        else:
            return None

# CHOMP (Covariant Hamiltonian Optimization for Motion Planning)
class CHOMPPlanner:
    def __init__(self, start_config, goal_config, collision_checker,
                 num_waypoints=20, learning_rate=0.01):
        self.start_config = np.array(start_config)
        self.goal_config = np.array(goal_config)
        self.collision_checker = collision_checker
        self.num_waypoints = num_waypoints
        self.learning_rate = learning_rate
        self.n_joints = len(start_config)

    def plan(self, initial_trajectory=None, max_iterations=1000):
        """
        Plan trajectory using CHOMP optimization
        """
        if initial_trajectory is None:
            # Create straight-line initial trajectory
            initial_trajectory = np.zeros((self.num_waypoints, self.n_joints))
            for i in range(self.num_waypoints):
                alpha = i / (self.num_waypoints - 1)
                initial_trajectory[i] = (1 - alpha) * self.start_config + alpha * self.goal_config

        trajectory = initial_trajectory.copy()

        for iteration in range(max_iterations):
            # Compute gradient of cost function
            grad = self.compute_gradient(trajectory)

            # Update trajectory
            trajectory = trajectory - self.learning_rate * grad

            # Enforce boundary conditions
            trajectory[0] = self.start_config
            trajectory[-1] = self.goal_config

            # Check for convergence
            if np.linalg.norm(grad) < 1e-6:
                break

        return trajectory

    def compute_gradient(self, trajectory):
        """
        Compute gradient of cost function with respect to trajectory
        """
        grad = np.zeros_like(trajectory)

        # Smoothness gradient (minimize velocity and acceleration)
        for i in range(1, self.num_waypoints - 1):
            # Acceleration term
            acc = trajectory[i-1] - 2*trajectory[i] + trajectory[i+1]
            grad[i] += 2 * acc

            # Velocity term
            vel_backward = trajectory[i] - trajectory[i-1]
            vel_forward = trajectory[i+1] - trajectory[i]
            grad[i] += 0.1 * (vel_backward - vel_forward)

        # Collision avoidance gradient
        for i in range(self.num_waypoints):
            in_collision, _ = self.collision_checker.check_collision(trajectory[i])
            if in_collision:
                # Compute gradient to move away from collision
                collision_grad = self.compute_collision_gradient(trajectory[i])
                grad[i] += 10.0 * collision_grad  # Strong penalty for collisions

        return grad

    def compute_collision_gradient(self, config):
        """
        Compute gradient to move away from collision
        """
        # Simple implementation: move away from obstacles
        # In practice, this would use distance fields or other methods
        grad = np.zeros(len(config))

        # For now, return a small random gradient to escape collision
        for i in range(len(config)):
            grad[i] = np.random.uniform(-0.1, 0.1)

        return grad
```

## 4. ROS Implementation for Motion Planning

### Motion Planning Node

```python
#!/usr/bin/env python3

import rospy
import numpy as np
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Pose, Point
from moveit_msgs.msg import MotionPlanRequest, MotionPlanResponse
from humanoid_motion_planning.msg import MotionPlan, MotionTrajectory
from visualization_msgs.msg import Marker, MarkerArray

class MotionPlanningNode:
    def __init__(self):
        rospy.init_node('motion_planning_node')

        # Initialize planning components
        self.collision_detector = CollisionDetector()
        self.environment = EnvironmentRepresentation()

        # Publishers
        self.plan_pub = rospy.Publisher('/motion_planning/plan', MotionPlan, queue_size=10)
        self.trajectory_pub = rospy.Publisher('/motion_planning/trajectory', MotionTrajectory, queue_size=10)
        self.visualization_pub = rospy.Publisher('/motion_planning/visualization', MarkerArray, queue_size=10)

        # Subscribers
        self.joint_state_sub = rospy.Subscriber('/joint_states', JointState, self.joint_state_callback)
        self.goal_sub = rospy.Subscriber('/motion_planning/goal', Pose, self.goal_callback)
        self.obstacle_sub = rospy.Subscriber('/obstacles', MarkerArray, self.obstacle_callback)

        # Current robot state
        self.current_joint_angles = None
        self.current_goal = None

        # Planning parameters
        self.planning_rate = rospy.Rate(1)  # 1 Hz planning
        self.planner_type = 'rrt'  # Default planner

    def joint_state_callback(self, msg):
        """
        Update current joint state
        """
        self.current_joint_angles = np.array(msg.position)

    def goal_callback(self, goal_pose):
        """
        Receive new goal pose and initiate planning
        """
        self.current_goal = goal_pose
        rospy.loginfo("Received new goal, initiating planning...")

        # Plan motion
        trajectory = self.plan_motion()

        if trajectory is not None:
            # Publish trajectory
            self.publish_trajectory(trajectory)

            # Visualize path
            self.visualize_path(trajectory)
        else:
            rospy.logwarn("Motion planning failed to find a path")

    def obstacle_callback(self, obstacles):
        """
        Update environment with new obstacles
        """
        for obstacle in obstacles.markers:
            if obstacle.type == Marker.CUBE:
                self.collision_detector.add_environment_object(
                    obstacle.ns + str(obstacle.id),
                    'box',
                    [obstacle.scale.x, obstacle.scale.y, obstacle.scale.z],
                    obstacle.pose
                )

    def plan_motion(self):
        """
        Plan motion from current configuration to goal
        """
        if self.current_joint_angles is None or self.current_goal is None:
            return None

        # Convert goal pose to joint configuration (inverse kinematics)
        goal_config = self.inverse_kinematics(self.current_goal)
        if goal_config is None:
            rospy.logwarn("Inverse kinematics failed for goal pose")
            return None

        # Choose planner based on requirements
        if self.planner_type == 'rrt':
            planner = RRTPlanner(
                self.current_joint_angles,
                goal_config,
                self.get_joint_limits()
            )
        elif self.planner_type == 'rrt*':
            planner = RRTStarPlanner(
                self.current_joint_angles,
                goal_config,
                self.get_joint_limits()
            )
        else:
            planner = RRTPlanner(
                self.current_joint_angles,
                goal_config,
                self.get_joint_limits()
            )

        # Plan path
        path = planner.plan(self.collision_detector)

        if path is not None:
            rospy.loginfo(f"Found path with {len(path)} waypoints")
            return path
        else:
            rospy.logwarn("Failed to find path")
            return None

    def inverse_kinematics(self, goal_pose):
        """
        Solve inverse kinematics for desired end-effector pose
        """
        # This would typically use a kinematics solver like KDL or PyKDL
        # For simplicity, returning a mock solution
        return np.random.uniform(-1.0, 1.0, size=len(self.current_joint_angles))

    def get_joint_limits(self):
        """
        Get joint limits for the robot
        """
        # In practice, these would come from URDF or robot description
        return [(-3.14, 3.14)] * len(self.current_joint_angles)  # Example limits

    def publish_trajectory(self, trajectory):
        """
        Publish planned trajectory
        """
        traj_msg = MotionTrajectory()
        traj_msg.header.stamp = rospy.Time.now()

        for waypoint in trajectory:
            joint_state = JointState()
            joint_state.position = waypoint.tolist()
            traj_msg.waypoints.append(joint_state)

        self.trajectory_pub.publish(traj_msg)

    def visualize_path(self, trajectory):
        """
        Visualize planned path in RViz
        """
        marker_array = MarkerArray()

        # Create markers for path visualization
        for i, waypoint in enumerate(trajectory):
            marker = Marker()
            marker.header.frame_id = "base_link"
            marker.header.stamp = rospy.Time.now()
            marker.ns = "planned_path"
            marker.id = i
            marker.type = Marker.SPHERE
            marker.action = Marker.ADD
            marker.pose.position.x = waypoint[0]  # Simplified - only first joint
            marker.pose.position.y = waypoint[1]  # Simplified - only second joint
            marker.pose.position.z = 0.8  # Robot height
            marker.pose.orientation.w = 1.0
            marker.scale.x = 0.05
            marker.scale.y = 0.05
            marker.scale.z = 0.05
            marker.color.r = 1.0
            marker.color.g = 0.0
            marker.color.b = 0.0
            marker.color.a = 0.8

            marker_array.markers.append(marker)

        self.visualization_pub.publish(marker_array)

    def run(self):
        """
        Main planning loop
        """
        rospy.loginfo("Motion planning node started")
        rospy.spin()

if __name__ == '__main__':
    try:
        motion_planner = MotionPlanningNode()
        motion_planner.run()
    except rospy.ROSInterruptException:
        pass
```

## 5. Performance Optimization

### Efficient Collision Checking

```python
import multiprocessing as mp
from concurrent.futures import ThreadPoolExecutor
import time

class OptimizedMotionPlanner:
    def __init__(self, num_processes=4):
        self.num_processes = num_processes
        self.executor = ThreadPoolExecutor(max_workers=num_processes)

    def parallel_collision_check(self, configurations, collision_checker):
        """
        Perform collision checking in parallel
        """
        # Submit collision checks to thread pool
        futures = []
        for config in configurations:
            future = self.executor.submit(collision_checker.check_collision, config)
            futures.append(future)

        # Collect results
        results = []
        for future in futures:
            results.append(future.result())

        return results

    def batch_collision_check(self, trajectory_batch, collision_checker):
        """
        Check collisions for multiple trajectory points simultaneously
        """
        # Vectorized collision checking where possible
        collision_results = []

        for config in trajectory_batch:
            in_collision, obj_name = collision_checker.check_collision(config)
            collision_results.append((in_collision, obj_name))

        return collision_results

# Cache-based planning for repeated queries
class CachedMotionPlanner:
    def __init__(self, cache_size=100):
        self.cache = {}
        self.cache_order = []  # Track order for LRU
        self.cache_size = cache_size

    def plan_with_cache(self, start_config, goal_config, planner_func):
        """
        Plan motion with caching of previous results
        """
        # Create cache key (discretized configurations)
        cache_key = self.create_cache_key(start_config, goal_config)

        if cache_key in self.cache:
            # Return cached result
            rospy.loginfo("Using cached motion plan")
            return self.cache[cache_key]

        # Plan new trajectory
        trajectory = planner_func(start_config, goal_config)

        # Store in cache
        if len(self.cache) >= self.cache_size:
            # Remove oldest entry (LRU)
            oldest_key = self.cache_order.pop(0)
            del self.cache[oldest_key]

        self.cache[cache_key] = trajectory
        self.cache_order.append(cache_key)

        return trajectory

    def create_cache_key(self, start_config, goal_config):
        """
        Create discretized cache key from configurations
        """
        # Discretize configurations to reduce cache size
        start_disc = tuple(np.round(start_config, decimals=1))
        goal_disc = tuple(np.round(goal_config, decimals=1))
        return (start_disc, goal_disc)
```

## 6. Integration with Control Systems

### Planning-Control Interface

```python
import actionlib
from control_msgs.msg import FollowJointTrajectoryAction, FollowJointTrajectoryGoal
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint

class PlanningControlInterface:
    def __init__(self):
        # Initialize action client for trajectory execution
        self.trajectory_client = actionlib.SimpleActionClient(
            '/joint_trajectory_controller/follow_joint_trajectory',
            FollowJointTrajectoryAction
        )
        self.trajectory_client.wait_for_server()

    def execute_trajectory(self, trajectory, joint_names):
        """
        Execute planned trajectory on robot
        """
        # Convert numpy trajectory to ROS JointTrajectory message
        joint_trajectory = JointTrajectory()
        joint_trajectory.joint_names = joint_names

        # Convert each waypoint to JointTrajectoryPoint
        for i, waypoint in enumerate(trajectory):
            point = JointTrajectoryPoint()
            point.positions = waypoint.tolist()

            # Calculate time from start (assuming constant velocity)
            time_from_start = rospy.Duration(i * 0.1)  # 100ms per point
            point.time_from_start = time_from_start

            # Add velocities and accelerations if available
            if i > 0 and i < len(trajectory) - 1:
                velocity = (trajectory[i+1] - trajectory[i-1]) / 0.2
                point.velocities = velocity.tolist()

            joint_trajectory.points.append(point)

        # Create and send goal
        goal = FollowJointTrajectoryGoal()
        goal.trajectory = joint_trajectory

        # Send goal to controller
        self.trajectory_client.send_goal(goal)

        # Wait for result
        finished_within_time = self.trajectory_client.wait_for_result(rospy.Duration(30.0))

        if finished_within_time:
            state = self.trajectory_client.get_state()
            return state == actionlib.GoalStatus.SUCCEEDED
        else:
            self.trajectory_client.cancel_goal()
            return False
```

## Conclusion

Implementing motion planning for humanoid robots requires careful integration of collision detection, sampling algorithms, optimization methods, and control systems. The examples provided demonstrate practical approaches to building robust planning systems that can handle the challenges of real-world deployment.

Success depends on balancing solution quality with computational efficiency, managing high-dimensional configuration spaces, and ensuring safe operation in dynamic environments. Modern tools like MoveIt, OMPL, and ROS provide the foundation for building sophisticated planning systems, while careful system design ensures they operate reliably on physical robots.

The field continues to evolve with advances in sampling techniques, optimization methods, and learning-based approaches, enabling increasingly capable motion planning systems for humanoid robots.