---
title: 7.2 Forward and Inverse Kinematics Implementation
sidebar_position: 29
---

# 7.2 Forward and Inverse Kinematics Implementation

## Introduction

This section provides practical implementation examples of forward and inverse kinematics for humanoid robots. We'll cover implementation of the mathematical concepts discussed in the concepts section, focusing on efficient algorithms for real-time humanoid control.

## 1. Mathematical Libraries and Dependencies

For implementing kinematics algorithms, we'll use the following Python libraries:

```python
import numpy as np
import math
from scipy.spatial.transform import Rotation as R
import roboticstoolbox as rtb
from spatialmath import SE3
```

## 2. Homogeneous Transformation Implementation

Let's implement the basic transformation matrix operations:

```python
class Transform3D:
    """3D transformation operations for kinematics"""

    @staticmethod
    def rotation_x(angle):
        """Rotation matrix around X-axis"""
        c, s = math.cos(angle), math.sin(angle)
        return np.array([
            [1,  0,  0],
            [0,  c, -s],
            [0,  s,  c]
        ])

    @staticmethod
    def rotation_y(angle):
        """Rotation matrix around Y-axis"""
        c, s = math.cos(angle), math.sin(angle)
        return np.array([
            [c,  0,  s],
            [0,  1,  0],
            [-s, 0,  c]
        ])

    @staticmethod
    def rotation_z(angle):
        """Rotation matrix around Z-axis"""
        c, s = math.cos(angle), math.sin(angle)
        return np.array([
            [c, -s,  0],
            [s,  c,  0],
            [0,  0,  1]
        ])

    @staticmethod
    def homogeneous_transform(rotation, translation):
        """Create 4x4 homogeneous transformation matrix"""
        T = np.eye(4)
        T[:3, :3] = rotation
        T[:3, 3] = translation
        return T

    @staticmethod
    def dh_transform(a, alpha, d, theta):
        """Denavit-Hartenberg transformation matrix"""
        c_theta, s_theta = math.cos(theta), math.sin(theta)
        c_alpha, s_alpha = math.cos(alpha), math.sin(alpha)

        return np.array([
            [c_theta, -s_theta * c_alpha,  s_theta * s_alpha, a * c_theta],
            [s_theta,  c_theta * c_alpha, -c_theta * s_alpha, a * s_theta],
            [0,        s_alpha,            c_alpha,          d],
            [0,        0,                  0,                1]
        ])
```

## 3. Forward Kinematics Implementation

Let's implement forward kinematics for a humanoid arm:

```python
class HumanoidArmFK:
    """Forward kinematics for a 7-DOF humanoid arm"""

    def __init__(self, link_lengths=None):
        """
        Initialize with link lengths [upper_arm, forearm, hand]
        Default values based on typical humanoid proportions
        """
        if link_lengths is None:
            self.link_lengths = [0.3, 0.25, 0.1]  # [upper_arm, forearm, hand]
        else:
            self.link_lengths = link_lengths

    def compute_fk(self, joint_angles):
        """
        Compute forward kinematics for 7-DOF arm
        joint_angles: [shoulder_yaw, shoulder_pitch, shoulder_roll,
                      elbow_pitch, elbow_yaw, wrist_pitch, wrist_yaw]
        """
        # Extract joint angles
        q1, q2, q3, q4, q5, q6, q7 = joint_angles

        # Define DH parameters for 7-DOF arm
        # [a, alpha, d, theta_offset]
        dh_params = [
            [0, -np.pi/2, 0, q1],      # Shoulder yaw
            [0, np.pi/2,  0, q2],      # Shoulder pitch
            [0, -np.pi/2, 0, q3],      # Shoulder roll
            [self.link_lengths[0], 0, 0, q4],  # Elbow pitch
            [0, np.pi/2, self.link_lengths[1], q5],  # Elbow yaw
            [0, -np.pi/2, 0, q6],      # Wrist pitch
            [0, 0, self.link_lengths[2], q7]    # Wrist yaw
        ]

        # Initialize base transformation
        T_total = np.eye(4)

        # Multiply all transformations
        for a, alpha, d, theta in dh_params:
            T_link = self._dh_transform(a, alpha, d, theta)
            T_total = T_total @ T_link

        return T_total

    def _dh_transform(self, a, alpha, d, theta):
        """DH transformation for a single joint"""
        c_theta, s_theta = math.cos(theta), math.sin(theta)
        c_alpha, s_alpha = math.cos(alpha), math.sin(alpha)

        return np.array([
            [c_theta, -s_theta * c_alpha,  s_theta * s_alpha, a * c_theta],
            [s_theta,  c_theta * c_alpha, -c_theta * s_alpha, a * s_theta],
            [0,        s_alpha,            c_alpha,          d],
            [0,        0,                  0,                1]
        ])

    def get_end_effector_pose(self, joint_angles):
        """Get position and orientation of end effector"""
        T = self.compute_fk(joint_angles)

        # Extract position
        position = T[:3, 3]

        # Extract rotation matrix
        rotation_matrix = T[:3, :3]

        # Convert to Euler angles (ZYX convention)
        euler_angles = self._rotation_matrix_to_euler(rotation_matrix)

        return position, euler_angles

    def _rotation_matrix_to_euler(self, R):
        """Convert rotation matrix to Euler angles (ZYX)"""
        sy = math.sqrt(R[0,0] * R[0,0] + R[1,0] * R[1,0])

        singular = sy < 1e-6

        if not singular:
            x = math.atan2(R[2,1], R[2,2])
            y = math.atan2(-R[2,0], sy)
            z = math.atan2(R[1,0], R[0,0])
        else:
            x = math.atan2(-R[1,2], R[1,1])
            y = math.atan2(-R[2,0], sy)
            z = 0

        return np.array([x, y, z])
```

## 4. Jacobian Implementation

Let's implement the geometric Jacobian computation:

```python
class JacobianCalculator:
    """Calculate Jacobian matrices for robotic arms"""

    def __init__(self, robot_model):
        self.robot_model = robot_model

    def geometric_jacobian(self, joint_angles, end_effector_frame='end_effector'):
        """
        Calculate geometric Jacobian using the geometric method
        Returns 6xN matrix where N is number of joints
        """
        n = len(joint_angles)
        J = np.zeros((6, n))

        # Get current end-effector pose
        T_end = self.robot_model.compute_fk(joint_angles)
        end_pos = T_end[:3, 3]

        # Calculate transformation matrices for each joint
        T_intermediate = np.eye(4)

        for i in range(n):
            # Get transformation from base to joint i
            # For this example, we'll compute partial transforms
            # In practice, you'd have a method to get each joint's pose

            # For a revolute joint, the Jacobian column is:
            # [z_i-1 x (p_end - p_i-1)]
            # [z_i-1]

            # Simplified calculation - in practice you'd have the exact joint positions
            # This is a placeholder implementation
            joint_pos = self._get_joint_position(joint_angles, i)
            joint_axis = self._get_joint_axis(joint_angles, i)

            # Linear velocity component: z Ã— (end_pos - joint_pos)
            linear_vel = np.cross(joint_axis, end_pos - joint_pos)

            # Angular velocity component: z (joint axis)
            angular_vel = joint_axis

            # Fill Jacobian column
            J[:3, i] = linear_vel  # Linear velocity part
            J[3:, i] = angular_vel  # Angular velocity part

        return J

    def _get_joint_position(self, joint_angles, joint_idx):
        """Get position of joint at given index"""
        # This would compute the transformation up to joint_idx
        # For simplicity, using a placeholder
        return np.zeros(3)

    def _get_joint_axis(self, joint_angles, joint_idx):
        """Get rotation axis of joint at given index"""
        # This would compute the rotation axis based on joint configuration
        # For simplicity, using a placeholder (z-axis)
        return np.array([0, 0, 1])
```

## 5. Inverse Kinematics Implementation

Now let's implement several inverse kinematics methods:

### 5.1 Pseudoinverse Method

```python
class InverseKinematics:
    """Inverse kinematics solvers for humanoid robots"""

    def __init__(self, robot_model, max_iterations=100, tolerance=1e-4):
        self.robot_model = robot_model
        self.max_iterations = max_iterations
        self.tolerance = tolerance
        self.jacobian_calc = JacobianCalculator(robot_model)

    def solve_pseudoinverse(self, target_pose, initial_joints, weights=None):
        """
        Solve IK using pseudoinverse method
        """
        joints = np.array(initial_joints, dtype=float)

        if weights is None:
            weights = np.ones(len(joints))

        W = np.diag(weights)  # Weight matrix

        for iteration in range(self.max_iterations):
            # Compute current end-effector pose
            current_pose = self.robot_model.compute_fk(joints)

            # Calculate pose error
            error = self._pose_error(current_pose, target_pose)

            # Check convergence
            if np.linalg.norm(error) < self.tolerance:
                return joints, True, iteration

            # Compute Jacobian
            J = self.jacobian_calc.geometric_jacobian(joints)

            # Apply weighting (for joint limits, etc.)
            J_weighted = np.linalg.inv(W) @ J.T

            # Compute joint update using pseudoinverse
            delta_joints = J_weighted @ error

            # Update joint angles
            joints = joints + delta_joints * 0.1  # Step size

            # Apply joint limits
            joints = self._apply_joint_limits(joints)

        return joints, False, self.max_iterations

    def _pose_error(self, current_pose, target_pose):
        """Calculate pose error between current and target poses"""
        # Position error
        pos_error = target_pose[:3, 3] - current_pose[:3, 3]

        # Orientation error using rotation matrix difference
        R_current = current_pose[:3, :3]
        R_target = target_pose[:3, :3]

        # Convert to axis-angle representation for error
        R_error = R_target @ R_current.T
        angle_error = self._rotation_matrix_to_axis_angle(R_error)

        # Combine position and orientation errors
        error = np.concatenate([pos_error, angle_error])

        return error

    def _rotation_matrix_to_axis_angle(self, R):
        """Convert rotation matrix to axis-angle representation"""
        angle = math.acos(np.clip((np.trace(R) - 1) / 2, -1, 1))

        if angle < 1e-6:
            return np.zeros(3)

        axis = np.array([
            R[2,1] - R[1,2],
            R[0,2] - R[2,0],
            R[1,0] - R[0,1]
        ]) / (2 * math.sin(angle))

        return axis * angle

    def _apply_joint_limits(self, joints):
        """Apply joint limits to joint angles"""
        # Define typical humanoid joint limits (in radians)
        joint_limits = {
            'shoulder_pitch': (-2.0, 2.0),
            'shoulder_roll': (-1.5, 1.5),
            'elbow_pitch': (-0.1, 2.3),
            'wrist_pitch': (-1.0, 1.0),
            'wrist_yaw': (-1.0, 1.0)
        }

        # For simplicity, apply generic limits
        lower_limits = np.full(len(joints), -np.pi)
        upper_limits = np.full(len(joints), np.pi)

        # Specific limits for common joints
        if len(joints) >= 3:
            lower_limits[2] = -0.1  # Elbow limit
            upper_limits[2] = 2.3   # Elbow limit

        return np.clip(joints, lower_limits, upper_limits)
```

### 5.2 Damped Least Squares Method

```python
class DLSInverseKinematics(InverseKinematics):
    """Inverse kinematics using damped least squares method"""

    def __init__(self, robot_model, max_iterations=100, tolerance=1e-4, damping_factor=0.01):
        super().__init__(robot_model, max_iterations, tolerance)
        self.damping_factor = damping_factor

    def solve_dls(self, target_pose, initial_joints, damping_factor=None):
        """
        Solve IK using damped least squares method
        More stable near singularities than pseudoinverse
        """
        if damping_factor is None:
            damping_factor = self.damping_factor

        joints = np.array(initial_joints, dtype=float)

        for iteration in range(self.max_iterations):
            # Compute current pose
            current_pose = self.robot_model.compute_fk(joints)

            # Calculate error
            error = self._pose_error(current_pose, target_pose)

            # Check convergence
            if np.linalg.norm(error) < self.tolerance:
                return joints, True, iteration

            # Compute Jacobian
            J = self.jacobian_calc.geometric_jacobian(joints)

            # Damped least squares: J^T * (J * J^T + lambda^2 * I)^(-1)
            JJT = J @ J.T
            I = np.eye(JJT.shape[0])
            dls_matrix = J.T @ np.linalg.inv(JJT + damping_factor**2 * I)

            # Compute joint update
            delta_joints = dls_matrix @ error

            # Update joints
            joints = joints + delta_joints * 0.1  # Step size

            # Apply joint limits
            joints = self._apply_joint_limits(joints)

        return joints, False, self.max_iterations
```

### 5.3 Cyclic Coordinate Descent (CCD)

```python
class CCDInverseKinematics:
    """Cyclic Coordinate Descent Inverse Kinematics"""

    def __init__(self, robot_model, max_iterations=100, tolerance=1e-4):
        self.robot_model = robot_model
        self.max_iterations = max_iterations
        self.tolerance = tolerance

    def solve_ccd(self, target_pos, initial_joints):
        """
        Solve IK using Cyclic Coordinate Descent
        Particularly good for reaching tasks
        """
        joints = np.array(initial_joints, dtype=float)

        for iteration in range(self.max_iterations):
            # Compute current end-effector position
            current_pose = self.robot_model.compute_fk(joints)
            current_pos = current_pose[:3, 3]

            # Calculate distance to target
            distance = np.linalg.norm(target_pos - current_pos)

            if distance < self.tolerance:
                return joints, True, iteration

            # Iterate through joints from end to beginning
            for i in range(len(joints) - 1, -1, -1):
                # Get position of current joint
                temp_joints = joints.copy()
                temp_joints[i+1:] = initial_joints[i+1:]  # Keep distal joints fixed
                joint_pose = self.robot_model.compute_fk(temp_joints)
                joint_pos = joint_pose[:3, 3]

                # Calculate vectors
                to_target = target_pos - joint_pos
                to_current = current_pos - joint_pos

                # Normalize vectors
                to_target_norm = np.linalg.norm(to_target)
                to_current_norm = np.linalg.norm(to_current)

                if to_target_norm < 1e-6 or to_current_norm < 1e-6:
                    continue

                to_target = to_target / to_target_norm
                to_current = to_current / to_current_norm

                # Calculate rotation axis and angle
                cross_product = np.cross(to_current, to_target)
                axis_norm = np.linalg.norm(cross_product)

                if axis_norm > 1e-6:
                    axis = cross_product / axis_norm
                    dot_product = np.clip(np.dot(to_current, to_target), -1, 1)
                    angle = math.acos(dot_product)

                    # Update joint angle (simplified - in practice would need to
                    # map rotation to actual joint DOF)
                    joints[i] += angle * 0.1  # Step factor

        return joints, False, self.max_iterations
```

## 6. Whole-Body Kinematics Implementation

For humanoid robots, we need to coordinate multiple limbs:

```python
class WholeBodyKinematics:
    """Whole-body kinematics for humanoid robots"""

    def __init__(self):
        # Initialize individual limb kinematics
        self.left_arm_fk = HumanoidArmFK()
        self.right_arm_fk = HumanoidArmFK()  # Same model, different joint values
        self.left_leg_fk = self._create_leg_model()
        self.right_leg_fk = self._create_leg_model()

        # Torso reference frame
        self.torso_transform = np.eye(4)

    def _create_leg_model(self):
        """Create kinematic model for leg"""
        # Simplified 6-DOF leg model [hip_yaw, hip_roll, hip_pitch, knee, ankle_pitch, ankle_roll]
        class LegModel:
            def compute_fk(self, joint_angles):
                # Simplified leg FK - in practice would have proper DH parameters
                q = joint_angles
                # This is a placeholder implementation
                T = np.eye(4)
                # Add proper leg kinematics here
                return T

        return LegModel()

    def compute_whole_body(self, joint_angles_dict):
        """
        Compute whole-body kinematics
        joint_angles_dict: {'left_arm': [...], 'right_arm': [...],
                           'left_leg': [...], 'right_leg': [...], 'torso': [...]}
        """
        results = {}

        # Compute each limb independently
        if 'left_arm' in joint_angles_dict:
            results['left_hand'] = self.left_arm_fk.compute_fk(joint_angles_dict['left_arm'])

        if 'right_arm' in joint_angles_dict:
            results['right_hand'] = self.right_arm_fk.compute_fk(joint_angles_dict['right_arm'])

        if 'left_leg' in joint_angles_dict:
            results['left_foot'] = self.left_leg_fk.compute_fk(joint_angles_dict['left_leg'])

        if 'right_leg' in joint_angles_dict:
            results['right_foot'] = self.right_leg_fk.compute_fk(joint_angles_dict['right_leg'])

        # Include torso transformation
        results['torso'] = self.torso_transform

        return results

    def solve_multi_task_ik(self, tasks, initial_joints, weights=None):
        """
        Solve multi-task inverse kinematics
        tasks: list of (end_effector_name, target_pose, priority)
        """
        if weights is None:
            weights = np.ones(len(initial_joints))

        joints = np.array(initial_joints, dtype=float)

        # Sort tasks by priority (highest first)
        sorted_tasks = sorted(tasks, key=lambda x: x[2], reverse=True)

        for task_name, target_pose, priority in sorted_tasks:
            # Solve IK for this task
            if task_name.startswith('left_'):
                ik_solver = InverseKinematics(self.left_arm_fk)
            elif task_name.startswith('right_'):
                ik_solver = InverseKinematics(self.right_arm_fk)
            else:
                continue  # Skip unsupported tasks for now

            # Solve for this specific end-effector
            result_joints, success, iterations = ik_solver.solve_pseudoinverse(
                target_pose, joints
            )

            if success:
                joints = result_joints

        return joints, True
```

## 7. Optimization-Based IK Implementation

For more sophisticated control with multiple constraints:

```python
from scipy.optimize import minimize

class OptimizationBasedIK:
    """Optimization-based inverse kinematics"""

    def __init__(self, robot_model):
        self.robot_model = robot_model

    def solve_optimization_ik(self, target_poses, initial_joints,
                            joint_limits=None, constraints=None):
        """
        Solve IK as an optimization problem
        target_poses: dict of {end_effector_name: target_pose}
        """
        def objective_function(joint_vars):
            """Objective function to minimize"""
            total_error = 0.0

            # Compute FK for current joint configuration
            current_results = self._compute_all_poses(joint_vars)

            # Calculate error for each target
            for ee_name, target_pose in target_poses.items():
                if ee_name in current_results:
                    current_pose = current_results[ee_name]
                    error = self._pose_error(current_pose, target_pose)
                    total_error += np.sum(error**2)

            # Add regularization term to prefer nominal joint positions
            nominal_joints = np.zeros(len(joint_vars))  # Default positions
            regularization = 0.01 * np.sum((joint_vars - nominal_joints)**2)

            return total_error + regularization

        def constraint_function(joint_vars):
            """Constraint function"""
            violations = []

            # Joint limit constraints
            if joint_limits:
                lower, upper = joint_limits
                violations.extend(upper - joint_vars)  # upper bound: upper - joint_vars >= 0
                violations.extend(joint_vars - lower)  # lower bound: joint_vars - lower >= 0

            return np.array(violations)

        # Solve optimization problem
        result = minimize(
            objective_function,
            initial_joints,
            method='SLSQP',
            constraints={'type': 'ineq', 'fun': constraint_function} if joint_limits else (),
            options={'maxiter': 200}
        )

        return result.x, result.success, result.nit

    def _compute_all_poses(self, joints):
        """Compute poses for all end-effectors"""
        # This would depend on the specific robot structure
        # Placeholder implementation
        return {}

    def _pose_error(self, current_pose, target_pose):
        """Calculate pose error"""
        pos_error = target_pose[:3, 3] - current_pose[:3, 3]
        return pos_error
```

## 8. Performance Optimization Techniques

For real-time humanoid control, we need efficient implementations:

```python
import numba
from numba import jit

@jit(nopython=True)
def fast_dh_transform(a, alpha, d, theta):
    """Numba-optimized DH transformation"""
    c_theta = math.cos(theta)
    s_theta = math.sin(theta)
    c_alpha = math.cos(alpha)
    s_alpha = math.sin(alpha)

    result = np.zeros((4, 4))
    result[0, 0] = c_theta
    result[0, 1] = -s_theta * c_alpha
    result[0, 2] = s_theta * s_alpha
    result[0, 3] = a * c_theta
    result[1, 0] = s_theta
    result[1, 1] = c_theta * c_alpha
    result[1, 2] = -c_theta * s_alpha
    result[1, 3] = a * s_theta
    result[2, 0] = 0
    result[2, 1] = s_alpha
    result[2, 2] = c_alpha
    result[2, 3] = d
    result[3, 3] = 1

    return result

class OptimizedKinematics:
    """Optimized kinematics implementation for real-time performance"""

    def __init__(self, max_joints=30):
        self.max_joints = max_joints
        # Pre-allocate arrays to avoid memory allocation during execution
        self.transform_cache = [np.eye(4) for _ in range(max_joints)]
        self.jacobian_cache = np.zeros((6, max_joints))

    def compute_fk_cached(self, joint_angles):
        """Forward kinematics with caching for better performance"""
        n = len(joint_angles)
        T_total = np.eye(4)

        for i in range(min(n, self.max_joints)):
            # Use cached transformation if possible
            T_link = fast_dh_transform(0, 0, 0, joint_angles[i])  # Simplified
            T_total = T_total @ T_link

        return T_total
```

## 9. Integration with ROS

For practical humanoid implementation, integration with ROS is important:

```python
# This would be used in a ROS environment
try:
    import rospy
    from sensor_msgs.msg import JointState
    from geometry_msgs.msg import PoseStamped
    from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint

    class HumanoidKinematicsROS:
        """ROS interface for humanoid kinematics"""

        def __init__(self, robot_name="humanoid"):
            self.robot_name = robot_name
            self.kinematics = WholeBodyKinematics()

            # ROS publishers and subscribers
            self.joint_state_sub = rospy.Subscriber(
                '/joint_states', JointState, self.joint_state_callback
            )
            self.ik_service = rospy.Service(
                '/ik_solver', IKService, self.ik_service_callback
            )

            self.current_joints = None

        def joint_state_callback(self, msg):
            """Update current joint states"""
            self.current_joints = dict(zip(msg.name, msg.position))

        def ik_service_callback(self, req):
            """Handle IK service requests"""
            # Parse target poses from request
            target_poses = {}
            for target in req.targets:
                pose_matrix = self.pose_to_matrix(target.pose)
                target_poses[target.end_effector] = pose_matrix

            # Solve IK
            initial_joints = list(self.current_joints.values()) if self.current_joints else [0]*7
            result_joints, success = self.kinematics.solve_multi_task_ik(
                target_poses, initial_joints
            )

            # Create response
            response = IKServiceResponse()
            response.success = success
            response.joint_angles = result_joints
            response.error_code = 0 if success else -1

            return response

        def pose_to_matrix(self, pose):
            """Convert ROS pose to transformation matrix"""
            # Implementation to convert geometry_msgs/Pose to 4x4 matrix
            pass
except ImportError:
    print("ROS not available, skipping ROS integration")
```

## 10. Testing and Validation

Let's create a testing framework:

```python
class KinematicsTester:
    """Testing framework for kinematics implementations"""

    def __init__(self):
        self.arm_model = HumanoidArmFK()
        self.ik_solver = InverseKinematics(self.arm_model)

    def test_forward_kinematics(self):
        """Test forward kinematics implementation"""
        # Test with known joint angles
        test_joints = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]

        # Compute FK
        pose = self.arm_model.compute_fk(test_joints)

        # Verify it's a valid transformation matrix
        rotation = pose[:3, :3]
        is_rotation_valid = np.allclose(rotation @ rotation.T, np.eye(3), atol=1e-6)

        print(f"FK Test - Rotation matrix valid: {is_rotation_valid}")

        # Test pose extraction
        pos, euler = self.arm_model.get_end_effector_pose(test_joints)
        print(f"FK Test - Position: {pos}, Euler: {euler}")

    def test_inverse_kinematics(self):
        """Test inverse kinematics implementation"""
        # Define a target pose
        target_pose = np.eye(4)
        target_pose[0, 3] = 0.5  # x position
        target_pose[1, 3] = 0.2  # y position
        target_pose[2, 3] = 0.8  # z position

        # Solve IK
        initial_joints = [0] * 7
        solution, success, iterations = self.ik_solver.solve_pseudoinverse(
            target_pose, initial_joints
        )

        print(f"IK Test - Success: {success}, Iterations: {iterations}")

        if success:
            # Verify solution by computing FK of solution
            fk_result = self.arm_model.compute_fk(solution)
            pos_error = np.linalg.norm(target_pose[:3, 3] - fk_result[:3, 3])
            print(f"IK Test - Position error: {pos_error}")

    def test_jacobian_computation(self):
        """Test Jacobian computation"""
        joints = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]
        # Jacobian computation would go here
        print("Jacobian test placeholder")

    def run_all_tests(self):
        """Run all kinematics tests"""
        print("Running Kinematics Tests...")
        self.test_forward_kinematics()
        self.test_inverse_kinematics()
        self.test_jacobian_computation()
        print("Kinematics tests completed.")

# Example usage
if __name__ == "__main__":
    tester = KinematicsTester()
    tester.run_all_tests()

    # Example of solving a practical problem
    print("\nExample: Reaching task")

    # Define target position
    target_pose = np.eye(4)
    target_pose[0, 3] = 0.6  # x
    target_pose[1, 3] = 0.1  # y
    target_pose[2, 3] = 0.7  # z

    # Solve for arm configuration
    initial_joints = [0.0] * 7
    ik_solver = InverseKinematics(HumanoidArmFK())
    solution, success, iterations = ik_solver.solve_pseudoinverse(
        target_pose, initial_joints
    )

    if success:
        print(f"Found solution in {iterations} iterations")
        print(f"Joint angles: {solution}")

        # Verify solution
        final_pose = HumanoidArmFK().compute_fk(solution)
        error = np.linalg.norm(target_pose[:3, 3] - final_pose[:3, 3])
        print(f"Final position error: {error}")
    else:
        print("IK solution failed to converge")
```

## Summary

This implementation provides comprehensive kinematics solutions for humanoid robots, including:

1. **Forward Kinematics**: DH parameter-based computation for position and orientation
2. **Inverse Kinematics**: Multiple algorithms (pseudoinverse, DLS, CCD) for different scenarios
3. **Jacobian Computation**: Geometric method for velocity kinematics
4. **Whole-Body Coordination**: Multi-limb coordination for full humanoid kinematics
5. **Optimization Techniques**: Performance optimizations for real-time control
6. **ROS Integration**: Interface for practical robotic systems
7. **Testing Framework**: Validation of implementations

The code is structured to be modular and extensible, allowing for easy adaptation to specific humanoid robot configurations and requirements.