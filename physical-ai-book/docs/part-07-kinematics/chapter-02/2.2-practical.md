---
title: 7.2.2 Jacobian and Differential Kinematics Implementation
sidebar_position: 32
---

# 7.2.2 Jacobian and Differential Kinematics Implementation

## Learning Objectives

- Implement Jacobian computation algorithms for humanoid robots
- Develop differential kinematics solvers for real-time control
- Apply singularity detection and handling techniques
- Integrate Jacobian-based control with humanoid hardware
- Optimize computational performance for real-time applications

## Introduction

The implementation of Jacobian and differential kinematics in humanoid robots requires careful consideration of computational efficiency, numerical stability, and real-time performance. Unlike theoretical formulations, practical implementations must handle the complexities of real hardware including sensor noise, actuator limitations, and timing constraints. This section provides detailed implementation strategies for computing Jacobians, solving differential kinematics problems, and handling singularities in real-world humanoid robot systems.

The practical implementation of Jacobian-based methods involves several key challenges: computational efficiency to meet real-time control requirements, numerical stability near singular configurations, integration with existing control systems, and robustness to modeling errors and sensor noise. These challenges are particularly acute in humanoid robotics where multiple limbs must be coordinated simultaneously while maintaining balance and safety.

Modern implementations often utilize optimized mathematical libraries, parallel processing, and specialized algorithms to achieve the required performance. The choice of implementation approach depends on factors such as the robot's kinematic structure, the required control frequency, and the specific tasks the robot is expected to perform.

## 2. Jacobian Computation Implementation

### 2.1 Geometric Jacobian Computation

The geometric Jacobian computation can be implemented using the cross-product method, which provides an intuitive geometric interpretation of the relationship between joint motions and end-effector motion:

```python
import numpy as np
from scipy.spatial.transform import Rotation as R

class GeometricJacobian:
    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.n_joints = len(robot_model.joint_info)

    def compute_jacobian(self, joint_angles, end_effector_link):
        """
        Compute the geometric Jacobian using the cross-product method
        """
        # Forward kinematics to get all transformation matrices
        transforms = self.robot_model.forward_kinematics(joint_angles)

        # Get end-effector position
        end_effector_pos = transforms[end_effector_link][:3, 3]

        # Initialize Jacobian (6 x n_joints)
        jacobian = np.zeros((6, self.n_joints))

        for i in range(self.n_joints):
            # Get joint axis in world frame
            joint_transform = transforms[i]
            z_axis = joint_transform[:3, 2]  # Third column is z-axis

            # Get joint position
            joint_pos = joint_transform[:3, 3]

            # Compute position contribution (linear velocity)
            if self.robot_model.joint_info[i]['type'] == 'revolute':
                jacobian[:3, i] = np.cross(z_axis, end_effector_pos - joint_pos)
                # Compute orientation contribution (angular velocity)
                jacobian[3:, i] = z_axis
            else:  # prismatic joint
                jacobian[:3, i] = z_axis
                jacobian[3:, i] = np.zeros(3)

        return jacobian

    def compute_body_jacobian(self, joint_angles, end_effector_link):
        """
        Compute the body Jacobian (expressed in end-effector frame)
        """
        world_jacobian = self.compute_jacobian(joint_angles, end_effector_link)
        end_effector_transform = self.robot_model.forward_kinematics(joint_angles)[end_effector_link]

        # Transform from world frame to body frame
        R_ee = end_effector_transform[:3, :3]
        p_ee = end_effector_transform[:3, 3]

        # Adjoint transformation matrix
        adjoint = np.zeros((6, 6))
        adjoint[:3, :3] = R_ee.T
        adjoint[3:, 3:] = R_ee.T
        adjoint[:3, 3:] = -R_ee.T @ self.skew_symmetric(p_ee) @ R_ee.T

        return adjoint @ world_jacobian

    def skew_symmetric(self, vector):
        """Create skew-symmetric matrix from vector"""
        return np.array([
            [0, -vector[2], vector[1]],
            [vector[2], 0, -vector[0]],
            [-vector[1], vector[0], 0]
        ])
```

### 2.2 Analytical Jacobian Implementation

For robots with specific kinematic structures, analytical Jacobians can be computed more efficiently by exploiting the structure:

```python
class AnalyticalJacobian:
    def __init__(self, robot_model):
        self.robot_model = robot_model

    def compute_analytical_jacobian(self, joint_angles):
        """
        Compute analytical Jacobian for a specific robot structure
        Example: 6-DOF anthropomorphic arm
        """
        q1, q2, q3, q4, q5, q6 = joint_angles

        # DH parameters (example for anthropomorphic arm)
        a2, a3 = self.robot_model.dh_params['a2'], self.robot_model.dh_params['a3']
        d1, d3, d4 = self.robot_model.dh_params['d1'], self.robot_model.dh_params['d3'], self.robot_model.dh_params['d4']

        # Precompute trigonometric functions
        c1, s1 = np.cos(q1), np.sin(q1)
        c2, s2 = np.cos(q2), np.sin(q2)
        c3, s3 = np.cos(q3), np.sin(q3)
        c23, s23 = np.cos(q2 + q3), np.sin(q2 + q3)

        # Position Jacobian
        Jv = np.zeros((3, 6))

        # Column 1 (Jv1)
        Jv[0, 0] = -s1 * (a2 * c2 + a3 * c23 + d4 * s23)
        Jv[1, 0] = c1 * (a2 * c2 + a3 * c23 + d4 * s23)
        Jv[2, 0] = 0

        # Column 2 (Jv2)
        Jv[0, 1] = -c1 * (a2 * s2 + a3 * s23 - d4 * c23)
        Jv[1, 1] = -s1 * (a2 * s2 + a3 * s23 - d4 * c23)
        Jv[2, 1] = a2 * c2 + a3 * c23 - d4 * s23

        # Column 3 (Jv3)
        Jv[0, 2] = -c1 * (a3 * s23 - d4 * c23)
        Jv[1, 2] = -s1 * (a3 * s23 - d4 * c23)
        Jv[2, 2] = a3 * c23 + d4 * s23

        # Columns 4, 5, 6 depend on specific robot configuration
        # Implementation continues based on robot structure

        # Orientation Jacobian
        Jo = self.compute_orientation_jacobian(joint_angles)

        # Full Jacobian
        jacobian = np.vstack([Jv, Jo])

        return jacobian

    def compute_orientation_jacobian(self, joint_angles):
        """
        Compute orientation Jacobian for rotation
        """
        q1, q2, q3, q4, q5, q6 = joint_angles

        # Compute orientation Jacobian based on Euler angles or other representation
        Jo = np.zeros((3, 6))

        # Example implementation for specific robot
        # This would be customized based on the robot's kinematic structure

        return Jo
```

### 2.3 Spatial Vector Notation Implementation

The spatial vector notation approach provides a unified framework for handling both position and orientation:

```python
class SpatialJacobian:
    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.n_joints = len(robot_model.joint_info)

    def compute_spatial_jacobian(self, joint_angles, base_transform=None):
        """
        Compute spatial Jacobian using spatial vector notation
        """
        if base_transform is None:
            base_transform = np.eye(4)

        # Initialize spatial Jacobian (6 x n_joints)
        Js = np.zeros((6, self.n_joints))

        # Forward kinematics to get all transforms
        transforms = self.robot_model.forward_kinematics(joint_angles)

        # Compute body Jacobian for each joint
        for i in range(self.n_joints):
            # Get joint screw in body frame
            joint_screw = self.compute_joint_screw(i, transforms)

            # Transform to spatial frame
            adjoint_matrix = self.compute_adjoint_transform(transforms[i], base_transform)
            Js[:, i] = adjoint_matrix @ joint_screw

        return Js

    def compute_joint_screw(self, joint_idx, transforms):
        """
        Compute the unit screw for a joint in body coordinates
        """
        # Get joint axis and position from robot model
        joint_info = self.robot_model.joint_info[joint_idx]
        axis = joint_info['axis']  # Joint axis in local coordinates
        position = transforms[joint_idx][:3, 3]  # Joint position

        if joint_info['type'] == 'revolute':
            # For revolute joints: screw = [omega; v] where v = -omega x q
            omega = axis
            v = -np.cross(omega, position)
            return np.hstack([omega, v])
        else:  # prismatic
            # For prismatic joints: screw = [0; d] where d is direction
            return np.hstack([np.zeros(3), axis])

    def compute_adjoint_transform(self, transform1, transform2):
        """
        Compute adjoint transformation matrix
        Adjoint maps spatial velocity from frame 1 to frame 2
        """
        R = transform2[:3, :3] @ transform1[:3, :3].T
        p = transform2[:3, 3] - R @ transform1[:3, 3]

        adjoint = np.zeros((6, 6))
        adjoint[:3, :3] = R
        adjoint[3:, 3:] = R
        adjoint[:3, 3:] = self.skew_symmetric(p) @ R

        return adjoint

    def skew_symmetric(self, vector):
        """Create skew-symmetric matrix from vector"""
        return np.array([
            [0, -vector[2], vector[1]],
            [vector[2], 0, -vector[0]],
            [-vector[1], vector[0], 0]
        ])
```

## 3. Differential Kinematics Solvers

### 3.1 Inverse Velocity Solver

The inverse velocity solver computes joint velocities required to achieve desired end-effector velocities:

```python
class InverseVelocitySolver:
    def __init__(self, robot_model, jacobian_calculator):
        self.robot_model = robot_model
        self.jacobian_calc = jacobian_calculator
        self.damping_factor = 0.01  # For damped least squares

    def solve_inverse_velocity(self, joint_angles, desired_velocity, method='dls'):
        """
        Solve inverse velocity kinematics
        """
        jacobian = self.jacobian_calc.compute_jacobian(joint_angles, 'end_effector')

        if method == 'pinv':
            # Pseudoinverse method
            joint_velocities = np.linalg.pinv(jacobian) @ desired_velocity
        elif method == 'dls':
            # Damped Least Squares
            joint_velocities = self.damped_least_squares(jacobian, desired_velocity)
        elif method == 'transpose':
            # Transpose method (for redundant systems)
            joint_velocities = jacobian.T @ desired_velocity
        else:
            raise ValueError(f"Unknown method: {method}")

        return joint_velocities

    def damped_least_squares(self, jacobian, desired_velocity):
        """
        Damped Least Squares method for inverse velocity kinematics
        """
        m, n = jacobian.shape
        damping_matrix = self.damping_factor * np.eye(n)

        if m >= n:  # More equations than unknowns (overdetermined)
            # J^T * (J * J^T + lambda^2 * I)^(-1) * x_des
            return jacobian.T @ np.linalg.inv(jacobian @ jacobian.T + damping_matrix @ damping_matrix) @ desired_velocity
        else:  # Underdetermined system
            # (J^T * J + lambda^2 * I)^(-1) * J^T * x_des
            return np.linalg.inv(jacobian.T @ jacobian + damping_matrix @ damping_matrix) @ jacobian.T @ desired_velocity

    def solve_redundant_system(self, joint_angles, desired_velocity,
                              null_task_velocity=None, null_weight=0.1):
        """
        Solve for redundant systems with null space optimization
        """
        jacobian = self.jacobian_calc.compute_jacobian(joint_angles, 'end_effector')

        # Primary task solution
        j_pinv = self.damped_least_squares(jacobian, desired_velocity)

        if null_task_velocity is not None:
            # Compute null space projector
            I = np.eye(jacobian.shape[1])
            null_projector = I - np.linalg.pinv(jacobian) @ jacobian

            # Null space task solution
            null_solution = self.solve_inverse_velocity(joint_angles, null_task_velocity, method='dls')

            # Combine solutions with weighting
            joint_velocities = j_pinv + null_weight * null_projector @ null_solution
        else:
            joint_velocities = j_pinv

        return joint_velocities
```

### 3.2 Forward Velocity Solver

The forward velocity solver computes end-effector velocities from joint velocities:

```python
class ForwardVelocitySolver:
    def __init__(self, jacobian_calculator):
        self.jacobian_calc = jacobian_calculator

    def solve_forward_velocity(self, joint_angles, joint_velocities, end_effector_link='end_effector'):
        """
        Solve forward velocity kinematics: x_dot = J * q_dot
        """
        jacobian = self.jacobian_calc.compute_jacobian(joint_angles, end_effector_link)
        end_effector_velocity = jacobian @ joint_velocities

        return end_effector_velocity

    def solve_multiple_end_effectors(self, joint_angles, joint_velocities, end_effector_links):
        """
        Solve forward velocity for multiple end-effectors simultaneously
        """
        velocities = {}

        for link in end_effector_links:
            jacobian = self.jacobian_calc.compute_jacobian(joint_angles, link)
            velocities[link] = jacobian @ joint_velocities

        return velocities
```

## 4. Singularity Detection and Handling

### 4.1 Singularity Detection Methods

```python
class SingularityDetector:
    def __init__(self, threshold=0.001):
        self.threshold = threshold  # Singularity threshold

    def detect_singularity(self, jacobian, method='condition_number'):
        """
        Detect singular configurations using various methods
        """
        if method == 'condition_number':
            return self.detect_by_condition_number(jacobian)
        elif method == 'determinant':
            return self.detect_by_determinant(jacobian)
        elif method == 'svd':
            return self.detect_by_svd(jacobian)
        else:
            raise ValueError(f"Unknown method: {method}")

    def detect_by_condition_number(self, jacobian):
        """
        Detect singularity using condition number
        """
        if jacobian.shape[0] == jacobian.shape[1]:  # Square matrix
            cond_num = np.linalg.cond(jacobian)
        else:  # Rectangular matrix
            U, s, Vt = np.linalg.svd(jacobian)
            cond_num = s[0] / s[-1] if s[-1] != 0 else float('inf')

        return cond_num > 1.0 / self.threshold, cond_num

    def detect_by_determinant(self, jacobian):
        """
        Detect singularity using determinant (for square matrices)
        """
        if jacobian.shape[0] != jacobian.shape[1]:
            raise ValueError("Determinant method only works for square matrices")

        det = np.linalg.det(jacobian)
        return abs(det) < self.threshold, abs(det)

    def detect_by_svd(self, jacobian):
        """
        Detect singularity using SVD
        """
        U, s, Vt = np.linalg.svd(jacobian)

        # Check if smallest singular value is below threshold
        smallest_sv = s[-1]
        is_singular = smallest_sv < self.threshold

        return is_singular, smallest_sv

    def get_singular_directions(self, jacobian):
        """
        Get singular directions (vectors in the null space)
        """
        U, s, Vt = np.linalg.svd(jacobian)

        # Find singular values below threshold
        singular_indices = np.where(s < self.threshold)[0]

        if len(singular_indices) == 0:
            return None, None

        # Right singular vectors corresponding to near-zero singular values
        # represent directions in joint space that don't affect end-effector
        null_space_dirs = Vt[singular_indices, :]

        # Left singular vectors represent directions in task space
        # that cannot be achieved
        task_space_singular_dirs = U[:, singular_indices]

        return null_space_dirs, task_space_singular_dirs
```

### 4.2 Singularity-Robust Control

```python
class SingularityRobustController:
    def __init__(self, base_controller, singularity_detector):
        self.base_controller = base_controller
        self.singularity_detector = singularity_detector
        self.damping_factor = 0.01
        self.adaptive_damping = True

    def compute_joint_velocities(self, jacobian, desired_velocity, joint_angles):
        """
        Compute joint velocities with singularity handling
        """
        # Check for singularity
        is_singular, cond_num = self.singularity_detector.detect_by_condition_number(jacobian)

        if is_singular:
            if self.adaptive_damping:
                # Adaptive damping based on condition number
                self.damping_factor = min(0.1, max(0.001, 1.0 / cond_num))

            # Use damped least squares
            joint_velocities = self.damped_least_squares(jacobian, desired_velocity)

            # Log singularity event for monitoring
            self.log_singularity_event(joint_angles, cond_num)
        else:
            # Normal operation
            joint_velocities = np.linalg.pinv(jacobian) @ desired_velocity

        return joint_velocities

    def damped_least_squares(self, jacobian, desired_velocity):
        """
        Damped Least Squares with adaptive damping
        """
        m, n = jacobian.shape

        if m >= n:  # Overdetermined
            damping_matrix = self.damping_factor * np.eye(n)
            return jacobian.T @ np.linalg.inv(jacobian @ jacobian.T +
                                            damping_matrix @ damping_matrix) @ desired_velocity
        else:  # Underdetermined
            damping_matrix = self.damping_factor * np.eye(m)
            return np.linalg.inv(jacobian.T @ jacobian +
                               damping_matrix @ damping_matrix) @ jacobian.T @ desired_velocity

    def log_singularity_event(self, joint_angles, condition_number):
        """
        Log singularity events for analysis and debugging
        """
        print(f"Singularity detected: condition number = {condition_number:.2e}")
        print(f"Joint angles: {joint_angles}")
        # In practice, this would log to a file or monitoring system
```

## 5. Real-Time Implementation Considerations

### 5.1 Performance Optimization

```python
import time
import threading
from collections import deque

class RealTimeJacobianController:
    def __init__(self, robot_model, control_frequency=1000):  # 1kHz control
        self.robot_model = robot_model
        self.control_frequency = control_frequency
        self.dt = 1.0 / control_frequency
        self.jacobian_calc = GeometricJacobian(robot_model)
        self.inverse_solver = InverseVelocitySolver(robot_model, self.jacobian_calc)
        self.singularity_detector = SingularityDetector()

        # Caching for performance
        self.jacobian_cache = {}
        self.last_joint_angles = None
        self.cache_valid = False

        # Real-time monitoring
        self.computation_times = deque(maxlen=100)
        self.control_thread = None
        self.running = False

    def compute_cached_jacobian(self, joint_angles, end_effector_link='end_effector'):
        """
        Compute Jacobian with caching for performance
        """
        # Convert to tuple for hashing
        angle_tuple = tuple(np.round(joint_angles, decimals=3))

        cache_key = (angle_tuple, end_effector_link)

        if (self.cache_valid and
            self.last_joint_angles is not None and
            np.allclose(joint_angles, self.last_joint_angles, atol=1e-3)):
            # Use cached result if angles haven't changed significantly
            if hasattr(self, '_cached_jacobian'):
                return self._cached_jacobian

        # Compute new Jacobian
        start_time = time.time()
        jacobian = self.jacobian_calc.compute_jacobian(joint_angles, end_effector_link)
        computation_time = time.time() - start_time

        # Store in cache
        self._cached_jacobian = jacobian
        self.last_joint_angles = joint_angles.copy()
        self.cache_valid = True

        # Track performance
        self.computation_times.append(computation_time)

        return jacobian

    def get_average_computation_time(self):
        """
        Get average Jacobian computation time
        """
        if len(self.computation_times) == 0:
            return 0.0
        return sum(self.computation_times) / len(self.computation_times)

    def is_real_time_capable(self):
        """
        Check if computation is fast enough for real-time control
        """
        avg_time = self.get_average_computation_time()
        # Should be at least 10x faster than control period for safety
        return avg_time < (self.dt / 10.0)

    def run_control_loop(self, trajectory_generator, hardware_interface):
        """
        Main control loop for real-time operation
        """
        self.running = True

        while self.running:
            start_time = time.time()

            # Get current joint angles from hardware
            current_angles = hardware_interface.get_joint_angles()

            # Get desired end-effector velocity from trajectory
            desired_velocity = trajectory_generator.get_desired_velocity()

            # Compute Jacobian
            jacobian = self.compute_cached_jacobian(current_angles)

            # Check for singularities
            is_singular, cond_num = self.singularity_detector.detect_by_condition_number(jacobian)

            if is_singular:
                # Implement singularity handling strategy
                joint_velocities = self.handle_singularity(jacobian, desired_velocity, current_angles)
            else:
                # Normal control
                joint_velocities = np.linalg.pinv(jacobian) @ desired_velocity

            # Apply joint velocity limits
            joint_velocities = self.apply_velocity_limits(joint_velocities)

            # Send commands to hardware
            hardware_interface.set_joint_velocities(joint_velocities)

            # Maintain control rate
            elapsed = time.time() - start_time
            sleep_time = max(0, self.dt - elapsed)

            if sleep_time > 0:
                time.sleep(sleep_time)

    def handle_singularity(self, jacobian, desired_velocity, joint_angles):
        """
        Handle control when near singularities
        """
        # Use damped least squares with increased damping
        dls_controller = SingularityRobustController(None, self.singularity_detector)
        return dls_controller.compute_joint_velocities(jacobian, desired_velocity, joint_angles)

    def apply_velocity_limits(self, joint_velocities, limits=None):
        """
        Apply joint velocity limits
        """
        if limits is None:
            # Use default limits (1 rad/s for all joints)
            limits = np.ones(len(joint_velocities))

        return np.clip(joint_velocities, -limits, limits)
```

## 6. Humanoid-Specific Implementations

### 6.1 Multi-Limb Jacobian Integration

```python
class MultiLimbJacobianController:
    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.limbs = {
            'left_arm': {'start': 'l_shoulder', 'end': 'l_end_effector'},
            'right_arm': {'start': 'r_shoulder', 'end': 'r_end_effector'},
            'left_leg': {'start': 'l_hip', 'end': 'l_foot'},
            'right_leg': {'start': 'r_hip', 'end': 'r_foot'},
            'torso': {'start': 'torso_base', 'end': 'torso_top'}
        }

        # Individual limb Jacobian calculators
        self.limb_calculators = {}
        for limb_name, config in self.limbs.items():
            self.limb_calculators[limb_name] = GeometricJacobian(robot_model)

    def compute_whole_body_jacobian(self, joint_angles):
        """
        Compute the whole-body Jacobian matrix
        """
        # Get joint indices for each limb
        limb_indices = self.get_limb_joint_indices()

        # Compute individual limb Jacobians
        limb_jacobians = {}
        for limb_name, indices in limb_indices.items():
            # Extract joint angles for this limb
            limb_angles = joint_angles[indices]

            # Compute Jacobian for this limb
            limb_jacobians[limb_name] = self.limb_calculators[limb_name].compute_jacobian(
                limb_angles, self.limbs[limb_name]['end']
            )

        # Combine into whole-body Jacobian
        return self.combine_limb_jacobians(limb_jacobians, limb_indices, len(joint_angles))

    def get_limb_joint_indices(self):
        """
        Get joint indices for each limb based on robot model
        """
        indices = {}

        # This would be populated based on the specific robot's joint ordering
        # Example structure:
        joint_names = self.robot_model.get_joint_names()

        # Map joint names to indices
        name_to_idx = {name: i for i, name in enumerate(joint_names)}

        # Define limb joint sets (this would be robot-specific)
        limb_joint_sets = {
            'left_arm': ['l_shoulder_pitch', 'l_shoulder_roll', 'l_shoulder_yaw',
                        'l_elbow_pitch', 'l_wrist_yaw', 'l_wrist_pitch'],
            'right_arm': ['r_shoulder_pitch', 'r_shoulder_roll', 'r_shoulder_yaw',
                         'r_elbow_pitch', 'r_wrist_yaw', 'r_wrist_pitch'],
            'left_leg': ['l_hip_yaw', 'l_hip_roll', 'l_hip_pitch',
                        'l_knee_pitch', 'l_ankle_pitch', 'l_ankle_roll'],
            'right_leg': ['r_hip_yaw', 'r_hip_roll', 'r_hip_pitch',
                         'r_knee_pitch', 'r_ankle_pitch', 'r_ankle_roll']
        }

        for limb, joint_list in limb_joint_sets.items():
            indices[limb] = [name_to_idx[name] for name in joint_list if name in name_to_idx]

        return indices

    def combine_limb_jacobians(self, limb_jacobians, limb_indices, total_joints):
        """
        Combine individual limb Jacobians into whole-body Jacobian
        """
        # Determine total task space dimensions
        total_task_dof = sum(jac.shape[0] for jac in limb_jacobians.values())

        # Initialize whole-body Jacobian
        whole_body_jac = np.zeros((total_task_dof, total_joints))

        # Fill in each limb's Jacobian in the appropriate columns
        task_row_start = 0
        for limb_name, jacobian in limb_jacobians.items():
            task_rows = jacobian.shape[0]
            joint_cols = jacobian.shape[1]

            # Get the indices for this limb's joints in the full joint vector
            limb_joint_indices = limb_indices[limb_name]

            # Place the Jacobian in the appropriate location
            whole_body_jac[task_row_start:task_row_start + task_rows, limb_joint_indices] = jacobian

            task_row_start += task_rows

        return whole_body_jac
```

### 6.2 Balance and Stability Integration

```python
class BalanceIntegratedController:
    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.jacobian_calc = GeometricJacobian(robot_model)
        self.com_jacobian = None  # Jacobian for center of mass
        self.zmp_jacobian = None  # Jacobian for zero moment point

    def compute_com_jacobian(self, joint_angles):
        """
        Compute Jacobian for center of mass position
        """
        # Forward kinematics to get all link positions and masses
        transforms = self.robot_model.forward_kinematics(joint_angles)
        link_info = self.robot_model.link_info

        # Compute total mass and center of mass
        total_mass = sum(link['mass'] for link in link_info.values())
        com_position = np.zeros(3)

        for link_name, link in link_info.items():
            link_transform = transforms[link_name]
            link_com = link_transform[:3, :3] @ link['com_offset'] + link_transform[:3, 3]
            com_position += link['mass'] * link_com

        com_position /= total_mass

        # Compute Jacobian columns for each joint
        com_jac = np.zeros((3, len(joint_angles)))

        for i in range(len(joint_angles)):
            # Compute how joint i affects COM position
            # This is a simplified implementation - in practice, this would involve
            # more complex differentiation of the COM calculation
            joint_transform = transforms[i]
            joint_axis = joint_transform[:3, 2]  # z-axis of joint
            joint_pos = joint_transform[:3, 3]

            # Contribution to COM velocity from this joint
            # (simplified - would need proper differentiation in practice)
            for link_name, link in link_info.items():
                if self.is_link_affected_by_joint(i, link_name):
                    link_transform = transforms[link_name]
                    link_pos = link_transform[:3, 3]
                    # Simplified: assume link moves with joint motion
                    com_jac[:, i] += (link['mass'] / total_mass) * np.cross(joint_axis, link_pos - joint_pos)

        self.com_jacobian = com_jac
        return com_jac

    def compute_zmp_jacobian(self, joint_angles):
        """
        Compute Jacobian for Zero Moment Point
        """
        # ZMP = [x, y, 0] where moments about x and y axes are zero
        # ZMP_x = (Int[∫(x·ρ·g·dz)] - Fz·xc) / Fz
        # ZMP_y = (Int[∫(y·ρ·g·dz)] - Fz·yc) / Fz

        # This is a simplified implementation
        # In practice, ZMP Jacobian computation involves complex dynamics

        com_jac = self.compute_com_jacobian(joint_angles)

        # For simplified ZMP calculation assuming flat ground contact
        # ZMP ≈ projection of COM on ground plane when robot is balanced
        zmp_jac = np.zeros((2, len(joint_angles)))  # ZMP has 2 DOF (x, y)
        zmp_jac[:2, :] = com_jac[:2, :]  # Simplified assumption

        self.zmp_jacobian = zmp_jac
        return zmp_jac

    def is_link_affected_by_joint(self, joint_idx, link_name):
        """
        Check if a link is affected by motion of a specific joint
        This would be implemented based on the robot's kinematic tree
        """
        # This would be implemented based on the specific robot's kinematic structure
        # Return True if the link is a descendant of the joint in the kinematic tree
        return True  # Simplified implementation

    def balance_control(self, joint_angles, desired_com_position, current_com_position):
        """
        Balance control using COM Jacobian
        """
        # Compute COM Jacobian
        com_jac = self.compute_com_jacobian(joint_angles)

        # Compute desired COM velocity
        com_error = desired_com_position - current_com_position
        desired_com_vel = 2.0 * com_error  # Simple PD-like control

        # Solve for joint velocities to achieve desired COM velocity
        joint_velocities = np.linalg.pinv(com_jac) @ desired_com_vel

        return joint_velocities
```

## 7. Testing and Validation

### 7.1 Unit Testing for Jacobian Implementation

```python
import unittest

class TestJacobianImplementation(unittest.TestCase):
    def setUp(self):
        # Create a simple test robot model
        self.robot_model = self.create_test_robot()
        self.jacobian_calc = GeometricJacobian(self.robot_model)

    def create_test_robot(self):
        """
        Create a simple test robot (e.g., 3-DOF planar arm)
        """
        class TestRobot:
            def __init__(self):
                self.joint_info = [
                    {'type': 'revolute', 'axis': [0, 0, 1]},
                    {'type': 'revolute', 'axis': [0, 0, 1]},
                    {'type': 'revolute', 'axis': [0, 0, 1]}
                ]
                self.dh_params = {'a1': 1.0, 'a2': 1.0, 'a3': 0.5}

            def forward_kinematics(self, joint_angles):
                # Simplified FK implementation for testing
                transforms = {}
                # Implementation would go here
                return transforms

        return TestRobot()

    def test_jacobian_properties(self):
        """
        Test fundamental properties of Jacobian
        """
        joint_angles = np.array([0.1, 0.2, 0.3])

        # Test 1: Jacobian should be 6x3 for 3-DOF robot with 6-DOF end-effector
        jacobian = self.jacobian_calc.compute_jacobian(joint_angles, 'end_effector')
        self.assertEqual(jacobian.shape, (6, 3), "Jacobian shape should be (6, 3)")

    def test_inverse_kinematics_solution(self):
        """
        Test that inverse velocity solution produces expected results
        """
        joint_angles = np.array([0.0, 0.0, 0.0])
        desired_velocity = np.array([0.1, 0.0, 0.0, 0.0, 0.0, 0.0])  # Pure x-direction

        jacobian = self.jacobian_calc.compute_jacobian(joint_angles, 'end_effector')
        inverse_solver = InverseVelocitySolver(self.robot_model, self.jacobian_calc)

        joint_velocities = inverse_solver.solve_inverse_velocity(joint_angles, desired_velocity)

        # Verify that the solution produces the desired end-effector velocity
        actual_velocity = jacobian @ joint_velocities

        # Allow for small numerical errors
        np.testing.assert_allclose(actual_velocity, desired_velocity, rtol=1e-3)

    def test_singularity_detection(self):
        """
        Test singularity detection at known singular configurations
        """
        # Test at a configuration that should be singular
        singular_angles = np.array([0.0, 0.0, 0.0])  # Example singular config

        jacobian = self.jacobian_calc.compute_jacobian(singular_angles, 'end_effector')
        detector = SingularityDetector()

        is_singular, cond_num = detector.detect_by_condition_number(jacobian)

        # In a real test, we would know if this specific config is singular
        # For now, just ensure the function runs without error
        self.assertIsInstance(is_singular, (bool, np.bool_))
        self.assertIsInstance(cond_num, (int, float, np.number))

# To run the tests:
# if __name__ == '__main__':
#     unittest.main()
```

### 7.2 Integration Testing with Hardware Simulation

```python
class IntegrationTester:
    def __init__(self, robot_controller, simulation_environment):
        self.controller = robot_controller
        self.sim_env = simulation_environment

    def test_jacobian_accuracy(self):
        """
        Test Jacobian accuracy against finite differences
        """
        test_configs = [
            np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
            np.array([0.1, 0.2, 0.3, 0.1, 0.2, 0.1]),
            np.array([0.5, -0.3, 0.8, -0.2, 0.4, -0.1])
        ]

        for config in test_configs:
            # Compute analytical Jacobian
            analytical_jac = self.controller.jacobian_calc.compute_jacobian(config, 'end_effector')

            # Compute numerical Jacobian using finite differences
            numerical_jac = self.compute_numerical_jacobian(config)

            # Compare results
            error = np.max(np.abs(analytical_jac - numerical_jac))

            print(f"Configuration: {config}")
            print(f"Max error: {error}")
            print(f"Analytical Jacobian:\n{analytical_jac}")
            print(f"Numerical Jacobian:\n{numerical_jac}")
            print("---")

    def compute_numerical_jacobian(self, joint_angles, eps=1e-6):
        """
        Compute Jacobian using numerical differentiation
        """
        n_joints = len(joint_angles)
        jacobian = np.zeros((6, n_joints))  # 6-DOF end-effector

        for i in range(n_joints):
            # Positive perturbation
            angles_plus = joint_angles.copy()
            angles_plus[i] += eps
            fk_plus = self.controller.robot_model.forward_kinematics(angles_plus)['end_effector']

            # Negative perturbation
            angles_minus = joint_angles.copy()
            angles_minus[i] -= eps
            fk_minus = self.controller.robot_model.forward_kinematics(angles_minus)['end_effector']

            # Compute velocity: (pos_plus - pos_minus) / (2*eps)
            pos_plus = fk_plus[:3, 3]
            pos_minus = fk_minus[:3, 3]

            linear_vel = (pos_plus - pos_minus) / (2 * eps)

            # Compute angular velocity from rotation matrices
            R_plus = fk_plus[:3, :3]
            R_minus = fk_minus[:3, :3]

            # Use logarithmic map to get angular velocity
            R_diff = R_plus @ R_minus.T
            # Simplified: assume small angles for testing
            angular_vel = np.array([
                R_diff[2, 1] - R_diff[1, 2],
                R_diff[0, 2] - R_diff[2, 0],
                R_diff[1, 0] - R_diff[0, 1]
            ]) / (2 * eps)

            jacobian[:, i] = np.hstack([linear_vel, angular_vel])

        return jacobian
```

## 8. Performance Optimization

### 8.1 Caching and Pre-computation

```python
class OptimizedJacobianCalculator:
    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.cache = {}
        self.max_cache_size = 1000
        self.precomputed_trig = {}  # Precomputed trigonometric values

    def compute_optimized_jacobian(self, joint_angles, end_effector_link):
        """
        Compute Jacobian with optimization techniques
        """
        # Round angles to reduce cache misses
        rounded_angles = tuple(np.round(joint_angles, decimals=3))
        cache_key = (rounded_angles, end_effector_link)

        if cache_key in self.cache:
            return self.cache[cache_key]

        # Precompute trigonometric values
        trig_values = self.precompute_trigonometric(joint_angles)

        # Compute Jacobian using precomputed values
        jacobian = self.compute_jacobian_with_trig(joint_angles, end_effector_link, trig_values)

        # Add to cache with size management
        if len(self.cache) >= self.max_cache_size:
            # Remove oldest entries (simple FIFO)
            oldest_key = next(iter(self.cache))
            del self.cache[oldest_key]

        self.cache[cache_key] = jacobian

        return jacobian

    def precompute_trigonometric(self, joint_angles):
        """
        Precompute trigonometric values to avoid repeated calculations
        """
        trig_vals = {}
        for i, angle in enumerate(joint_angles):
            trig_vals[f'c{i}'] = np.cos(angle)
            trig_vals[f's{i}'] = np.sin(angle)
            # Precompute common combinations
            if i < len(joint_angles) - 1:
                next_angle = joint_angles[i + 1]
                trig_vals[f'c{i}_{i+1}'] = np.cos(angle + next_angle)
                trig_vals[f's{i}_{i+1}'] = np.sin(angle + next_angle)

        return trig_vals

    def compute_jacobian_with_trig(self, joint_angles, end_effector_link, trig_values):
        """
        Compute Jacobian using precomputed trigonometric values
        """
        # Implementation using precomputed values
        # This would be customized based on the specific robot structure
        return self.robot_model.compute_jacobian(joint_angles, end_effector_link)
```

### 8.2 Parallel Processing Implementation

```python
import multiprocessing as mp
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
import threading

class ParallelJacobianProcessor:
    def __init__(self, robot_model, num_processes=None):
        self.robot_model = robot_model
        self.num_processes = num_processes or mp.cpu_count()
        self.jacobian_calc = GeometricJacobian(robot_model)

        # Thread-safe cache
        self.cache_lock = threading.Lock()
        self.cache = {}

    def compute_multiple_jacobians_parallel(self, joint_angle_configs, end_effector_links):
        """
        Compute multiple Jacobians in parallel
        """
        tasks = [(config, link) for config, link in zip(joint_angle_configs, end_effector_links)]

        with ThreadPoolExecutor(max_workers=self.num_processes) as executor:
            results = list(executor.map(self._compute_single_jacobian, tasks))

        return results

    def _compute_single_jacobian(self, task):
        """
        Compute single Jacobian (used by parallel executor)
        """
        joint_angles, end_effector_link = task

        # Check cache first
        with self.cache_lock:
            cache_key = (tuple(np.round(joint_angles, decimals=3)), end_effector_link)
            if cache_key in self.cache:
                return self.cache[cache_key]

        # Compute Jacobian
        jacobian = self.jacobian_calc.compute_jacobian(joint_angles, end_effector_link)

        # Cache result
        with self.cache_lock:
            if len(self.cache) < 1000:  # Limit cache size
                self.cache[cache_key] = jacobian

        return jacobian

    def compute_whole_body_jacobian_parallel(self, joint_angles, end_effector_links):
        """
        Compute whole-body Jacobian by computing limb Jacobians in parallel
        """
        # Split computation across multiple end-effectors
        with ThreadPoolExecutor(max_workers=len(end_effector_links)) as executor:
            futures = {
                link: executor.submit(
                    self.jacobian_calc.compute_jacobian,
                    joint_angles,
                    link
                ) for link in end_effector_links
            }

            limb_jacobians = {link: future.result() for link, future in futures.items()}

        # Combine results into whole-body Jacobian
        return self.combine_limb_jacobians(limb_jacobians, joint_angles)

    def combine_limb_jacobians(self, limb_jacobians, joint_angles):
        """
        Combine individual limb Jacobians
        """
        total_task_dof = sum(jac.shape[0] for jac in limb_jacobians.values())
        total_joints = len(joint_angles)

        combined_jacobian = np.zeros((total_task_dof, total_joints))

        row_offset = 0
        for link, jac in limb_jacobians.items():
            combined_jacobian[row_offset:row_offset + jac.shape[0], :] = jac
            row_offset += jac.shape[0]

        return combined_jacobian
```

## Conclusion

The practical implementation of Jacobian and differential kinematics for humanoid robots requires careful attention to computational efficiency, numerical stability, and real-time performance. The implementations provided in this section demonstrate various approaches to computing Jacobians, solving differential kinematics problems, and handling singularities in real-world systems.

Key considerations for practical implementation include caching for performance optimization, singularity detection and handling for safety, and integration with real-time control systems. The multi-limb and balance integration examples show how differential kinematics can be extended to support complex humanoid behaviors including coordinated multi-limb motion and dynamic balance control.

Successful implementation requires extensive testing and validation, including comparison with numerical differentiation methods and integration testing with simulation or real hardware. Performance optimization techniques such as parallel processing and caching can significantly improve computational efficiency, enabling real-time control of complex humanoid robots.