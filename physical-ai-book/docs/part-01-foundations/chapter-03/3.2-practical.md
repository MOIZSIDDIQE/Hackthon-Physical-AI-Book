---
title: 3.2 ROS2 and Gazebo in Practice - Real Examples
sidebar_position: 8
---

# 3.2 ROS2 and Gazebo in Practice - Real Examples

## Learning Objectives
- Implement practical ROS2 nodes for robot control and simulation
- Create and configure Gazebo models and worlds for humanoid robots
- Integrate ROS2 and Gazebo for complete robotic systems
- Debug and troubleshoot common ROS2-Gazebo integration issues
- Apply best practices for simulation-based robot development

## Introduction

This section provides hands-on practical examples of implementing ROS2 and Gazebo systems for humanoid robotics. Through concrete examples, we'll demonstrate how to create, configure, and integrate these tools to build functional robotic systems. The examples will cover everything from basic node creation to complex humanoid robot simulation.

## Practical Example 1: Creating a Simple Robot Model

### URDF Robot Definition

Let's create a simple wheeled robot model that we can later extend for humanoid applications:

```xml
<!-- simple_robot.urdf -->
<?xml version="1.0"?>
<robot name="simple_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">
  <!-- Base link -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.5 0.3 0.15"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 1 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="0.5 0.3 0.15"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="2.0"/>
      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>
    </inertial>
  </link>

  <!-- Left wheel -->
  <link name="left_wheel">
    <visual>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
      <material name="black">
        <color rgba="0 0 0 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.2"/>
      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
    </inertial>
  </link>

  <!-- Right wheel -->
  <link name="right_wheel">
    <visual>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
      <material name="black">
        <color rgba="0 0 0 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.2"/>
      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
    </inertial>
  </link>

  <!-- Joints -->
  <joint name="left_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="left_wheel"/>
    <origin xyz="0 0.2 -0.075" rpy="1.5708 0 0"/>
    <axis xyz="0 0 1"/>
  </joint>

  <joint name="right_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="right_wheel"/>
    <origin xyz="0 -0.2 -0.075" rpy="1.5708 0 0"/>
    <axis xyz="0 0 1"/>
  </joint>

  <!-- Gazebo plugins -->
  <gazebo reference="base_link">
    <material>Gazebo/Blue</material>
  </gazebo>

  <gazebo reference="left_wheel">
    <material>Gazebo/Black</material>
    <mu1>1.0</mu1>
    <mu2>1.0</mu2>
    <kp>1000000.0</kp>
    <kd>100.0</kd>
  </gazebo>

  <gazebo reference="right_wheel">
    <material>Gazebo/Black</material>
    <mu1>1.0</mu1>
    <mu2>1.0</mu2>
    <kp>1000000.0</kp>
    <kd>100.0</kd>
  </gazebo>
</robot>
```

### Robot State Publisher Node

```python
#!/usr/bin/env python3
# robot_state_publisher.py

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from geometry_msgs.msg import TransformStamped
from tf2_ros import TransformBroadcaster
import math

class RobotStatePublisher(Node):
    def __init__(self):
        super().__init__('robot_state_publisher')

        # Create publisher for joint states
        self.joint_publisher = self.create_publisher(JointState, 'joint_states', 10)

        # Create transform broadcaster for TF
        self.tf_broadcaster = TransformBroadcaster(self)

        # Timer for publishing
        self.timer = self.create_timer(0.1, self.publish_states)

        # Joint positions (for this example, static)
        self.joint_positions = {
            'left_wheel_joint': 0.0,
            'right_wheel_joint': 0.0
        }

    def publish_states(self):
        # Create joint state message
        msg = JointState()
        msg.name = list(self.joint_positions.keys())
        msg.position = list(self.joint_positions.values())
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'base_link'

        # Publish joint states
        self.joint_publisher.publish(msg)

        # Broadcast transforms
        self.broadcast_transforms()

    def broadcast_transforms(self):
        # Broadcast base_link to left_wheel transform
        t = TransformStamped()
        t.header.stamp = self.get_clock().now().to_msg()
        t.header.frame_id = 'base_link'
        t.child_frame_id = 'left_wheel'
        t.transform.translation.x = 0.0
        t.transform.translation.y = 0.2
        t.transform.translation.z = -0.075
        t.transform.rotation.x = 0.0
        t.transform.rotation.y = 0.0
        t.transform.rotation.z = 0.0
        t.transform.rotation.w = 1.0
        self.tf_broadcaster.sendTransform(t)

        # Broadcast base_link to right_wheel transform
        t = TransformStamped()
        t.header.stamp = self.get_clock().now().to_msg()
        t.header.frame_id = 'base_link'
        t.child_frame_id = 'right_wheel'
        t.transform.translation.x = 0.0
        t.transform.translation.y = -0.2
        t.transform.translation.z = -0.075
        t.transform.rotation.x = 0.0
        t.transform.rotation.y = 0.0
        t.transform.rotation.z = 0.0
        t.transform.rotation.w = 1.0
        self.tf_broadcaster.sendTransform(t)

def main(args=None):
    rclpy.init(args=args)
    node = RobotStatePublisher()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Practical Example 2: Differential Drive Controller

### ROS2 Controller Node

```python
#!/usr/bin/env python3
# differential_drive_controller.py

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from std_msgs.msg import Float64MultiArray
import math

class DifferentialDriveController(Node):
    def __init__(self):
        super().__init__('differential_drive_controller')

        # Subscribe to velocity commands
        self.cmd_vel_sub = self.create_subscription(
            Twist, 'cmd_vel', self.cmd_vel_callback, 10)

        # Publish to wheel joints (using Float64MultiArray for joint trajectory controller)
        self.wheel_cmd_pub = self.create_publisher(Float64MultiArray, '/joint_commands', 10)

        # Robot parameters
        self.wheel_radius = 0.1  # meters
        self.wheel_separation = 0.4  # meters (distance between wheels)
        self.max_wheel_speed = 5.0  # rad/s

        # Current velocity commands
        self.linear_vel = 0.0
        self.angular_vel = 0.0

        # Timer for control loop
        self.control_timer = self.create_timer(0.02, self.control_loop)  # 50 Hz

    def cmd_vel_callback(self, msg):
        """Handle velocity commands"""
        self.linear_vel = msg.linear.x
        self.angular_vel = msg.angular.z

    def control_loop(self):
        """Calculate wheel velocities and publish commands"""
        # Calculate wheel velocities for differential drive
        # v_left = (v - w * L/2) / r
        # v_right = (v + w * L/2) / r
        # where v = linear velocity, w = angular velocity, L = wheel separation, r = wheel radius

        left_wheel_vel = (self.linear_vel - self.angular_vel * self.wheel_separation / 2.0) / self.wheel_radius
        right_wheel_vel = (self.linear_vel + self.angular_vel * self.wheel_separation / 2.0) / self.wheel_radius

        # Limit wheel velocities
        left_wheel_vel = max(min(left_wheel_vel, self.max_wheel_speed), -self.max_wheel_speed)
        right_wheel_vel = max(min(right_wheel_vel, self.max_wheel_speed), -self.max_wheel_speed)

        # Create and publish command message
        cmd_msg = Float64MultiArray()
        cmd_msg.data = [left_wheel_vel, right_wheel_vel]

        # Publish command
        self.wheel_cmd_pub.publish(cmd_msg)

        self.get_logger().debug(f'Left: {left_wheel_vel:.2f}, Right: {right_wheel_vel:.2f}')

def main(args=None):
    rclpy.init(args=args)
    controller = DifferentialDriveController()

    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        pass
    finally:
        controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Practical Example 3: Gazebo Integration

### Launch File for Simulation

```python
# launch/simple_robot.launch.py

from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    # Launch configuration
    use_sim_time = LaunchConfiguration('use_sim_time', default='true')

    # Launch Gazebo
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([
                FindPackageShare('gazebo_ros'),
                'launch',
                'gazebo.launch.py'
            ])
        ]),
    )

    # Spawn robot in Gazebo
    spawn_entity = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-topic', 'robot_description',
            '-entity', 'simple_robot',
            '-x', '0', '-y', '0', '-z', '0.1'
        ],
        output='screen'
    )

    # Robot State Publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{'use_sim_time': use_sim_time}],
        remappings=[
            ('/joint_states', 'joint_states'),
        ]
    )

    # Joint State Publisher (GUI for testing)
    joint_state_publisher = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        parameters=[{'use_sim_time': use_sim_time}],
    )

    # Our custom nodes
    robot_controller = Node(
        package='simple_robot',
        executable='differential_drive_controller',
        parameters=[{'use_sim_time': use_sim_time}],
    )

    return LaunchDescription([
        DeclareLaunchArgument(
            'use_sim_time',
            default_value='true',
            description='Use simulation (Gazebo) clock if true'
        ),
        gazebo,
        spawn_entity,
        robot_state_publisher,
        joint_state_publisher,
        robot_controller,
    ])
```

## Practical Example 4: Humanoid Robot Model

Now let's create a more complex humanoid robot model:

```xml
<!-- humanoid_robot.urdf -->
<?xml version="1.0"?>
<robot name="humanoid_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">
  <!-- Materials -->
  <material name="white">
    <color rgba="1 1 1 1"/>
  </material>
  <material name="blue">
    <color rgba="0 0 1 1"/>
  </material>
  <material name="black">
    <color rgba="0 0 0 1"/>
  </material>

  <!-- Base link (torso) -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.2 0.2 0.5"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <geometry>
        <box size="0.2 0.2 0.5"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="5.0"/>
      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>
    </inertial>
  </link>

  <!-- Head -->
  <link name="head">
    <visual>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.002" ixy="0" ixz="0" iyy="0.002" iyz="0" izz="0.002"/>
    </inertial>
  </link>

  <joint name="neck_joint" type="revolute">
    <parent link="base_link"/>
    <child link="head"/>
    <origin xyz="0 0 0.35" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-0.5" upper="0.5" effort="10" velocity="1"/>
  </joint>

  <!-- Left Arm -->
  <link name="left_shoulder">
    <visual>
      <geometry>
        <box size="0.1 0.1 0.1"/>
      </geometry>
      <material name="blue"/>
    </visual>
    <collision>
      <geometry>
        <box size="0.1 0.1 0.1"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.5"/>
      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
    </inertial>
  </link>

  <joint name="left_shoulder_joint" type="revolute">
    <parent link="base_link"/>
    <child link="left_shoulder"/>
    <origin xyz="0.15 0.1 0.1" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-1.57" upper="1.57" effort="10" velocity="1"/>
  </joint>

  <link name="left_arm">
    <visual>
      <geometry>
        <cylinder length="0.3" radius="0.03"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <geometry>
        <cylinder length="0.3" radius="0.03"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.5"/>
      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
    </inertial>
  </link>

  <joint name="left_elbow_joint" type="revolute">
    <parent link="left_shoulder"/>
    <child link="left_arm"/>
    <origin xyz="0 0 -0.15" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <limit lower="-1.57" upper="1.57" effort="10" velocity="1"/>
  </joint>

  <!-- Gazebo plugins -->
  <gazebo reference="base_link">
    <material>Gazebo/White</material>
  </gazebo>

  <gazebo reference="head">
    <material>Gazebo/White</material>
  </gazebo>

  <gazebo reference="left_shoulder">
    <material>Gazebo/Blue</material>
  </gazebo>

  <gazebo reference="left_arm">
    <material>Gazebo/White</material>
  </gazebo>

  <!-- Transmission for ROS2 Control -->
  <transmission name="left_shoulder_trans">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="left_shoulder_joint">
      <hardwareInterface>position_controllers/JointPositionController</hardwareInterface>
    </joint>
    <actuator name="left_shoulder_motor">
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>

  <transmission name="left_elbow_trans">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="left_elbow_joint">
      <hardwareInterface>position_controllers/JointPositionController</hardwareInterface>
    </joint>
    <actuator name="left_elbow_motor">
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>
</robot>
```

## Practical Example 5: Humanoid Control Node

```python
#!/usr/bin/env python3
# humanoid_controller.py

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from builtin_interfaces.msg import Duration
import math
import time

class HumanoidController(Node):
    def __init__(self):
        super().__init__('humanoid_controller')

        # Publisher for joint trajectory commands
        self.trajectory_pub = self.create_publisher(
            JointTrajectory, '/joint_trajectory', 10)

        # Subscriber for current joint states
        self.joint_state_sub = self.create_subscription(
            JointState, 'joint_states', self.joint_state_callback, 10)

        # Timer for periodic control
        self.control_timer = self.create_timer(1.0, self.execute_demo_movement)

        self.current_joint_positions = {}
        self.joint_names = ['left_shoulder_joint', 'left_elbow_joint']

    def joint_state_callback(self, msg):
        """Update current joint positions"""
        for i, name in enumerate(msg.name):
            if name in self.joint_names:
                self.current_joint_positions[name] = msg.position[i]

    def execute_demo_movement(self):
        """Execute a simple demo movement"""
        trajectory_msg = JointTrajectory()
        trajectory_msg.joint_names = self.joint_names

        # Create trajectory points
        point1 = JointTrajectoryPoint()
        point1.positions = [0.0, 0.0]  # Home position
        point1.time_from_start = Duration(sec=1, nanosec=0)

        point2 = JointTrajectoryPoint()
        point2.positions = [0.5, -0.3]  # Raised arm position
        point2.time_from_start = Duration(sec=2, nanosec=0)

        point3 = JointTrajectoryPoint()
        point3.positions = [0.0, 0.0]  # Return to home
        point3.time_from_start = Duration(sec=3, nanosec=0)

        trajectory_msg.points = [point1, point2, point3]

        # Publish trajectory
        self.trajectory_pub.publish(trajectory_msg)
        self.get_logger().info('Published trajectory command')

def main(args=None):
    rclpy.init(args=args)
    controller = HumanoidController()

    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        pass
    finally:
        controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Practical Example 6: Advanced Gazebo Configuration

### World File with Complex Environment

```xml
<!-- complex_world.world -->
<?xml version="1.0" ?>
<sdf version="1.6">
  <world name="complex_world">
    <!-- Physics parameters -->
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
    </physics>

    <!-- Include standard models -->
    <include>
      <uri>model://ground_plane</uri>
    </include>
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Add obstacles -->
    <model name="table1">
      <pose>2 0 0 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>1.0 0.8 0.8</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>1.0 0.8 0.8</size>
            </box>
          </geometry>
          <material>
            <ambient>0.8 0.6 0.4 1</ambient>
            <diffuse>0.8 0.6 0.4 1</diffuse>
          </material>
        </visual>
      </link>
    </model>

    <!-- Add objects for manipulation -->
    <model name="object1">
      <pose>2.2 0.1 0.5 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.1 0.1 0.1</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.1 0.1 0.1</size>
            </box>
          </geometry>
          <material>
            <ambient>1 0 0 1</ambient>
            <diffuse>1 0 0 1</diffuse>
          </material>
        </visual>
      </link>
    </model>

    <!-- Add lighting -->
    <light name="room_light" type="point">
      <pose>0 0 3 0 0 0</pose>
      <diffuse>1 1 1 1</diffuse>
      <specular>0.5 0.5 0.5 1</specular>
      <attenuation>
        <range>10</range>
        <linear>0.1</linear>
        <quadratic>0.01</quadratic>
      </attenuation>
    </light>
  </world>
</sdf>
```

## Debugging and Troubleshooting

### Common Issues and Solutions

#### 1. TF Tree Issues
```python
# Check TF tree
import subprocess

def check_tf_tree():
    try:
        result = subprocess.run(['ros2', 'run', 'tf2_tools', 'view_frames'],
                              capture_output=True, text=True)
        print(result.stdout)
    except Exception as e:
        print(f"Error checking TF tree: {e}")
```

#### 2. Topic Connection Issues
```python
# Verify topic connections
def check_topic_connection(topic_name):
    import subprocess
    try:
        # Check if topic exists
        result = subprocess.run(['ros2', 'topic', 'list'],
                              capture_output=True, text=True)
        if topic_name in result.stdout:
            print(f"Topic {topic_name} exists")

            # Check topic info
            info_result = subprocess.run(['ros2', 'topic', 'info', topic_name],
                                       capture_output=True, text=True)
            print(info_result.stdout)
        else:
            print(f"Topic {topic_name} does not exist")
    except Exception as e:
        print(f"Error checking topic: {e}")
```

#### 3. Gazebo Model Loading Issues
```bash
# Check if model is properly loaded
gz model -m simple_robot

# Check simulation status
gz info
```

## Performance Optimization

### 1. Efficient Node Design
```python
class OptimizedController(Node):
    def __init__(self):
        super().__init__('optimized_controller')

        # Use appropriate QoS profiles
        from rclpy.qos import QoSProfile, QoSDurabilityPolicy

        qos_profile = QoSProfile(
            depth=1,  # Minimal queue depth for real-time
            durability=QoSDurabilityPolicy.VOLATILE
        )

        # Publisher with optimized QoS
        self.cmd_pub = self.create_publisher(
            Twist, 'cmd_vel', qos_profile)

        # Timer with appropriate frequency
        self.timer = self.create_timer(0.02, self.control_loop)  # 50 Hz

    def control_loop(self):
        # Minimize computation in callback
        # Process data efficiently
        pass
```

### 2. Simulation Optimization
```xml
<!-- Optimized Gazebo configuration -->
<physics type="ode">
  <max_step_size>0.01</max_step_size>  <!-- Larger for performance -->
  <real_time_factor>1.0</real_time_factor>
  <real_time_update_rate>100</real_time_update_rate>  <!-- Lower for performance -->
</physics>
```

## Integration Patterns

### Pattern 1: Modular Architecture
```python
class ModularRobotSystem:
    def __init__(self, node):
        self.node = node
        self.perception = PerceptionModule(node)
        self.planning = PlanningModule(node)
        self.control = ControlModule(node)
        self.safety = SafetyModule(node)

    def run_cycle(self):
        # Perception
        sensor_data = self.perception.get_data()

        # Safety check
        if self.safety.is_safe(sensor_data):
            # Planning
            plan = self.planning.create_plan(sensor_data)

            # Control execution
            commands = self.control.execute_plan(plan)
        else:
            # Emergency stop
            commands = self.safety.emergency_stop()

        return commands
```

### Pattern 2: Parameter-Based Configuration
```python
class ConfigurableRobotController(Node):
    def __init__(self):
        super().__init__('configurable_controller')

        # Declare parameters
        self.declare_parameter('robot_type', 'differential_drive')
        self.declare_parameter('max_linear_vel', 1.0)
        self.declare_parameter('max_angular_vel', 1.0)

        # Use parameters
        self.robot_type = self.get_parameter('robot_type').value
        self.max_linear = self.get_parameter('max_linear_vel').value
        self.max_angular = self.get_parameter('max_angular_vel').value
```

## Summary

This practical section has demonstrated the implementation of ROS2 and Gazebo systems for robotics applications. We've covered:

- Creating robot models in URDF format
- Implementing ROS2 nodes for control and simulation
- Integrating Gazebo for realistic simulation
- Building complex humanoid robot models
- Debugging common integration issues
- Optimizing performance for real-time operation

The examples provide a foundation for developing more sophisticated robotic systems using the ROS2-Gazebo ecosystem. The modular approach and best practices demonstrated here can be extended to more complex humanoid robotics applications.

## Exercises

1. **Implementation Exercise**: Create a simple robot model with 3-4 joints and implement a controller that makes it follow a square path in Gazebo.

2. **Extension Exercise**: Extend the humanoid model to include a complete arm with 6 DOF and implement inverse kinematics for reaching positions.

3. **Integration Exercise**: Create a complete launch file that starts Gazebo with a complex environment and multiple robot controllers.

4. **Optimization Exercise**: Profile the performance of your robot controller and implement optimizations to achieve 100Hz control loop.