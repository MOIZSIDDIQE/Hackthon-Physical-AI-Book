---
title: 2.2 Biomechanics in Practice - Movement Analysis and Applications
sidebar_position: 14
---

# 2.2 Biomechanics in Practice - Movement Analysis and Applications

## Learning Objectives
- Apply biomechanical analysis techniques to human movement data
- Implement practical movement analysis for robotic applications
- Analyze real-world movement data for robot control applications
- Evaluate movement efficiency and identify optimization opportunities
- Implement biomechanical principles in robotic movement control

## Introduction

This section bridges the gap between biomechanical theory and practical implementation in robotics. We'll explore how to collect, analyze, and apply human movement data to create more natural and efficient robotic movements. Through practical examples and implementation techniques, we'll demonstrate how biomechanical principles translate into functional robot behaviors.

## Movement Data Collection and Analysis

### Motion Capture Implementation

#### Optical Motion Capture Setup
```python
import numpy as np
from scipy.spatial.transform import Rotation as R
import matplotlib.pyplot as plt

class MotionCaptureAnalyzer:
    def __init__(self, marker_config):
        """
        Initialize motion capture analyzer with marker configuration
        marker_config: dictionary with marker names and body segment assignments
        """
        self.marker_config = marker_config
        self.marker_positions = {}
        self.segment_lengths = self.calculate_segment_lengths()
        self.joint_angles = {}

    def calculate_segment_lengths(self):
        """Calculate anthropometric segment lengths from marker positions"""
        # Typical human segment proportions
        segment_ratios = {
            'upper_arm': 0.186,  # 18.6% of height
            'forearm': 0.146,    # 14.6% of height
            'thigh': 0.243,      # 24.3% of height
            'shin': 0.245,       # 24.5% of height
            'trunk': 0.292       # 29.2% of height
        }

        # Estimate height from marker positions
        height_estimate = self.estimate_height()

        segment_lengths = {}
        for segment, ratio in segment_ratios.items():
            segment_lengths[segment] = height_estimate * ratio

        return segment_lengths

    def estimate_height(self):
        """Estimate subject height from marker positions"""
        # Estimate height as distance from head marker to foot markers
        # This is a simplified approach - real systems use multiple methods
        if 'head_top' in self.marker_positions and 'left_foot' in self.marker_positions:
            head_pos = self.marker_positions['head_top']
            foot_pos = self.marker_positions['left_foot']
            height = abs(head_pos[2] - foot_pos[2])  # Z-axis is typically vertical
            return height
        else:
            # Default height if markers not available
            return 1.7  # meters

    def calculate_joint_angles(self, frame_data):
        """Calculate joint angles from marker positions in a single frame"""
        angles = {}

        # Calculate shoulder angles
        if all(marker in frame_data for marker in ['left_shoulder', 'left_elbow', 'left_wrist']):
            shoulder_angle = self.calculate_shoulder_angles(
                frame_data['left_shoulder'],
                frame_data['left_elbow'],
                frame_data['left_wrist']
            )
            angles['left_shoulder'] = shoulder_angle

        # Calculate hip angles
        if all(marker in frame_data for marker in ['left_hip', 'left_knee', 'left_ankle']):
            hip_angle = self.calculate_hip_angles(
                frame_data['left_hip'],
                frame_data['left_knee'],
                frame_data['left_ankle']
            )
            angles['left_hip'] = hip_angle

        return angles

    def calculate_shoulder_angles(self, shoulder_pos, elbow_pos, wrist_pos):
        """Calculate shoulder joint angles using anatomical coordinate systems"""
        # Define anatomical axes based on marker positions
        upper_arm_vector = elbow_pos - shoulder_pos
        forearm_vector = wrist_pos - elbow_pos

        # Normalize vectors
        upper_arm_unit = upper_arm_vector / np.linalg.norm(upper_arm_vector)
        forearm_unit = forearm_vector / np.linalg.norm(forearm_vector)

        # Calculate angles
        flexion_abduction = np.arccos(np.clip(np.dot(upper_arm_unit, forearm_unit), -1.0, 1.0))

        return {
            'flexion_abduction': np.degrees(flexion_abduction),
            'internal_external_rotation': 0.0,  # Simplified calculation
            'horizontal_adduction_abduction': 0.0
        }

    def calculate_hip_angles(self, hip_pos, knee_pos, ankle_pos):
        """Calculate hip joint angles"""
        # Define anatomical axes
        thigh_vector = knee_pos - hip_pos
        shank_vector = ankle_pos - knee_pos

        # Normalize vectors
        thigh_unit = thigh_vector / np.linalg.norm(thigh_vector)
        shank_unit = shank_vector / np.linalg.norm(shank_vector)

        # Calculate hip flexion/extension
        flexion_angle = np.arccos(np.clip(np.dot(thigh_unit, shank_unit), -1.0, 1.0))

        return {
            'flexion_extension': np.degrees(flexion_angle),
            'abduction_adduction': 0.0,
            'internal_external_rotation': 0.0
        }

    def analyze_gait_cycle(self, motion_data):
        """Analyze walking gait cycle from motion capture data"""
        gait_analysis = {
            'stride_length': [],
            'step_width': [],
            'cadence': [],
            'walking_speed': [],
            'joint_angles': {}
        }

        # Analyze each step in the motion data
        for i in range(len(motion_data)):
            frame = motion_data[i]
            angles = self.calculate_joint_angles(frame)

            # Store joint angles
            for joint, angle_data in angles.items():
                if joint not in gait_analysis['joint_angles']:
                    gait_analysis['joint_angles'][joint] = []
                gait_analysis['joint_angles'][joint].append(angle_data)

        # Calculate gait parameters
        gait_analysis['stride_length'] = self.calculate_stride_length(motion_data)
        gait_analysis['step_width'] = self.calculate_step_width(motion_data)
        gait_analysis['cadence'] = self.calculate_cadence(motion_data)
        gait_analysis['walking_speed'] = self.calculate_walking_speed(motion_data)

        return gait_analysis

    def calculate_stride_length(self, motion_data):
        """Calculate stride length from heel marker positions"""
        stride_lengths = []

        for frame in motion_data:
            if 'left_heel' in frame and 'right_heel' in frame:
                left_heel = frame['left_heel']
                right_heel = frame['right_heel']
                stride_length = np.linalg.norm(left_heel - right_heel)
                stride_lengths.append(stride_length)

        return stride_lengths

    def calculate_cadence(self, motion_data, frame_rate=60):
        """Calculate walking cadence (steps per minute)"""
        # Simplified calculation - in practice, use heel strike detection
        if len(motion_data) > 0:
            total_time = len(motion_data) / frame_rate  # seconds
            # Estimate steps based on gait cycle analysis
            estimated_steps = len(motion_data) / 30  # Rough estimate
            cadence = (estimated_steps / total_time) * 60  # steps per minute
            return [cadence] * len(motion_data)
        return []

# Example usage
def analyze_human_movement():
    """Example of analyzing human movement data"""
    # Define marker configuration
    marker_config = {
        'head_top': 'head',
        'left_shoulder': 'left_arm',
        'left_elbow': 'left_arm',
        'left_wrist': 'left_arm',
        'left_hip': 'left_leg',
        'left_knee': 'left_leg',
        'left_ankle': 'left_leg',
        'left_heel': 'left_leg',
        'left_toe': 'left_leg'
    }

    analyzer = MotionCaptureAnalyzer(marker_config)

    # Simulate some motion data (in practice, this comes from motion capture)
    # This is a simplified example with synthetic data
    motion_data = []
    for i in range(100):
        frame = {
            'left_shoulder': np.array([0.2, 0.1, 1.6]),
            'left_elbow': np.array([0.3, 0.0, 1.4]),
            'left_wrist': np.array([0.4, -0.1, 1.2]),
            'left_hip': np.array([0.0, 0.0, 1.0]),
            'left_knee': np.array([0.0, 0.0, 0.6]),
            'left_ankle': np.array([0.0, 0.0, 0.1]),
            'left_heel': np.array([0.0, 0.0, 0.0]),
            'left_toe': np.array([0.1, 0.0, 0.0])
        }
        # Add some variation to simulate movement
        frame['left_elbow'][0] += 0.1 * np.sin(i * 0.1)
        frame['left_wrist'][0] += 0.2 * np.sin(i * 0.1)
        motion_data.append(frame)

    # Analyze the movement
    gait_analysis = analyzer.analyze_gait_cycle(motion_data)

    return gait_analysis
```

### Inertial Measurement Unit (IMU) Analysis

```python
class IMUAnalyzer:
    def __init__(self, sampling_rate=100):
        self.sampling_rate = sampling_rate
        self.acceleration_data = []
        self.angular_velocity_data = []
        self.orientation_data = []
        self.gravity_vector = np.array([0, 0, 9.81])  # m/s²

    def process_imu_data(self, accel, gyro, dt=0.01):
        """
        Process IMU data to extract movement information
        accel: [ax, ay, az] in m/s²
        gyro: [wx, wy, wz] in rad/s
        """
        # Convert to numpy arrays
        acceleration = np.array(accel)
        angular_velocity = np.array(gyro)

        # Estimate orientation using gyroscope integration
        if len(self.orientation_data) == 0:
            # Initialize with gravity-based orientation
            orientation = self.estimate_initial_orientation(acceleration)
        else:
            # Integrate angular velocity
            last_orientation = self.orientation_data[-1]
            orientation = self.integrate_gyroscope(last_orientation, angular_velocity, dt)

        # Store processed data
        self.acceleration_data.append(acceleration)
        self.angular_velocity_data.append(angular_velocity)
        self.orientation_data.append(orientation)

        return {
            'acceleration': acceleration,
            'angular_velocity': angular_velocity,
            'orientation': orientation,
            'linear_acceleration': self.extract_linear_acceleration(acceleration, orientation)
        }

    def estimate_initial_orientation(self, acceleration):
        """Estimate initial orientation from static acceleration"""
        # Gravity vector in sensor frame
        gravity_sensor = acceleration

        # Calculate roll and pitch from gravity
        pitch = np.arctan2(-gravity_sensor[0],
                          np.sqrt(gravity_sensor[1]**2 + gravity_sensor[2]**2))
        roll = np.arctan2(gravity_sensor[1], gravity_sensor[2])

        # Yaw cannot be determined from gravity alone
        yaw = 0.0

        return np.array([roll, pitch, yaw])

    def integrate_gyroscope(self, last_orientation, angular_velocity, dt):
        """Integrate gyroscope data to estimate orientation"""
        # Convert angular velocity to quaternion derivative
        # Simplified integration - in practice, use more sophisticated methods
        roll_rate, pitch_rate, yaw_rate = angular_velocity

        # Update orientation (Euler integration)
        new_orientation = last_orientation.copy()
        new_orientation[0] += roll_rate * dt
        new_orientation[1] += pitch_rate * dt
        new_orientation[2] += yaw_rate * dt

        return new_orientation

    def extract_linear_acceleration(self, acceleration, orientation):
        """Extract linear acceleration by removing gravity"""
        # Convert orientation to rotation matrix
        roll, pitch, yaw = orientation

        # Calculate rotation matrix
        cr, sr = np.cos(roll), np.sin(roll)
        cp, sp = np.cos(pitch), np.sin(pitch)
        cy, sy = np.cos(yaw), np.sin(yaw)

        # Rotation matrix from body to world frame
        R = np.array([
            [cp*cy, sr*sp*cy - cr*sy, cr*sp*cy + sr*sy],
            [cp*sy, sr*sp*sy + cr*cy, cr*sp*sy - sr*cy],
            [-sp, sr*cp, cr*cp]
        ])

        # Gravity in body frame
        gravity_body = R.T @ self.gravity_vector

        # Linear acceleration = measured - gravity
        linear_accel = acceleration - gravity_body

        return linear_accel

    def detect_gait_events(self):
        """Detect gait events (heel strike, toe off) from IMU data"""
        # Analyze vertical acceleration for gait events
        if len(self.acceleration_data) < 10:
            return []

        vertical_accel = [acc[2] for acc in self.acceleration_data]  # Z-axis is vertical

        # Detect peaks in vertical acceleration
        # Heel strike typically corresponds to impact peak
        heel_strikes = []
        for i in range(5, len(vertical_accel) - 5):
            if (vertical_accel[i] > vertical_accel[i-1] and
                vertical_accel[i] > vertical_accel[i+1] and
                vertical_accel[i] > 10):  # Threshold for impact
                heel_strikes.append(i)

        return heel_strikes
```

## Movement Pattern Extraction for Robotics

### Walking Pattern Analysis

```python
class WalkingPatternExtractor:
    def __init__(self):
        self.stance_phase = []
        self.swing_phase = []
        self.gait_cycle_duration = 1.0  # seconds
        self.nominal_joint_angles = {}
        self.pattern_library = {}

    def extract_walking_pattern(self, human_data):
        """Extract walking pattern from human motion data"""
        # Identify gait cycles
        gait_cycles = self.segment_gait_cycles(human_data)

        # Extract average pattern
        avg_pattern = self.calculate_average_pattern(gait_cycles)

        # Normalize to standard gait cycle
        normalized_pattern = self.normalize_to_gait_cycle(avg_pattern)

        return normalized_pattern

    def segment_gait_cycles(self, data):
        """Segment continuous walking data into individual gait cycles"""
        cycles = []

        # Detect heel strikes to segment cycles
        heel_strikes = self.detect_heel_strikes(data)

        # Create cycles between consecutive heel strikes
        for i in range(len(heel_strikes) - 1):
            start_idx = heel_strikes[i]
            end_idx = heel_strikes[i + 1]
            cycle_data = data[start_idx:end_idx]
            cycles.append(cycle_data)

        return cycles

    def detect_heel_strikes(self, data):
        """Detect heel strike events in walking data"""
        heel_strikes = []

        # For IMU data, heel strikes correspond to impact peaks
        # For motion capture, heel strikes correspond to heel position changes
        if 'heel_pos' in data[0]:
            # Motion capture data
            heel_positions = [frame['heel_pos'] for frame in data]
            heel_z = [pos[2] for pos in heel_positions]  # Vertical position

            # Detect minimum points (heel contact)
            for i in range(1, len(heel_z) - 1):
                if (heel_z[i] < heel_z[i-1] and
                    heel_z[i] < heel_z[i+1] and
                    heel_z[i] < 0.05):  # Close to ground
                    heel_strikes.append(i)
        else:
            # IMU data - detect impact peaks
            if hasattr(self, 'imu_analyzer'):
                heel_strikes = self.imu_analyzer.detect_gait_events()

        return heel_strikes

    def calculate_average_pattern(self, cycles):
        """Calculate average pattern across all cycles"""
        if not cycles:
            return {}

        # Determine the number of points to resample to
        target_points = 100  # Standard gait cycle representation

        # Resample each cycle to target points
        resampled_cycles = []
        for cycle in cycles:
            resampled = self.resample_cycle(cycle, target_points)
            resampled_cycles.append(resampled)

        # Calculate average across all cycles
        avg_pattern = {}
        for key in resampled_cycles[0].keys():
            avg_values = []
            for i in range(target_points):
                cycle_values = [cycle[key][i] for cycle in resampled_cycles]
                avg_values.append(np.mean(cycle_values))
            avg_pattern[key] = avg_values

        return avg_pattern

    def resample_cycle(self, cycle_data, target_points):
        """Resample a gait cycle to standard number of points"""
        resampled = {}

        for key, values in cycle_data.items():
            if isinstance(values, (list, np.ndarray)):
                # Interpolate to target number of points
                original_points = len(values)
                x_original = np.linspace(0, 1, original_points)
                x_target = np.linspace(0, 1, target_points)

                if len(values) > 1:
                    resampled_values = np.interp(x_target, x_original, values)
                else:
                    resampled_values = np.full(target_points, values[0])

                resampled[key] = resampled_values
            else:
                resampled[key] = values  # Single values remain unchanged

        return resampled

    def normalize_to_gait_cycle(self, pattern):
        """Normalize pattern to standard gait cycle phases"""
        normalized = {}

        # Define gait cycle phases (percentage of cycle)
        stance_phase_end = 60  # 60% of cycle is stance
        swing_phase_end = 100  # 40% of cycle is swing

        for joint, angles in pattern.items():
            normalized[joint] = {
                'stance': angles[:int(stance_phase_end)],
                'swing': angles[int(stance_phase_end):]
            }

        return normalized

    def generate_robot_trajectory(self, pattern, robot_config):
        """Generate robot joint trajectory from human pattern"""
        robot_trajectory = {}

        # Map human joints to robot joints
        joint_mapping = self.create_joint_mapping(robot_config)

        for human_joint, human_pattern in pattern.items():
            if human_joint in joint_mapping:
                robot_joint = joint_mapping[human_joint]
                robot_trajectory[robot_joint] = self.adapt_pattern(
                    human_pattern, robot_config[robot_joint]
                )

        return robot_trajectory

    def create_joint_mapping(self, robot_config):
        """Create mapping between human and robot joints"""
        mapping = {
            'hip_flexion': 'left_hip_pitch',
            'knee_flexion': 'left_knee_pitch',
            'ankle_flexion': 'left_ankle_pitch',
            'shoulder_flexion': 'left_shoulder_pitch',
            'elbow_flexion': 'left_elbow_pitch'
        }
        return mapping

    def adapt_pattern(self, human_pattern, robot_joint_limits):
        """Adapt human pattern to robot joint limits and capabilities"""
        adapted = []

        for value in human_pattern:
            # Scale to robot range
            scaled_value = self.scale_to_robot_range(
                value,
                human_range=(-90, 90),  # Example human range
                robot_range=robot_joint_limits
            )
            adapted.append(scaled_value)

        return adapted

    def scale_to_robot_range(self, value, human_range, robot_range):
        """Scale value from human range to robot range"""
        human_min, human_max = human_range
        robot_min, robot_max = robot_range

        # Normalize to [0, 1]
        normalized = (value - human_min) / (human_max - human_min)

        # Scale to robot range
        robot_value = robot_min + normalized * (robot_max - robot_min)

        # Clamp to robot limits
        robot_value = max(robot_min, min(robot_value, robot_max))

        return robot_value
```

## Practical Implementation Examples

### Humanoid Robot Walking Controller

```python
class HumanoidWalkingController:
    def __init__(self, robot_model):
        self.robot_model = robot_model
        self.pattern_extractor = WalkingPatternExtractor()
        self.balance_controller = BalanceController()
        self.trajectory_generator = TrajectoryGenerator()

        # Walking parameters
        self.step_length = 0.3  # meters
        self.step_width = 0.2  # meters
        self.step_height = 0.05  # meters (clearance)
        self.walking_speed = 0.5  # m/s
        self.nominal_com_height = 0.8  # meters

        # Timing parameters
        self.gait_cycle_time = 1.0  # seconds
        self.dsp_ratio = 0.2  # double support phase ratio
        self.tsp_ratio = 0.8  # single support phase ratio

    def generate_walking_trajectory(self, step_count, walking_direction='forward'):
        """Generate complete walking trajectory for specified steps"""
        trajectory = []

        for step in range(step_count):
            # Generate individual step trajectory
            step_trajectory = self.generate_single_step(walking_direction)

            # Apply to overall trajectory
            if step == 0:
                trajectory = step_trajectory
            else:
                # Concatenate with previous trajectory
                trajectory = self.concatenate_trajectories(trajectory, step_trajectory)

        return trajectory

    def generate_single_step(self, direction):
        """Generate trajectory for a single step"""
        # Calculate step parameters based on direction
        if direction == 'forward':
            step_x = self.step_length
            step_y = 0
        elif direction == 'backward':
            step_x = -self.step_length * 0.5
            step_y = 0
        elif direction == 'lateral':
            step_x = 0
            step_y = self.step_width
        else:
            step_x = self.step_length
            step_y = 0

        # Generate foot trajectory
        foot_trajectory = self.generate_foot_trajectory(step_x, step_y)

        # Generate CoM trajectory for balance
        com_trajectory = self.generate_com_trajectory(step_x, step_y)

        # Generate joint trajectories using inverse kinematics
        joint_trajectory = self.generate_joint_trajectory(foot_trajectory, com_trajectory)

        return {
            'foot_trajectory': foot_trajectory,
            'com_trajectory': com_trajectory,
            'joint_trajectory': joint_trajectory,
            'timing': self.calculate_timing_parameters()
        }

    def generate_foot_trajectory(self, step_x, step_y):
        """Generate foot trajectory for single step"""
        # Define key points in foot trajectory
        # Start: current foot position
        # Apex: highest point during swing
        # End: target foot position

        # Calculate trajectory points
        trajectory_points = []
        time_steps = 50  # Number of points in trajectory

        for i in range(time_steps):
            t = i / (time_steps - 1)  # Normalized time (0 to 1)

            # Calculate horizontal position (cubic interpolation)
            x = self.interpolate_cubic(0, 0, step_x, step_x, t)
            y = self.interpolate_cubic(0, 0, step_y, step_y, t)

            # Calculate vertical position (parabolic for smooth lift/lower)
            if t < 0.3:  # Initial lift
                z = self.interpolate_parabolic(0, self.step_height * 0.3, t / 0.3)
            elif t < 0.7:  # Apex
                z = self.step_height
            else:  # Lower to ground
                z = self.interpolate_parabolic(self.step_height, 0, (t - 0.7) / 0.3)

            trajectory_points.append(np.array([x, y, z]))

        return trajectory_points

    def interpolate_cubic(self, start, start_deriv, end, end_deriv, t):
        """Cubic interpolation for smooth trajectory"""
        t2 = t * t
        t3 = t2 * t

        # Hermite basis functions
        h00 = 2*t3 - 3*t2 + 1
        h10 = t3 - 2*t2 + t
        h01 = -2*t3 + 3*t2
        h11 = t3 - t2

        return h00*start + h10*start_deriv + h01*end + h11*end_deriv

    def interpolate_parabolic(self, start, end, t):
        """Parabolic interpolation for vertical movement"""
        return start + (end - start) * (1 - np.cos(np.pi * t)) / 2

    def generate_com_trajectory(self, step_x, step_y):
        """Generate Center of Mass trajectory for balance"""
        # Use inverted pendulum model for CoM trajectory
        # This ensures dynamic balance during walking

        trajectory_points = []
        time_steps = 50

        for i in range(time_steps):
            t = i / (time_steps - 1)

            # CoM should move smoothly to stay over support foot
            # Simplified model: CoM follows foot with some delay
            com_x = step_x * t * 0.8  # Slightly behind foot for stability
            com_y = step_y * t * 0.8
            com_z = self.nominal_com_height  # Maintain height

            # Add small oscillation to mimic natural walking
            oscillation = 0.01 * np.sin(2 * np.pi * t * 2)  # 2 Hz oscillation
            com_z += oscillation

            trajectory_points.append(np.array([com_x, com_y, com_z]))

        return trajectory_points

    def generate_joint_trajectory(self, foot_trajectory, com_trajectory):
        """Generate joint angle trajectories using inverse kinematics"""
        joint_trajectories = {}

        # For each time step, calculate joint angles
        for i in range(len(foot_trajectory)):
            foot_pos = foot_trajectory[i]
            com_pos = com_trajectory[i]

            # Calculate joint angles using inverse kinematics
            joint_angles = self.inverse_kinematics(foot_pos, com_pos)
            for joint, angle in joint_angles.items():
                if joint not in joint_trajectories:
                    joint_trajectories[joint] = []
                joint_trajectories[joint].append(angle)

        return joint_trajectories

    def inverse_kinematics(self, foot_position, com_position):
        """Calculate joint angles to achieve desired foot position"""
        # Simplified 2D inverse kinematics for leg
        # In practice, use full 3D IK solver

        # Extract 2D coordinates (sagittal plane)
        x = foot_position[0]  # Forward/backward
        z = foot_position[2]  # Up/down

        # Leg length (simplified)
        thigh_length = 0.4  # meters
        shin_length = 0.4  # meters

        # Calculate hip and knee angles
        # Distance from hip to foot
        distance = np.sqrt(x**2 + z**2)

        # Check if position is reachable
        if distance > thigh_length + shin_length:
            # Position too far, extend fully
            hip_angle = np.arctan2(z, x)
            knee_angle = 0
        elif distance < abs(thigh_length - shin_length):
            # Position too close, this shouldn't happen in normal walking
            hip_angle = np.arctan2(z, x)
            knee_angle = np.pi  # Fully bent
        else:
            # Use law of cosines to find angles
            cos_knee = (thigh_length**2 + shin_length**2 - distance**2) / (2 * thigh_length * shin_length)
            knee_angle = np.pi - np.arccos(np.clip(cos_knee, -1, 1))

            cos_hip = (thigh_length**2 + distance**2 - shin_length**2) / (2 * thigh_length * distance)
            alpha = np.arccos(np.clip(cos_hip, -1, 1))
            beta = np.arctan2(z, x)
            hip_angle = beta - alpha

        return {
            'hip_pitch': hip_angle,
            'knee_pitch': knee_angle,
            'ankle_pitch': 0.0  # Simplified
        }

    def execute_walking(self, trajectory):
        """Execute walking trajectory on robot"""
        # Send trajectory to robot controllers
        for i, point in enumerate(trajectory['joint_trajectory']['hip_pitch']):
            # Calculate current joint positions
            joint_commands = {}
            for joint, angles in trajectory['joint_trajectory'].items():
                if i < len(angles):
                    joint_commands[joint] = angles[i]

            # Send commands to robot
            self.send_joint_commands(joint_commands)

            # Wait for next time step
            self.wait_for_time_step()

    def send_joint_commands(self, commands):
        """Send joint position commands to robot"""
        # In practice, this would interface with robot's control system
        print(f"Sending joint commands: {commands}")

    def wait_for_time_step(self):
        """Wait for next control cycle"""
        import time
        time.sleep(0.02)  # 50 Hz control rate

class BalanceController:
    """Balance controller for humanoid robot"""

    def __init__(self):
        self.zmp_reference = np.array([0.0, 0.0])
        self.com_reference = np.array([0.0, 0.0, 0.8])
        self.com_current = np.array([0.0, 0.0, 0.8])
        self.com_error_int = np.array([0.0, 0.0, 0.0])
        self.com_error_deriv = np.array([0.0, 0.0, 0.0])

        # PID gains
        self.com_kp = np.array([10.0, 10.0, 10.0])
        self.com_ki = np.array([1.0, 1.0, 1.0])
        self.com_kd = np.array([5.0, 5.0, 5.0])

    def update_balance(self, sensor_data):
        """Update balance control based on sensor data"""
        # Get current CoM position from state estimator
        self.com_current = self.estimate_com_position(sensor_data)

        # Calculate error
        com_error = self.com_reference - self.com_current

        # Update integral and derivative terms
        self.com_error_int += com_error * 0.02  # dt = 0.02s
        com_error_deriv = (com_error - self.com_error_deriv) / 0.02

        # PID control
        com_control = (self.com_kp * com_error +
                      self.com_ki * self.com_error_int +
                      self.com_kd * com_error_deriv)

        # Generate balance correction commands
        balance_correction = self.generate_balance_correction(com_control)

        return balance_correction

    def estimate_com_position(self, sensor_data):
        """Estimate Center of Mass position from sensor data"""
        # Simplified estimation
        # In practice, use full state estimation with IMU, joint encoders, etc.
        return np.array([0.0, 0.0, 0.8])

    def generate_balance_correction(self, com_control):
        """Generate balance correction commands"""
        # Convert CoM control to joint commands
        # This involves whole-body control algorithms
        joint_corrections = {}

        # Example: map CoM control to hip and ankle adjustments
        joint_corrections['left_hip_roll'] = com_control[1] * 0.1  # Lateral CoM -> hip roll
        joint_corrections['right_hip_roll'] = -com_control[1] * 0.1
        joint_corrections['left_ankle_roll'] = -com_control[1] * 0.05
        joint_corrections['right_ankle_roll'] = com_control[1] * 0.05

        return joint_corrections

class TrajectoryGenerator:
    """Trajectory generation for humanoid robot movements"""

    def __init__(self):
        pass

    def generate_smooth_trajectory(self, start_pos, end_pos, duration, max_vel=None, max_acc=None):
        """Generate smooth trajectory between two points"""
        # Use trapezoidal velocity profile
        if max_vel is None:
            max_vel = 1.0  # rad/s
        if max_acc is None:
            max_acc = 2.0  # rad/s²

        # Calculate distance
        distance = abs(end_pos - start_pos)

        # Calculate time for acceleration phase
        accel_time = min(max_vel / max_acc, duration / 2)
        accel_dist = 0.5 * max_acc * accel_time**2

        if 2 * accel_dist > distance:
            # Triangle profile (no constant velocity phase)
            accel_time = np.sqrt(distance / max_acc)
            total_time = 2 * accel_time
        else:
            # Trapezoidal profile
            const_dist = distance - 2 * accel_dist
            const_time = const_dist / max_vel
            total_time = 2 * accel_time + const_time

        # Generate trajectory points
        trajectory = []
        time_steps = int(total_time / 0.01)  # 100 Hz

        for i in range(time_steps + 1):
            t = i * 0.01

            if t <= accel_time:
                # Acceleration phase
                pos = start_pos + 0.5 * max_acc * t**2 * np.sign(end_pos - start_pos)
            elif t <= accel_time + (total_time - 2*accel_time):
                # Constant velocity phase
                pos = (start_pos +
                      accel_dist * np.sign(end_pos - start_pos) +
                      max_vel * (t - accel_time) * np.sign(end_pos - start_pos))
            else:
                # Deceleration phase
                decel_t = t - (total_time - accel_time)
                pos = (end_pos -
                      0.5 * max_acc * (total_time - t)**2 * np.sign(end_pos - start_pos))

            trajectory.append(pos)

        return trajectory
```

## Movement Optimization Techniques

### Energy Efficiency Optimization

```python
class MovementOptimizer:
    def __init__(self):
        self.energy_model = self.create_energy_model()
        self.optimization_method = 'gradient_descent'  # or 'genetic_algorithm'

    def create_energy_model(self):
        """Create model for estimating movement energy consumption"""
        # Simplified energy model based on joint torques and velocities
        def energy_function(joint_trajectories, robot_params):
            total_energy = 0

            for joint_name, trajectory in joint_trajectories.items():
                # Calculate energy for each joint
                joint_energy = 0
                for i in range(1, len(trajectory)):
                    # Approximate torque from acceleration
                    velocity = (trajectory[i] - trajectory[i-1]) / 0.02  # dt = 0.02s
                    if i > 1:
                        acceleration = (velocity - (trajectory[i-1] - trajectory[i-2]) / 0.02) / 0.02
                        torque = robot_params[joint_name]['inertia'] * acceleration
                        power = abs(torque * velocity)
                        joint_energy += power * 0.02  # dt

                total_energy += joint_energy

            return total_energy

        return energy_function

    def optimize_movement(self, base_trajectory, constraints=None):
        """Optimize movement trajectory for energy efficiency"""
        if self.optimization_method == 'gradient_descent':
            return self.gradient_descent_optimization(base_trajectory, constraints)
        elif self.optimization_method == 'genetic_algorithm':
            return self.genetic_algorithm_optimization(base_trajectory, constraints)

    def gradient_descent_optimization(self, base_trajectory, constraints):
        """Optimize using gradient descent"""
        optimized_trajectory = base_trajectory.copy()
        learning_rate = 0.01
        max_iterations = 100

        for iteration in range(max_iterations):
            # Calculate current energy
            current_energy = self.energy_model(optimized_trajectory, self.get_robot_params())

            # Calculate gradients
            gradients = self.calculate_energy_gradients(optimized_trajectory)

            # Update trajectory
            for joint, grad in gradients.items():
                if joint in optimized_trajectory:
                    optimized_trajectory[joint] = [
                        pos - learning_rate * grad_val
                        for pos, grad_val in zip(optimized_trajectory[joint], grad)
                    ]

            # Apply constraints
            if constraints:
                optimized_trajectory = self.apply_constraints(optimized_trajectory, constraints)

            # Check for convergence
            new_energy = self.energy_model(optimized_trajectory, self.get_robot_params())
            if abs(new_energy - current_energy) < 1e-6:
                break

        return optimized_trajectory

    def calculate_energy_gradients(self, trajectory):
        """Calculate gradients of energy function"""
        gradients = {}

        for joint, positions in trajectory.items():
            grad = []
            for i in range(len(positions)):
                # Numerical differentiation
                h = 1e-6
                trajectory_plus = positions.copy()
                trajectory_plus[i] += h
                trajectory_minus = positions.copy()
                trajectory_minus[i] -= h

                # Calculate energy difference
                energy_plus = self.energy_model({joint: trajectory_plus}, self.get_robot_params())
                energy_minus = self.energy_model({joint: trajectory_minus}, self.get_robot_params())

                grad_val = (energy_plus - energy_minus) / (2 * h)
                grad.append(grad_val)

            gradients[joint] = grad

        return gradients

    def get_robot_params(self):
        """Get robot parameters for energy calculation"""
        return {
            'hip_pitch': {'inertia': 0.5},
            'knee_pitch': {'inertia': 0.3},
            'ankle_pitch': {'inertia': 0.1},
            'shoulder_pitch': {'inertia': 0.2}
        }

    def apply_constraints(self, trajectory, constraints):
        """Apply constraints to trajectory"""
        for joint, joint_traj in trajectory.items():
            if joint in constraints:
                # Apply joint limits
                limits = constraints[joint].get('limits', [-np.inf, np.inf])
                trajectory[joint] = [
                    max(limits[0], min(limits[1], pos))
                    for pos in joint_traj
                ]

        return trajectory
```

## Real-World Applications

### Rehabilitation Robotics

```python
class RehabilitationAnalyzer:
    def __init__(self):
        self.normal_pattern_db = self.load_normal_patterns()
        self.patient_data = {}
        self.progress_tracker = ProgressTracker()

    def load_normal_patterns(self):
        """Load normal movement patterns for comparison"""
        # In practice, this would load from a database of normal movement patterns
        return {
            'walking': {
                'stride_length': (0.6, 0.8),  # meters
                'step_width': (0.1, 0.3),     # meters
                'cadence': (90, 120),         # steps per minute
                'walking_speed': (1.0, 1.5)   # m/s
            },
            'reaching': {
                'reach_distance': (0.5, 0.8),  # meters
                'movement_time': (1.0, 2.0),   # seconds
                'smoothness': (0.8, 1.0)       # dimensionless
            }
        }

    def analyze_patient_movement(self, patient_id, movement_data):
        """Analyze patient movement and compare to normal patterns"""
        analysis = {
            'patient_id': patient_id,
            'movement_type': 'walking',  # or reaching, etc.
            'metrics': {},
            'deviation_score': 0.0,
            'rehabilitation_recommendations': []
        }

        # Calculate movement metrics
        metrics = self.calculate_movement_metrics(movement_data)
        analysis['metrics'] = metrics

        # Compare to normal patterns
        deviation_score = self.calculate_deviation_score(metrics)
        analysis['deviation_score'] = deviation_score

        # Generate recommendations
        recommendations = self.generate_recommendations(metrics, deviation_score)
        analysis['rehabilitation_recommendations'] = recommendations

        # Store patient data
        self.patient_data[patient_id] = analysis

        return analysis

    def calculate_movement_metrics(self, movement_data):
        """Calculate quantitative movement metrics"""
        metrics = {}

        # For walking data
        if 'stride_length' in movement_data:
            metrics['stride_length'] = np.mean(movement_data['stride_length'])
            metrics['stride_variability'] = np.std(movement_data['stride_length'])

        if 'step_width' in movement_data:
            metrics['step_width'] = np.mean(movement_data['step_width'])

        if 'cadence' in movement_data:
            metrics['cadence'] = np.mean(movement_data['cadence'])

        if 'walking_speed' in movement_data:
            metrics['walking_speed'] = np.mean(movement_data['walking_speed'])

        # Calculate smoothness metrics
        if 'joint_angles' in movement_data:
            metrics['movement_smoothness'] = self.calculate_smoothness(movement_data['joint_angles'])

        return metrics

    def calculate_smoothness(self, joint_angles):
        """Calculate movement smoothness (lower jerk)"""
        # Calculate jerk (third derivative) as measure of smoothness
        if len(joint_angles) < 3:
            return 1.0  # Perfectly smooth for insufficient data

        # Calculate velocity
        velocities = np.diff(joint_angles)

        # Calculate acceleration
        accelerations = np.diff(velocities)

        # Calculate jerk
        jerks = np.diff(accelerations)

        # Smoothness is inverse of mean absolute jerk
        mean_abs_jerk = np.mean(np.abs(jerks))
        smoothness = 1.0 / (1.0 + mean_abs_jerk)

        return min(smoothness, 1.0)  # Clamp to [0, 1]

    def calculate_deviation_score(self, metrics):
        """Calculate how much movement deviates from normal"""
        total_deviation = 0.0
        metric_count = 0

        for metric_name, value in metrics.items():
            if metric_name in self.normal_pattern_db['walking']:
                normal_range = self.normal_pattern_db['walking'][metric_name]

                # Calculate normalized deviation
                if normal_range[1] != normal_range[0]:  # Avoid division by zero
                    deviation = abs(value - (normal_range[0] + normal_range[1]) / 2)
                    range_width = normal_range[1] - normal_range[0]
                    normalized_deviation = deviation / range_width
                    total_deviation += normalized_deviation
                    metric_count += 1

        if metric_count > 0:
            return total_deviation / metric_count
        else:
            return 0.0

    def generate_recommendations(self, metrics, deviation_score):
        """Generate rehabilitation recommendations based on analysis"""
        recommendations = []

        if deviation_score > 0.5:
            recommendations.append("Significant deviation from normal movement patterns detected")
            recommendations.append("Focus on basic movement retraining")
        elif deviation_score > 0.2:
            recommendations.append("Moderate deviation from normal patterns")
            recommendations.append("Continue current rehabilitation program")
        else:
            recommendations.append("Movement patterns approaching normal range")
            recommendations.append("Consider advancing to more complex movements")

        # Specific recommendations based on metrics
        if 'walking_speed' in metrics:
            if metrics['walking_speed'] < 0.8:
                recommendations.append("Speed training: practice walking at faster pace")

        if 'stride_variability' in metrics:
            if metrics['stride_variability'] > 0.1:
                recommendations.append("Stability training: focus on consistent stride length")

        if 'movement_smoothness' in metrics:
            if metrics['movement_smoothness'] < 0.5:
                recommendations.append("Smoothness training: practice fluid movements")

        return recommendations

class ProgressTracker:
    """Track patient progress over time"""

    def __init__(self):
        self.patient_history = {}

    def record_session(self, patient_id, session_data):
        """Record a rehabilitation session"""
        if patient_id not in self.patient_history:
            self.patient_history[patient_id] = []

        self.patient_history[patient_id].append(session_data)

    def calculate_progress(self, patient_id):
        """Calculate progress over multiple sessions"""
        if patient_id not in self.patient_history:
            return {}

        history = self.patient_history[patient_id]

        if len(history) < 2:
            return {"message": "Insufficient data for progress calculation"}

        # Calculate trends
        deviation_scores = [session['deviation_score'] for session in history]
        trend = self.calculate_trend(deviation_scores)

        progress = {
            'initial_score': deviation_scores[0],
            'current_score': deviation_scores[-1],
            'improvement': deviation_scores[0] - deviation_scores[-1],
            'trend': trend,
            'session_count': len(history)
        }

        return progress

    def calculate_trend(self, values):
        """Calculate trend of improvement"""
        if len(values) < 2:
            return "insufficient_data"

        # Simple linear regression slope
        x = np.arange(len(values))
        slope = np.polyfit(x, values, 1)[0]

        if slope < -0.01:  # Improving (negative slope)
            return "improving"
        elif slope > 0.01:  # Deteriorating (positive slope)
            return "deteriorating"
        else:
            return "stable"
```

## Summary

This section has demonstrated practical applications of biomechanics in robotics, including:

- **Motion capture analysis**: Techniques for collecting and analyzing human movement data
- **Movement pattern extraction**: Methods for extracting and adapting human movement patterns for robots
- **Walking control implementation**: Practical controllers for humanoid robot locomotion
- **Optimization techniques**: Methods for improving movement efficiency
- **Real-world applications**: Rehabilitation robotics as an example application

The practical examples show how biomechanical principles translate into functional code that can be used to create more natural and efficient robotic movements. The implementations provided serve as foundations that can be extended and refined for specific applications.

## Exercises

1. **Implementation Exercise**: Create a motion capture data analyzer that can process real human walking data and extract key gait parameters.

2. **Optimization Exercise**: Implement an energy optimization algorithm for a simple 2-DOF arm movement and compare the results to the original trajectory.

3. **Control Exercise**: Design and implement a balance controller for a simulated humanoid robot that maintains stability during external disturbances.

4. **Analysis Exercise**: Create a system that can compare different human movement patterns and identify the most energy-efficient approach for a given task.