---
title: 8.3.2 Actuator Systems and Control Implementation
sidebar_position: 41
---

# 8.3.2 Actuator Systems and Control Implementation

## Learning Objectives

- Implement actuator control systems for humanoid robots
- Develop PID and advanced control algorithms for actuators
- Integrate actuator systems with real-time control frameworks
- Apply torque and impedance control techniques
- Validate actuator system performance in real-world scenarios

## Introduction

The practical implementation of actuator systems for humanoid robots requires careful attention to real-time performance, safety, and system integration. Unlike theoretical control models, practical implementations must handle timing constraints, noise, communication delays, and hardware limitations. This section provides detailed implementation strategies for actuator control systems that enable robust humanoid robot operation.

Real-world actuator implementation involves multiple challenges including precise position control, accurate force/torque regulation, safety in dynamic environments, and integration with higher-level control systems. The implementation approach must balance performance, reliability, and computational efficiency to meet the demanding requirements of humanoid robot applications.

Modern actuator system implementations leverage specialized hardware, optimized algorithms, and robust software architectures to achieve the performance required for dynamic humanoid operation. The integration of machine learning techniques with traditional control methods enables more sophisticated and adaptive actuator control while maintaining the reliability required for safe human-robot interaction.

## 2. Hardware Interface Implementation

### 2.1 Motor Controller Development

The motor controller provides the fundamental interface between the control software and the physical motor hardware.

```python
import threading
import time
import numpy as np
from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, List, Tuple, Optional
import serial
import can
from dataclasses import dataclass

class ControlMode(Enum):
    POSITION = "position"
    VELOCITY = "velocity"
    TORQUE = "torque"
    IMPEDANCE = "impedance"

@dataclass
class ActuatorState:
    """Current state of an actuator"""
    position: float = 0.0
    velocity: float = 0.0
    torque: float = 0.0
    temperature: float = 25.0
    current: float = 0.0
    voltage: float = 0.0
    timestamp: float = 0.0
    status_flags: int = 0

@dataclass
class ActuatorCommand:
    """Command sent to an actuator"""
    position: float = 0.0
    velocity: float = 0.0
    torque: float = 0.0
    kp: float = 0.0  # Stiffness for impedance control
    kd: float = 0.0  # Damping for impedance control
    control_mode: ControlMode = ControlMode.POSITION
    timestamp: float = 0.0

class MotorController(ABC):
    """Abstract base class for motor controllers"""

    def __init__(self, actuator_id: str, config: Dict):
        self.actuator_id = actuator_id
        self.config = config
        self.is_connected = False
        self.current_state = ActuatorState()
        self.command_buffer = []
        self.lock = threading.Lock()
        self.control_thread = None
        self.is_running = False

    @abstractmethod
    def connect(self) -> bool:
        """Establish connection to motor controller hardware"""
        pass

    @abstractmethod
    def send_command(self, command: ActuatorCommand) -> bool:
        """Send command to motor controller"""
        pass

    @abstractmethod
    def read_state(self) -> Optional[ActuatorState]:
        """Read current state from motor controller"""
        pass

    @abstractmethod
    def disconnect(self) -> bool:
        """Disconnect from motor controller hardware"""
        pass

class ServoController(MotorController):
    """Implementation for servo motor controllers"""

    def __init__(self, actuator_id: str, config: Dict):
        super().__init__(actuator_id, config)

        # PID controller parameters
        self.pid_params = {
            ControlMode.POSITION: {
                'kp': config.get('position_kp', 100.0),
                'ki': config.get('position_ki', 0.1),
                'kd': config.get('position_kd', 10.0)
            },
            ControlMode.VELOCITY: {
                'kp': config.get('velocity_kp', 10.0),
                'ki': config.get('velocity_ki', 0.01),
                'kd': config.get('velocity_kd', 1.0)
            },
            ControlMode.TORQUE: {
                'kp': config.get('torque_kp', 1.0),
                'ki': config.get('torque_ki', 0.0),
                'kd': config.get('torque_kd', 0.0)
            }
        }

        # Safety limits
        self.max_torque = config.get('max_torque', 100.0)  # Nm
        self.max_velocity = config.get('max_velocity', 10.0)  # rad/s
        self.max_position = config.get('max_position', np.pi * 2)  # rad
        self.max_current = config.get('max_current', 10.0)  # A

        # Communication interface
        self.interface_type = config.get('interface', 'serial')
        self.device_address = config.get('address', 0x01)

        # PID controllers
        self.pid_controllers = {}
        for mode in ControlMode:
            if mode in self.pid_params:
                self.pid_controllers[mode] = PIDController(
                    self.pid_params[mode]['kp'],
                    self.pid_params[mode]['ki'],
                    self.pid_params[mode]['kd']
                )

    def connect(self) -> bool:
        """Connect to servo controller via specified interface"""
        try:
            if self.interface_type == 'serial':
                self.serial_port = serial.Serial(
                    port=self.config['port'],
                    baudrate=self.config['baudrate'],
                    timeout=self.config.get('timeout', 1.0)
                )
            elif self.interface_type == 'can':
                self.can_bus = can.Bus(
                    channel=self.config['channel'],
                    bustype=self.config.get('bustype', 'socketcan'),
                    bitrate=self.config.get('bitrate', 500000)
                )
            elif self.interface_type == 'ethercat':
                # EtherCAT implementation would go here
                pass

            self.is_connected = True
            return True

        except Exception as e:
            print(f"Servo connection failed: {e}")
            return False

    def send_command(self, command: ActuatorCommand) -> bool:
        """Send command to servo controller"""
        if not self.is_connected:
            return False

        try:
            # Clamp command values to safety limits
            clamped_command = self._clamp_command(command)

            # Format command based on interface type
            if self.interface_type == 'serial':
                cmd_bytes = self._format_serial_command(clamped_command)
                self.serial_port.write(cmd_bytes)
            elif self.interface_type == 'can':
                msg = self._format_can_command(clamped_command)
                self.can_bus.send(msg)

            return True

        except Exception as e:
            print(f"Command send error: {e}")
            return False

    def read_state(self) -> Optional[ActuatorState]:
        """Read current state from servo controller"""
        if not self.is_connected:
            return None

        try:
            if self.interface_type == 'serial':
                # Read state packet from serial
                response = self.serial_port.read(32)  # Adjust size as needed
                state = self._parse_serial_response(response)
            elif self.interface_type == 'can':
                # Read state from CAN bus
                msg = self.can_bus.recv(timeout=0.1)
                if msg:
                    state = self._parse_can_response(msg)
                else:
                    return None

            # Update current state
            self.current_state = state
            return state

        except Exception as e:
            print(f"State read error: {e}")
            return ActuatorState(
                position=self.current_state.position,
                velocity=self.current_state.velocity,
                torque=self.current_state.torque,
                timestamp=time.time(),
                status_flags=0x01  # Error flag
            )

    def _clamp_command(self, command: ActuatorCommand) -> ActuatorCommand:
        """Clamp command values to safety limits"""
        clamped = ActuatorCommand()

        if command.control_mode == ControlMode.TORQUE:
            clamped.torque = np.clip(command.torque, -self.max_torque, self.max_torque)
        elif command.control_mode == ControlMode.VELOCITY:
            clamped.velocity = np.clip(command.velocity, -self.max_velocity, self.max_velocity)
        elif command.control_mode == ControlMode.POSITION:
            clamped.position = np.clip(command.position, -self.max_position, self.max_position)

        # Copy other fields
        clamped.control_mode = command.control_mode
        clamped.timestamp = command.timestamp

        return clamped

    def _format_serial_command(self, command: ActuatorCommand) -> bytes:
        """Format command for serial transmission"""
        # Example protocol: [START_BYTE, ID, LENGTH, INST, PARAMETER, CHECKSUM]
        instruction = 0x03  # Write command

        if command.control_mode == ControlMode.POSITION:
            # Position control command
            pos_bytes = int(command.position * 1000).to_bytes(4, byteorder='little', signed=True)
            cmd_bytes = [0xFF, 0xFF, self.device_address, 0x08, instruction, 0x00] + list(pos_bytes)
        elif command.control_mode == ControlMode.VELOCITY:
            # Velocity control command
            vel_bytes = int(command.velocity * 1000).to_bytes(4, byteorder='little', signed=True)
            cmd_bytes = [0xFF, 0xFF, self.device_address, 0x08, instruction, 0x01] + list(vel_bytes)
        elif command.control_mode == ControlMode.TORQUE:
            # Torque control command
            torque_bytes = int(command.torque * 1000).to_bytes(4, byteorder='little', signed=True)
            cmd_bytes = [0xFF, 0xFF, self.device_address, 0x08, instruction, 0x02] + list(torque_bytes)
        else:
            # Default to position control
            pos_bytes = int(command.position * 1000).to_bytes(4, byteorder='little', signed=True)
            cmd_bytes = [0xFF, 0xFF, self.device_address, 0x08, instruction, 0x00] + list(pos_bytes)

        # Calculate checksum
        checksum = 0xFF - (sum(cmd_bytes[2:]) & 0xFF)
        cmd_bytes.append(checksum)

        return bytes(cmd_bytes)

    def _format_can_command(self, command: ActuatorCommand) -> can.Message:
        """Format command for CAN transmission"""
        # Create CAN message based on control mode
        arbitration_id = 0x140 + self.device_address  # Standard format

        if command.control_mode == ControlMode.POSITION:
            # Encode position in message data
            pos_int = int(command.position * 1000)  # Convert to integer
            data = pos_int.to_bytes(4, byteorder='little', signed=True) + b'\x00\x00\x00\x00'
        elif command.control_mode == ControlMode.VELOCITY:
            vel_int = int(command.velocity * 1000)
            data = vel_int.to_bytes(4, byteorder='little', signed=True) + b'\x01\x00\x00\x00'
        elif command.control_mode == ControlMode.TORQUE:
            torque_int = int(command.torque * 1000)
            data = torque_int.to_bytes(4, byteorder='little', signed=True) + b'\x02\x00\x00\x00'
        else:
            # Default to position control
            pos_int = int(command.position * 1000)
            data = pos_int.to_bytes(4, byteorder='little', signed=True) + b'\x00\x00\x00\x00'

        return can.Message(
            arbitration_id=arbitration_id,
            data=data,
            is_extended_id=True
        )

    def _parse_serial_response(self, response: bytes) -> ActuatorState:
        """Parse serial response into actuator state"""
        if len(response) < 10:
            return self.current_state  # Return previous state if invalid response

        try:
            # Example parsing based on protocol
            position = int.from_bytes(response[0:4], byteorder='little', signed=True) / 1000.0
            velocity = int.from_bytes(response[4:8], byteorder='little', signed=True) / 1000.0
            torque = int.from_bytes(response[8:12], byteorder='little', signed=True) / 1000.0
            temperature = int.from_bytes(response[12:13], byteorder='big', signed=False)
            current = int.from_bytes(response[13:15], byteorder='big', signed=True) / 1000.0

            return ActuatorState(
                position=position,
                velocity=velocity,
                torque=torque,
                temperature=temperature,
                current=current,
                timestamp=time.time()
            )
        except Exception:
            return self.current_state

    def _parse_can_response(self, msg: can.Message) -> ActuatorState:
        """Parse CAN response into actuator state"""
        try:
            if len(msg.data) < 8:
                return self.current_state

            position = int.from_bytes(msg.data[0:4], byteorder='little', signed=True) / 1000.0
            velocity = int.from_bytes(msg.data[4:8], byteorder='little', signed=True) / 1000.0

            return ActuatorState(
                position=position,
                velocity=velocity,
                timestamp=msg.timestamp
            )
        except Exception:
            return self.current_state

    def disconnect(self) -> bool:
        """Disconnect from servo controller"""
        try:
            if hasattr(self, 'serial_port'):
                self.serial_port.close()
            elif hasattr(self, 'can_bus'):
                self.can_bus.shutdown()

            self.is_connected = False
            return True
        except Exception as e:
            print(f"Servo disconnect error: {e}")
            return False

class PIDController:
    """PID controller implementation for actuator control"""

    def __init__(self, kp: float, ki: float, kd: float,
                 output_limits: Tuple[float, float] = (-100.0, 100.0)):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.output_limits = output_limits

        self.integral = 0.0
        self.previous_error = 0.0
        self.previous_time = time.time()

        # Anti-windup parameters
        self.windup_guard = 100.0
        self.integral_limit = self.windup_guard / max(abs(ki), 1e-10) if ki != 0 else 100.0

    def update(self, error: float) -> float:
        """Update PID controller with new error value"""
        current_time = time.time()
        dt = current_time - self.previous_time

        if dt <= 0.0:
            dt = 1e-6  # Small positive value to avoid division by zero

        # Proportional term
        proportional = self.kp * error

        # Integral term
        self.integral += error * dt
        self.integral = np.clip(self.integral, -self.integral_limit, self.integral_limit)
        integral_term = self.ki * self.integral

        # Derivative term
        if dt > 0:
            derivative = (error - self.previous_error) / dt
        else:
            derivative = 0.0
        derivative_term = self.kd * derivative

        # Calculate output
        output = proportional + integral_term + derivative_term

        # Apply output limits
        output = np.clip(output, self.output_limits[0], self.output_limits[1])

        # Update for next iteration
        self.previous_error = error
        self.previous_time = current_time

        return output

    def reset(self):
        """Reset the PID controller state"""
        self.integral = 0.0
        self.previous_error = 0.0
        self.previous_time = time.time()
```

### 2.2 Communication Protocol Implementation

```python
class CANBusActuatorNetwork:
    """Implementation of CAN bus network for distributed actuator control"""

    def __init__(self, channel: str = 'can0', bitrate: int = 500000):
        self.channel = channel
        self.bitrate = bitrate
        self.bus = None
        self.actuators = {}  # {id: ServoController}
        self.message_handlers = {}
        self.is_running = False
        self.receive_thread = None

    def connect_network(self) -> bool:
        """Connect to CAN bus network"""
        try:
            self.bus = can.Bus(channel=self.channel, bustype='socketcan', bitrate=self.bitrate)
            self.is_running = True

            # Start receiving thread
            self.receive_thread = threading.Thread(target=self._receive_messages)
            self.receive_thread.daemon = True
            self.receive_thread.start()

            return True
        except Exception as e:
            print(f"CAN network connection failed: {e}")
            return False

    def add_actuator(self, actuator_id: str, controller: ServoController):
        """Add actuator controller to network"""
        self.actuators[actuator_id] = controller

    def send_command_to_actuator(self, actuator_id: str, command: ActuatorCommand) -> bool:
        """Send command to specific actuator via CAN bus"""
        if actuator_id not in self.actuators:
            return False

        # Format command for CAN transmission
        msg = self._format_actuator_command(actuator_id, command)

        try:
            self.bus.send(msg)
            return True
        except Exception as e:
            print(f"CAN command send error: {e}")
            return False

    def broadcast_command(self, command_template: ActuatorCommand):
        """Broadcast command to all actuators"""
        for actuator_id in self.actuators:
            command = ActuatorCommand(
                position=command_template.position,
                velocity=command_template.velocity,
                torque=command_template.torque,
                kp=command_template.kp,
                kd=command_template.kd,
                control_mode=command_template.control_mode,
                timestamp=time.time()
            )
            self.send_command_to_actuator(actuator_id, command)

    def _format_actuator_command(self, actuator_id: str, command: ActuatorCommand) -> can.Message:
        """Format command for specific actuator"""
        # Use actuator ID as part of arbitration ID
        # Format: [Command Type (4 bits) | Actuator ID (12 bits)]
        cmd_type_map = {
            ControlMode.POSITION: 0x1,
            ControlMode.VELOCITY: 0x2,
            ControlMode.TORQUE: 0x3,
            ControlMode.IMPEDANCE: 0x4
        }

        cmd_type = cmd_type_map.get(command.control_mode, 0x1)
        actuator_addr = hash(actuator_id) % 0x1000  # 12-bit address

        arbitration_id = (cmd_type << 12) | actuator_addr

        # Pack command data
        if command.control_mode == ControlMode.POSITION:
            data = struct.pack('<f', command.position)
        elif command.control_mode == ControlMode.VELOCITY:
            data = struct.pack('<f', command.velocity)
        elif command.control_mode == ControlMode.TORQUE:
            data = struct.pack('<f', command.torque)
        elif command.control_mode == ControlMode.IMPEDANCE:
            data = struct.pack('<ffff', command.position, command.velocity, command.kp, command.kd)
        else:
            data = struct.pack('<f', command.position)  # Default to position

        return can.Message(
            arbitration_id=arbitration_id,
            data=data,
            is_extended_id=True
        )

    def _receive_messages(self):
        """Receive and process incoming CAN messages"""
        while self.is_running:
            try:
                msg = self.bus.recv(timeout=0.1)
                if msg:
                    # Parse message and update actuator state
                    self._process_received_message(msg)
            except Exception as e:
                print(f"CAN receive error: {e}")
                time.sleep(0.01)  # Brief delay before retry

    def _process_received_message(self, msg: can.Message):
        """Process received CAN message"""
        # Extract actuator ID and command type from arbitration ID
        cmd_type = (msg.arbitration_id >> 12) & 0xF
        actuator_addr = msg.arbitration_id & 0xFFF

        # Find corresponding actuator
        for actuator_id, controller in self.actuators.items():
            if hash(actuator_id) % 0x1000 == actuator_addr:
                # Update actuator state based on received data
                if len(msg.data) >= 4:  # Minimum data size
                    try:
                        state_value = struct.unpack('<f', msg.data[:4])[0]

                        # Update controller's current state
                        if cmd_type == 0x1:  # Position feedback
                            controller.current_state.position = state_value
                        elif cmd_type == 0x2:  # Velocity feedback
                            controller.current_state.velocity = state_value
                        elif cmd_type == 0x3:  # Torque feedback
                            controller.current_state.torque = state_value

                        controller.current_state.timestamp = msg.timestamp
                    except Exception as e:
                        print(f"Message parsing error: {e}")
                break

    def disconnect_network(self):
        """Disconnect from CAN bus network"""
        self.is_running = False
        if self.receive_thread:
            self.receive_thread.join()
        if self.bus:
            self.bus.shutdown()
            self.bus = None
```

## 3. Control Algorithm Implementation

### 3.1 PID Control Implementation

```python
class AdvancedPIDController:
    """Advanced PID controller with feedforward and anti-windup"""

    def __init__(self, kp: float, ki: float, kd: float,
                 feedforward_gain: float = 0.0,
                 output_limits: Tuple[float, float] = (-100.0, 100.0),
                 derivative_filter_tau: float = 0.01):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.kf = feedforward_gain
        self.output_limits = output_limits
        self.derivative_filter_tau = derivative_filter_tau  # Derivative filter time constant

        # State variables
        self.integral = 0.0
        self.previous_error = 0.0
        self.filtered_derivative = 0.0
        self.previous_time = time.time()

        # Anti-windup parameters
        self.windup_guard = 100.0
        self.integral_limit = self.windup_guard / max(abs(ki), 1e-10) if ki != 0 else 100.0

    def update(self, error: float, feedforward_signal: float = 0.0, dt: float = None) -> float:
        """Update PID controller with error and feedforward signal"""
        if dt is None:
            current_time = time.time()
            dt = current_time - self.previous_time
            self.previous_time = current_time
        else:
            current_time = self.previous_time + dt

        if dt <= 0.0:
            dt = 1e-6  # Small positive value to avoid division by zero

        # Proportional term
        proportional = self.kp * error

        # Integral term with anti-windup
        self.integral += error * dt

        # Anti-windup: only integrate if output is not saturated
        if self.ki != 0:
            # Calculate what the output would be without integral
            proportional_derivative = proportional + self.kd * self.filtered_derivative
            feedforward_contribution = self.kf * feedforward_signal

            # Only integrate if the sum of other terms doesn't saturate the output
            if (proportional_derivative + feedforward_contribution) < self.output_limits[0]:
                # Output would be saturated low, only integrate if error is positive
                if error > 0:
                    self.integral = min(self.integral, self.integral_limit)
                else:
                    self.integral = max(self.integral, -self.integral_limit)
            elif (proportional_derivative + feedforward_contribution) > self.output_limits[1]:
                # Output would be saturated high, only integrate if error is negative
                if error < 0:
                    self.integral = min(self.integral, self.integral_limit)
                else:
                    self.integral = max(self.integral, -self.integral_limit)
            else:
                # No saturation, integrate normally
                self.integral = np.clip(self.integral, -self.integral_limit, self.integral_limit)

        integral_term = self.ki * self.integral

        # Derivative term with low-pass filter to reduce noise
        if dt > 0:
            raw_derivative = (error - self.previous_error) / dt

            # First-order low-pass filter on derivative
            alpha = dt / (self.derivative_filter_tau + dt)
            self.filtered_derivative = alpha * raw_derivative + (1 - alpha) * self.filtered_derivative
        else:
            self.filtered_derivative = 0.0

        derivative_term = self.kd * self.filtered_derivative

        # Feedforward term
        feedforward_term = self.kf * feedforward_signal

        # Calculate total output
        output = proportional + integral_term + derivative_term + feedforward_term

        # Apply output limits
        output = np.clip(output, self.output_limits[0], self.output_limits[1])

        # Update for next iteration
        self.previous_error = error

        return output

    def reset(self):
        """Reset the PID controller state"""
        self.integral = 0.0
        self.previous_error = 0.0
        self.filtered_derivative = 0.0
        self.previous_time = time.time()

    def tune_parameters(self, kp: float = None, ki: float = None, kd: float = None):
        """Dynamically tune PID parameters"""
        if kp is not None:
            self.kp = kp
        if ki is not None:
            self.ki = ki
            self.integral_limit = self.windup_guard / max(abs(ki), 1e-10) if ki != 0 else 100.0
        if kd is not None:
            self.kd = kd

class TrajectoryBasedController:
    """Controller that follows predefined trajectories with feedforward"""

    def __init__(self, kp: float, ki: float, kd: float, kv: float = 1.0):
        self.pid_controller = AdvancedPIDController(kp, ki, kd)
        self.velocity_feedforward_gain = kv
        self.tracking_error = 0.0
        self.velocity_error = 0.0

    def update(self, current_pos: float, current_vel: float,
               desired_pos: float, desired_vel: float, desired_acc: float = 0.0) -> float:
        """Update controller with trajectory tracking"""
        # Position error
        pos_error = desired_pos - current_pos
        self.tracking_error = pos_error

        # Velocity error
        vel_error = desired_vel - current_vel
        self.velocity_error = vel_error

        # Feedforward term based on desired acceleration
        feedforward = self.velocity_feedforward_gain * desired_vel + desired_acc

        # Use PID on position error with velocity feedforward
        pid_output = self.pid_controller.update(pos_error, feedforward)

        return pid_output

    def get_tracking_error(self) -> float:
        """Get current tracking error"""
        return self.tracking_error
```

### 3.2 Impedance Control Implementation

```python
class ImpedanceController:
    """Implementation of impedance control for compliant actuator behavior"""

    def __init__(self, stiffness: float = 1000.0, damping: float = 20.0,
                 mass: float = 1.0, max_force: float = 100.0):
        self.stiffness = stiffness  # N/m or Nm/rad
        self.damping = damping      # Ns/m or Nms/rad
        self.mass = mass           # kg or kg*m^2
        self.max_force = max_force  # N or Nm

        # Desired equilibrium position
        self.desired_pos = 0.0

        # State variables
        self.position = 0.0
        self.velocity = 0.0
        self.force = 0.0

        # Previous state for numerical differentiation
        self.prev_pos = 0.0
        self.prev_time = time.time()

    def update(self, current_pos: float, dt: float = None) -> float:
        """Update impedance controller to compute desired force/torque"""
        if dt is None:
            current_time = time.time()
            dt = current_time - self.prev_time
            self.prev_time = current_time
        else:
            current_time = self.prev_time + dt

        # Update current state
        self.position = current_pos
        self.velocity = (current_pos - self.prev_pos) / dt if dt > 0 else 0.0
        self.prev_pos = current_pos

        # Calculate position and velocity errors relative to desired equilibrium
        pos_error = self.desired_pos - current_pos
        vel_error = 0.0 - self.velocity  # Assuming desired velocity is 0

        # Calculate impedance force: F = K*(xd-x) + B*(vd-v) + M*a
        # For steady state: F = K*(xd-x) + B*(vd-v)
        spring_force = self.stiffness * pos_error
        damper_force = self.damping * vel_error
        # Mass term would require acceleration (not calculated here)

        total_force = spring_force + damper_force

        # Apply force limits
        self.force = np.clip(total_force, -self.max_force, self.max_force)

        return self.force

    def set_equilibrium(self, position: float):
        """Set new equilibrium position"""
        self.desired_pos = position

    def get_impedance_params(self) -> Dict[str, float]:
        """Get current impedance parameters"""
        return {
            'stiffness': self.stiffness,
            'damping': self.damping,
            'mass': self.mass,
            'max_force': self.max_force
        }

    def set_impedance_params(self, stiffness: float = None, damping: float = None,
                           mass: float = None, max_force: float = None):
        """Dynamically adjust impedance parameters"""
        if stiffness is not None:
            self.stiffness = stiffness
        if damping is not None:
            self.damping = damping
        if mass is not None:
            self.mass = mass
        if max_force is not None:
            self.max_force = max_force

class VariableStiffnessController:
    """Controller for actuators with variable stiffness capabilities"""

    def __init__(self, base_stiffness: float = 100.0, max_stiffness: float = 1000.0,
                 min_stiffness: float = 10.0):
        self.base_stiffness = base_stiffness
        self.max_stiffness = max_stiffness
        self.min_stiffness = min_stiffness

        # Current stiffness value
        self.current_stiffness = base_stiffness

        # Stiffness control PID
        self.stiffness_pid = AdvancedPIDController(
            kp=0.1, ki=0.01, kd=0.001,
            output_limits=(min_stiffness, max_stiffness)
        )

        # Position controller with variable stiffness
        self.position_controller = AdvancedPIDController(
            kp=base_stiffness, ki=10.0, kd=1.0
        )

    def update(self, current_pos: float, desired_pos: float,
               desired_stiffness: float = None) -> float:
        """Update variable stiffness controller"""
        # Update desired stiffness if provided
        if desired_stiffness is not None:
            # Use PID to smoothly transition to desired stiffness
            stiffness_error = desired_stiffness - self.current_stiffness
            self.current_stiffness = self.stiffness_pid.update(stiffness_error)
            self.current_stiffness = np.clip(
                self.current_stiffness,
                self.min_stiffness,
                self.max_stiffness
            )

            # Update position controller's KP with current stiffness
            self.position_controller.tune_parameters(kp=self.current_stiffness)

        # Calculate position error
        pos_error = desired_pos - current_pos

        # Use current stiffness in position control
        control_output = self.position_controller.update(pos_error)

        return control_output

    def get_current_stiffness(self) -> float:
        """Get current stiffness value"""
        return self.current_stiffness
```

### 3.3 Torque Control Implementation

```python
class TorqueController:
    """Implementation of torque control for actuator force regulation"""

    def __init__(self, kp: float = 1.0, ki: float = 0.1, kd: float = 0.05,
                 max_current: float = 10.0, torque_constant: float = 0.1):
        self.current_pid = AdvancedPIDController(kp, ki, kd)
        self.max_current = max_current
        self.torque_constant = torque_constant  # Nm/A
        self.friction_compensation = 0.0  # Torque to overcome static friction
        self.gravity_compensation = 0.0   # Torque to counteract gravity
        self.desired_torque = 0.0
        self.measured_torque = 0.0

    def update(self, desired_torque: float, measured_torque: float = None,
               current_load: float = 0.0) -> float:
        """Update torque controller to compute current command"""
        self.desired_torque = desired_torque

        if measured_torque is not None:
            self.measured_torque = measured_torque

        # Calculate torque error
        torque_error = desired_torque - self.measured_torque if measured_torque is not None else desired_torque

        # Add compensation terms
        compensation_torque = self.friction_compensation + self.gravity_compensation

        # Calculate required current using PID on torque error
        current_command = self.current_pid.update(torque_error)

        # Add feedforward compensation
        current_command += compensation_torque / self.torque_constant

        # Apply current limits
        current_command = np.clip(current_command, -self.max_current, self.max_current)

        # Convert to torque for verification
        actual_torque = current_command * self.torque_constant

        return current_command, actual_torque

    def set_friction_compensation(self, friction_torque: float):
        """Set friction compensation value"""
        self.friction_compensation = friction_torque

    def set_gravity_compensation(self, gravity_torque: float):
        """Set gravity compensation value (depends on joint angle and robot configuration)"""
        self.gravity_compensation = gravity_torque

class CurrentController:
    """Low-level current controller for precise torque control"""

    def __init__(self, kp: float = 10.0, ki: float = 1.0, kd: float = 0.1,
                 max_voltage: float = 24.0, resistance: float = 0.5, inductance: float = 0.01):
        self.current_pid = AdvancedPIDController(kp, ki, kd)
        self.max_voltage = max_voltage
        self.resistance = resistance  # Motor resistance in Ohms
        self.inductance = inductance  # Motor inductance in Henrys

        self.desired_current = 0.0
        self.measured_current = 0.0
        self.back_emf = 0.0  # Back EMF voltage

    def update(self, desired_current: float, measured_current: float,
               back_emf: float = 0.0, dt: float = 0.001) -> float:
        """Update current controller to compute voltage command"""
        self.desired_current = desired_current
        self.measured_current = measured_current
        self.back_emf = back_emf

        # Calculate current error
        current_error = desired_current - measured_current

        # Use PID to calculate voltage command
        voltage_command = self.current_pid.update(current_error)

        # Add compensation for back EMF and resistive drop
        voltage_command += back_emf
        voltage_command += measured_current * self.resistance

        # Apply voltage limits
        voltage_command = np.clip(voltage_command, -self.max_voltage, self.max_voltage)

        return voltage_command

    def estimate_current(self, applied_voltage: float, dt: float) -> float:
        """Estimate current based on applied voltage (simulation)"""
        # Simple RL circuit model: L*di/dt = V - R*i - back_emf
        # Rearranged: di/dt = (V - R*i - back_emf) / L
        if self.inductance > 0:
            di_dt = (applied_voltage - self.measured_current * self.resistance - self.back_emf) / self.inductance
            new_current = self.measured_current + di_dt * dt
        else:
            # If inductance is negligible, assume instantaneous response
            new_current = applied_voltage / self.resistance

        return np.clip(new_current, -self.max_current, self.max_current)
```

## 4. Multi-Actuator Coordination

### 4.1 Centralized Control Implementation

```python
class CentralizedActuatorController:
    """Centralized controller for coordinating multiple actuators"""

    def __init__(self, control_frequency: float = 1000.0):  # 1000 Hz default
        self.control_frequency = control_frequency
        self.dt = 1.0 / control_frequency
        self.actuators = {}  # {id: controller}
        self.joint_states = {}  # {id: state}
        self.desired_commands = {}  # {id: command}
        self.is_running = False
        self.control_thread = None
        self.safety_monitor = SafetyMonitor()

    def add_actuator(self, actuator_id: str, controller: MotorController):
        """Add actuator to centralized control system"""
        self.actuators[actuator_id] = controller
        self.joint_states[actuator_id] = ActuatorState()
        self.desired_commands[actuator_id] = ActuatorCommand()

    def set_desired_trajectory(self, actuator_id: str, command: ActuatorCommand):
        """Set desired command for specific actuator"""
        if actuator_id in self.desired_commands:
            self.desired_commands[actuator_id] = command

    def set_multiple_trajectories(self, commands: Dict[str, ActuatorCommand]):
        """Set commands for multiple actuators simultaneously"""
        for actuator_id, command in commands.items():
            self.set_desired_trajectory(actuator_id, command)

    def start_control_loop(self):
        """Start the centralized control loop"""
        self.is_running = True
        self.control_thread = threading.Thread(target=self._control_loop)
        self.control_thread.daemon = True
        self.control_thread.start()

    def stop_control_loop(self):
        """Stop the centralized control loop"""
        self.is_running = False
        if self.control_thread:
            self.control_thread.join()

    def _control_loop(self):
        """Main control loop running at specified frequency"""
        while self.is_running:
            start_time = time.time()

            # Update all actuator states
            for actuator_id, controller in self.actuators.items():
                state = controller.read_state()
                if state:
                    self.joint_states[actuator_id] = state

            # Apply safety checks
            if not self.safety_monitor.check_system_safety(self.joint_states):
                print("Safety violation detected, stopping all actuators")
                self.emergency_stop()
                break

            # Calculate control commands for all actuators
            control_commands = self._calculate_multi_actuator_control()

            # Send commands to all actuators
            for actuator_id, command in control_commands.items():
                if actuator_id in self.actuators:
                    success = self.actuators[actuator_id].send_command(command)
                    if not success:
                        print(f"Failed to send command to actuator {actuator_id}")

            # Maintain control frequency
            elapsed = time.time() - start_time
            sleep_time = max(0, self.dt - elapsed)
            if sleep_time > 0:
                time.sleep(sleep_time)

    def _calculate_multi_actuator_control(self) -> Dict[str, ActuatorCommand]:
        """Calculate control commands for all actuators based on desired trajectories"""
        commands = {}

        for actuator_id in self.actuators.keys():
            desired_cmd = self.desired_commands[actuator_id]
            current_state = self.joint_states[actuator_id]

            # Apply control law based on control mode
            if desired_cmd.control_mode == ControlMode.POSITION:
                # Position control with trajectory following
                command = self._position_control(
                    actuator_id, current_state, desired_cmd
                )
            elif desired_cmd.control_mode == ControlMode.VELOCITY:
                # Velocity control
                command = self._velocity_control(
                    actuator_id, current_state, desired_cmd
                )
            elif desired_cmd.control_mode == ControlMode.TORQUE:
                # Torque control
                command = self._torque_control(
                    actuator_id, current_state, desired_cmd
                )
            elif desired_cmd.control_mode == ControlMode.IMPEDANCE:
                # Impedance control
                command = self._impedance_control(
                    actuator_id, current_state, desired_cmd
                )
            else:
                # Default to position control
                command = self._position_control(
                    actuator_id, current_state, desired_cmd
                )

            commands[actuator_id] = command

        return commands

    def _position_control(self, actuator_id: str, current_state: ActuatorState,
                         desired_cmd: ActuatorCommand) -> ActuatorCommand:
        """Calculate position control command"""
        # For position control, we typically use PID on position error
        # and possibly feedforward on velocity
        pos_error = desired_cmd.position - current_state.position
        vel_error = desired_cmd.velocity - current_state.velocity

        # This is a simplified example - in practice, you'd have specific PID
        # controllers tuned for each actuator
        kp = 100.0  # Position gain
        kv = 10.0   # Velocity gain (for feedforward)

        # Calculate desired torque/current based on errors
        desired_torque = kp * pos_error + kv * vel_error

        # Create new command with calculated values
        command = ActuatorCommand(
            position=desired_cmd.position,
            velocity=desired_cmd.velocity,
            torque=np.clip(desired_torque, -100.0, 100.0),  # Limit torque
            control_mode=ControlMode.TORQUE,  # Switch to torque control
            timestamp=time.time()
        )

        return command

    def _velocity_control(self, actuator_id: str, current_state: ActuatorState,
                         desired_cmd: ActuatorCommand) -> ActuatorCommand:
        """Calculate velocity control command"""
        vel_error = desired_cmd.velocity - current_state.velocity

        # Simple PI control for velocity
        kp = 10.0
        ki = 1.0

        desired_torque = kp * vel_error + ki * self._get_integral_term(vel_error)

        command = ActuatorCommand(
            position=current_state.position,  # Use current position
            velocity=desired_cmd.velocity,
            torque=np.clip(desired_torque, -100.0, 100.0),
            control_mode=ControlMode.TORQUE,
            timestamp=time.time()
        )

        return command

    def _torque_control(self, actuator_id: str, current_state: ActuatorState,
                       desired_cmd: ActuatorCommand) -> ActuatorCommand:
        """Calculate torque control command"""
        # Direct torque control - just pass through the desired torque
        # with safety limiting
        command = ActuatorCommand(
            position=current_state.position,
            velocity=current_state.velocity,
            torque=np.clip(desired_cmd.torque, -100.0, 100.0),
            control_mode=ControlMode.TORQUE,
            timestamp=time.time()
        )

        return command

    def _impedance_control(self, actuator_id: str, current_state: ActuatorState,
                          desired_cmd: ActuatorCommand) -> ActuatorCommand:
        """Calculate impedance control command"""
        # Calculate desired force based on impedance parameters
        pos_error = desired_cmd.position - current_state.position
        vel_error = desired_cmd.velocity - current_state.velocity

        stiffness = desired_cmd.kp
        damping = desired_cmd.kd

        desired_force = stiffness * pos_error + damping * vel_error

        command = ActuatorCommand(
            position=desired_cmd.position,
            velocity=desired_cmd.velocity,
            torque=np.clip(desired_force, -100.0, 100.0),
            kp=stiffness,
            kd=damping,
            control_mode=ControlMode.TORQUE,
            timestamp=time.time()
        )

        return command

    def _get_integral_term(self, error: float) -> float:
        """Simple integral term calculation (in practice, you'd maintain state)"""
        # This is a placeholder - in real implementation, you'd maintain
        # integral state in the controller
        return error * self.dt

    def emergency_stop(self):
        """Emergency stop all actuators"""
        for actuator_id, controller in self.actuators.items():
            # Send zero torque command to all actuators
            zero_cmd = ActuatorCommand(
                torque=0.0,
                control_mode=ControlMode.TORQUE,
                timestamp=time.time()
            )
            controller.send_command(zero_cmd)

    def get_joint_states(self) -> Dict[str, ActuatorState]:
        """Get current states of all joints"""
        return self.joint_states.copy()

class SafetyMonitor:
    """Monitor actuator system for safety violations"""

    def __init__(self):
        self.temperature_limits = {}  # {id: (min_temp, max_temp)}
        self.torque_limits = {}      # {id: max_torque}
        self.velocity_limits = {}    # {id: max_velocity}
        self.position_limits = {}    # {id: (min_pos, max_pos)}
        self.emergency_stop_active = False

    def set_temperature_limits(self, actuator_id: str, min_temp: float, max_temp: float):
        """Set temperature limits for actuator"""
        self.temperature_limits[actuator_id] = (min_temp, max_temp)

    def set_torque_limits(self, actuator_id: str, max_torque: float):
        """Set torque limits for actuator"""
        self.torque_limits[actuator_id] = max_torque

    def set_velocity_limits(self, actuator_id: str, max_velocity: float):
        """Set velocity limits for actuator"""
        self.velocity_limits[actuator_id] = max_velocity

    def set_position_limits(self, actuator_id: str, min_pos: float, max_pos: float):
        """Set position limits for actuator"""
        self.position_limits[actuator_id] = (min_pos, max_pos)

    def check_system_safety(self, joint_states: Dict[str, ActuatorState]) -> bool:
        """Check if system is within safety limits"""
        if self.emergency_stop_active:
            return False

        for actuator_id, state in joint_states.items():
            # Check temperature
            temp_limits = self.temperature_limits.get(actuator_id, (-10, 80))
            if not (temp_limits[0] <= state.temperature <= temp_limits[1]):
                print(f"Temperature violation for actuator {actuator_id}: {state.temperature}Â°C")
                return False

            # Check torque
            max_torque = self.torque_limits.get(actuator_id, 100.0)
            if abs(state.torque) > max_torque:
                print(f"Torque violation for actuator {actuator_id}: {abs(state.torque)} Nm > {max_torque} Nm")
                return False

            # Check velocity
            max_velocity = self.velocity_limits.get(actuator_id, 10.0)
            if abs(state.velocity) > max_velocity:
                print(f"Velocity violation for actuator {actuator_id}: {abs(state.velocity)} rad/s > {max_velocity} rad/s")
                return False

            # Check position
            pos_limits = self.position_limits.get(actuator_id, (-np.pi*2, np.pi*2))
            if not (pos_limits[0] <= state.position <= pos_limits[1]):
                print(f"Position violation for actuator {actuator_id}: {state.position} rad")
                return False

        return True

    def trigger_emergency_stop(self):
        """Manually trigger emergency stop"""
        self.emergency_stop_active = True

    def clear_emergency_stop(self):
        """Clear emergency stop condition"""
        self.emergency_stop_active = False
```

### 4.2 Distributed Control Implementation

```python
class DistributedActuatorController:
    """Distributed controller where each actuator runs its own control loop"""

    def __init__(self, control_frequency: float = 1000.0):
        self.control_frequency = control_frequency
        self.dt = 1.0 / control_frequency
        self.actuators = {}  # {id: (controller, thread)}
        self.shared_state = {}  # Shared state between actuators
        self.communication_interface = None

    def add_actuator(self, actuator_id: str, controller: MotorController):
        """Add actuator with its own control thread"""
        control_thread = threading.Thread(
            target=self._actuator_control_loop,
            args=(actuator_id, controller),
            daemon=True
        )

        self.actuators[actuator_id] = {
            'controller': controller,
            'thread': control_thread,
            'desired_command': ActuatorCommand(),
            'current_state': ActuatorState(),
            'is_running': False
        }

    def set_desired_command(self, actuator_id: str, command: ActuatorCommand):
        """Set desired command for specific actuator"""
        if actuator_id in self.actuators:
            self.actuators[actuator_id]['desired_command'] = command

    def start_all_controllers(self):
        """Start control loops for all actuators"""
        for actuator_id, actuator_data in self.actuators.items():
            actuator_data['is_running'] = True
            actuator_data['thread'].start()

    def stop_all_controllers(self):
        """Stop control loops for all actuators"""
        for actuator_id, actuator_data in self.actuators.items():
            actuator_data['is_running'] = False
        # Give threads time to stop
        time.sleep(0.1)

    def _actuator_control_loop(self, actuator_id: str, controller: MotorController):
        """Individual control loop for each actuator"""
        actuator_data = self.actuators[actuator_id]

        while actuator_data['is_running']:
            start_time = time.time()

            # Read current state
            state = controller.read_state()
            if state:
                actuator_data['current_state'] = state

            # Get desired command
            desired_cmd = actuator_data['desired_command']

            # Apply local control law
            control_cmd = self._apply_local_control(
                actuator_id, actuator_data['current_state'], desired_cmd
            )

            # Send command to actuator
            controller.send_command(control_cmd)

            # Communicate with other actuators if needed
            self._communicate_with_others(actuator_id, actuator_data['current_state'])

            # Maintain control frequency
            elapsed = time.time() - start_time
            sleep_time = max(0, self.dt - elapsed)
            if sleep_time > 0:
                time.sleep(sleep_time)

    def _apply_local_control(self, actuator_id: str, current_state: ActuatorState,
                           desired_cmd: ActuatorCommand) -> ActuatorCommand:
        """Apply local control law to generate command"""
        # This would implement the specific control algorithm for this actuator
        # based on its current state and desired command

        if desired_cmd.control_mode == ControlMode.POSITION:
            # Position control implementation
            pos_error = desired_cmd.position - current_state.position
            control_output = 100.0 * pos_error  # Simple proportional control
        elif desired_cmd.control_mode == ControlMode.VELOCITY:
            # Velocity control implementation
            vel_error = desired_cmd.velocity - current_state.velocity
            control_output = 10.0 * vel_error
        elif desired_cmd.control_mode == ControlMode.TORQUE:
            # Torque control - directly use desired torque
            control_output = desired_cmd.torque
        else:
            control_output = 0.0

        # Create command with safety limits
        command = ActuatorCommand(
            position=desired_cmd.position,
            velocity=desired_cmd.velocity,
            torque=np.clip(control_output, -100.0, 100.0),
            control_mode=ControlMode.TORQUE,
            timestamp=time.time()
        )

        return command

    def _communicate_with_others(self, actuator_id: str, current_state: ActuatorState):
        """Share state information with other actuators"""
        # Update shared state for this actuator
        self.shared_state[actuator_id] = {
            'position': current_state.position,
            'velocity': current_state.velocity,
            'timestamp': current_state.timestamp
        }

        # This is where you would implement coordination algorithms
        # that depend on information from other actuators
```

## 5. Real-Time Implementation

### 5.1 Real-Time Scheduling

```python
import sched
import os
import ctypes

class RealTimeActuatorScheduler:
    """Real-time scheduler for actuator control with deterministic timing"""

    def __init__(self, control_frequency: float = 1000.0):
        self.control_frequency = control_frequency
        self.period_ns = int(1e9 / control_frequency)  # Period in nanoseconds
        self.actuators = {}
        self.scheduler = sched.scheduler(time.time, time.sleep)
        self.control_threads = {}
        self.is_running = False

        # Configure real-time priority (Linux-specific)
        self._configure_realtime_priority()

    def _configure_realtime_priority(self):
        """Configure real-time priority for actuator control"""
        try:
            # Set real-time scheduling (Linux)
            import resource
            # Set CPU affinity to dedicate cores to actuator control
            os.sched_setscheduler(0, os.SCHED_FIFO, os.sched_param(99))
        except AttributeError:
            # Not available on all platforms
            print("Real-time scheduling not available on this platform")
        except PermissionError:
            print("Permission denied for real-time scheduling. Run as root or configure capabilities.")

    def add_actuator(self, actuator_id: str, controller: MotorController,
                     control_phase: float = 0.0):
        """Add actuator with specific control phase (for staggered control)"""
        self.actuators[actuator_id] = {
            'controller': controller,
            'control_phase': control_phase,
            'last_update': time.time(),
            'desired_command': ActuatorCommand(),
            'current_state': ActuatorState()
        }

    def set_control_command(self, actuator_id: str, command: ActuatorCommand):
        """Set desired command for specific actuator"""
        if actuator_id in self.actuators:
            self.actuators[actuator_id]['desired_command'] = command

    def start_scheduled_control(self):
        """Start scheduled real-time control"""
        self.is_running = True

        # Schedule control for each actuator with appropriate phase
        for actuator_id, actuator_data in self.actuators.items():
            phase_offset = int(actuator_data['control_phase'] * self.period_ns)
            self._schedule_actuator_control(actuator_id, time.time() + phase_offset/1e9)

    def _schedule_actuator_control(self, actuator_id: str, start_time: float):
        """Schedule control for specific actuator"""
        if not self.is_running:
            return

        # Schedule next control execution
        next_time = start_time + self.period_ns / 1e9
        self.scheduler.enterabs(next_time, 1, self._execute_actuator_control,
                              argument=(actuator_id,))

        # Reschedule this actuator
        self.scheduler.enterabs(next_time, 1, self._schedule_actuator_control,
                              argument=(actuator_id, next_time))

    def _execute_actuator_control(self, actuator_id: str):
        """Execute control for specific actuator at scheduled time"""
        if actuator_id not in self.actuators:
            return

        actuator_data = self.actuators[actuator_id]
        controller = actuator_data['controller']

        # Read current state
        state = controller.read_state()
        if state:
            actuator_data['current_state'] = state

        # Calculate control command
        desired_cmd = actuator_data['desired_command']
        control_cmd = self._calculate_control_command(actuator_id, state, desired_cmd)

        # Send command to actuator
        controller.send_command(control_cmd)

        # Update timing
        actuator_data['last_update'] = time.time()

    def _calculate_control_command(self, actuator_id: str, current_state: ActuatorState,
                                 desired_cmd: ActuatorCommand) -> ActuatorCommand:
        """Calculate control command based on current state and desired command"""
        # Apply control law based on mode
        if desired_cmd.control_mode == ControlMode.POSITION:
            error = desired_cmd.position - current_state.position
            control_signal = 100.0 * error  # Proportional control
        elif desired_cmd.control_mode == ControlMode.VELOCITY:
            error = desired_cmd.velocity - current_state.velocity
            control_signal = 10.0 * error
        elif desired_cmd.control_mode == ControlMode.TORQUE:
            control_signal = desired_cmd.torque
        else:
            control_signal = 0.0

        # Apply limits
        control_signal = np.clip(control_signal, -100.0, 100.0)

        return ActuatorCommand(
            position=desired_cmd.position,
            velocity=desired_cmd.velocity,
            torque=control_signal,
            control_mode=ControlMode.TORQUE,
            timestamp=time.time()
        )

    def stop_scheduled_control(self):
        """Stop scheduled control"""
        self.is_running = False
        self.scheduler.cancel_all()

class LockstepSynchronizer:
    """Synchronize multiple actuators to operate in lockstep"""

    def __init__(self, num_actuators: int, control_frequency: float = 1000.0):
        self.num_actuators = num_actuators
        self.control_frequency = control_frequency
        self.dt = 1.0 / control_frequency
        self.barrier = threading.Barrier(num_actuators + 1)  # +1 for coordinator
        self.actuator_threads = []
        self.desired_commands = [ActuatorCommand() for _ in range(num_actuators)]
        self.current_states = [ActuatorState() for _ in range(num_actuators)]
        self.is_running = False

    def set_desired_commands(self, commands: List[ActuatorCommand]):
        """Set desired commands for all actuators"""
        for i, cmd in enumerate(commands):
            if i < len(self.desired_commands):
                self.desired_commands[i] = cmd

    def start_synchronized_control(self):
        """Start synchronized control of all actuators"""
        self.is_running = True

        # Start threads for each actuator
        for i in range(self.num_actuators):
            thread = threading.Thread(
                target=self._synchronized_control_loop,
                args=(i,),
                daemon=True
            )
            self.actuator_threads.append(thread)
            thread.start()

    def _synchronized_control_loop(self, actuator_index: int):
        """Synchronized control loop for individual actuator"""
        while self.is_running:
            # Wait for all actuators to reach this point
            self.barrier.wait()

            # All actuators proceed together
            start_time = time.time()

            # Read state
            # In real implementation, this would interface with actual hardware
            self.current_states[actuator_index] = self._read_actuator_state(actuator_index)

            # Calculate and send command
            command = self._calculate_sync_command(actuator_index)
            self._send_command_to_actuator(actuator_index, command)

            # Wait until it's time for the next cycle
            elapsed = time.time() - start_time
            sleep_time = max(0, self.dt - elapsed)
            if sleep_time > 0:
                time.sleep(sleep_time)

    def _read_actuator_state(self, actuator_index: int) -> ActuatorState:
        """Read state from specific actuator (placeholder)"""
        # In real implementation, this would interface with actual hardware
        return ActuatorState(
            position=np.random.random(),
            velocity=np.random.random(),
            timestamp=time.time()
        )

    def _calculate_sync_command(self, actuator_index: int) -> ActuatorCommand:
        """Calculate command for synchronized actuator"""
        desired_cmd = self.desired_commands[actuator_index]
        current_state = self.current_states[actuator_index]

        # Apply control law
        if desired_cmd.control_mode == ControlMode.POSITION:
            error = desired_cmd.position - current_state.position
            torque_cmd = 100.0 * error
        else:
            torque_cmd = desired_cmd.torque

        return ActuatorCommand(
            position=desired_cmd.position,
            velocity=desired_cmd.velocity,
            torque=np.clip(torque_cmd, -100.0, 100.0),
            control_mode=ControlMode.TORQUE,
            timestamp=time.time()
        )

    def _send_command_to_actuator(self, actuator_index: int, command: ActuatorCommand):
        """Send command to specific actuator (placeholder)"""
        # In real implementation, this would interface with actual hardware
        pass

    def stop_synchronized_control(self):
        """Stop synchronized control"""
        self.is_running = False
        # Wait for all threads to finish
        for thread in self.actuator_threads:
            thread.join()
```

### 5.2 Performance Monitoring

```python
class ActuatorPerformanceMonitor:
    """Monitor and log actuator performance metrics"""

    def __init__(self):
        self.performance_data = {}  # {actuator_id: [metrics]}
        self.metrics_history = {}  # {actuator_id: deque of recent metrics}
        self.start_times = {}      # {actuator_id: start_time}
        self.is_monitoring = False

    def start_monitoring(self, actuator_ids: List[str]):
        """Start monitoring for specified actuators"""
        self.is_monitoring = True
        for actuator_id in actuator_ids:
            self.performance_data[actuator_id] = []
            self.metrics_history[actuator_id] = deque(maxlen=1000)  # Keep last 1000 samples
            self.start_times[actuator_id] = time.time()

    def log_performance(self, actuator_id: str, state: ActuatorState,
                      command: ActuatorCommand, control_output: float):
        """Log performance data for an actuator"""
        if not self.is_monitoring:
            return

        current_time = time.time()
        metrics = {
            'timestamp': current_time,
            'position_error': command.position - state.position if command.control_mode == ControlMode.POSITION else 0.0,
            'velocity_error': command.velocity - state.velocity if command.control_mode == ControlMode.VELOCITY else 0.0,
            'torque_applied': state.torque,
            'torque_commanded': command.torque,
            'current': state.current,
            'temperature': state.temperature,
            'control_effort': abs(control_output),
            'tracking_accuracy': abs(command.position - state.position) if command.control_mode == ControlMode.POSITION else 0.0
        }

        self.performance_data[actuator_id].append(metrics)
        self.metrics_history[actuator_id].append(metrics)

    def get_performance_summary(self, actuator_id: str) -> Dict:
        """Get performance summary for specific actuator"""
        if actuator_id not in self.metrics_history:
            return {}

        history = list(self.metrics_history[actuator_id])
        if not history:
            return {}

        # Calculate statistics
        timestamps = [m['timestamp'] for m in history]
        position_errors = [m['position_error'] for m in history]
        tracking_accuracy = [m['tracking_accuracy'] for m in history]
        control_effort = [m['control_effort'] for m in history]
        temperatures = [m['temperature'] for m in history]

        return {
            'actuator_id': actuator_id,
            'sample_count': len(history),
            'time_span': max(timestamps) - min(timestamps) if timestamps else 0,
            'position_error_rms': np.sqrt(np.mean(np.array(position_errors)**2)) if position_errors else 0,
            'position_error_max': np.max(np.abs(position_errors)) if position_errors else 0,
            'tracking_accuracy_mean': np.mean(tracking_accuracy) if tracking_accuracy else 0,
            'tracking_accuracy_std': np.std(tracking_accuracy) if tracking_accuracy else 0,
            'control_effort_mean': np.mean(control_effort) if control_effort else 0,
            'temperature_max': np.max(temperatures) if temperatures else 0,
            'temperature_mean': np.mean(temperatures) if temperatures else 0,
            'steady_state_error': np.mean(position_errors[-100:]) if len(position_errors) >= 100 else np.mean(position_errors) if position_errors else 0
        }

    def get_all_performance_summaries(self) -> Dict[str, Dict]:
        """Get performance summaries for all monitored actuators"""
        summaries = {}
        for actuator_id in self.metrics_history.keys():
            summaries[actuator_id] = self.get_performance_summary(actuator_id)
        return summaries

    def save_performance_log(self, actuator_id: str, filename: str):
        """Save performance log to file"""
        import json

        # Convert numpy types to native Python types for JSON serialization
        serializable_data = []
        for metric in self.performance_data[actuator_id]:
            serializable_metric = {}
            for key, value in metric.items():
                if isinstance(value, np.floating):
                    serializable_metric[key] = float(value)
                elif isinstance(value, np.integer):
                    serializable_metric[key] = int(value)
                else:
                    serializable_metric[key] = value
            serializable_data.append(serializable_metric)

        with open(filename, 'w') as f:
            json.dump(serializable_data, f, indent=2)

class RealTimePerformanceTracker:
    """Track real-time performance metrics"""

    def __init__(self, buffer_size: int = 1000):
        self.buffer_size = buffer_size
        self.cycle_times = deque(maxlen=buffer_size)
        self.deadline_misses = 0
        self.total_cycles = 0
        self.max_cycle_time = 0.0
        self.min_cycle_time = float('inf')
        self.scheduled_period = 0.001  # Default 1ms

    def set_scheduled_period(self, period: float):
        """Set the scheduled control period"""
        self.scheduled_period = period

    def record_cycle_time(self, cycle_time: float):
        """Record the time taken for one control cycle"""
        self.cycle_times.append(cycle_time)
        self.total_cycles += 1

        if cycle_time > self.max_cycle_time:
            self.max_cycle_time = cycle_time

        if cycle_time < self.min_cycle_time:
            self.min_cycle_time = cycle_time

        # Count deadline misses
        if cycle_time > self.scheduled_period:
            self.deadline_misses += 1

    def get_real_time_metrics(self) -> Dict:
        """Get real-time performance metrics"""
        if not self.cycle_times:
            return {
                'avg_cycle_time': 0.0,
                'max_cycle_time': 0.0,
                'min_cycle_time': 0.0,
                'deadline_miss_rate': 0.0,
                'utilization': 0.0
            }

        avg_cycle_time = np.mean(self.cycle_times)
        deadline_miss_rate = self.deadline_misses / max(1, self.total_cycles)
        utilization = avg_cycle_time / self.scheduled_period if self.scheduled_period > 0 else 0.0

        return {
            'avg_cycle_time': avg_cycle_time,
            'max_cycle_time': self.max_cycle_time if self.max_cycle_time != float('inf') else 0.0,
            'min_cycle_time': self.min_cycle_time if self.min_cycle_time != float('inf') else 0.0,
            'deadline_miss_rate': deadline_miss_rate,
            'utilization': utilization,
            'total_cycles': self.total_cycles,
            'buffer_size': len(self.cycle_times)
        }
```

## 6. Integration with Robot Control Systems

### 6.1 Robot Control Interface

```python
class RobotActuatorInterface:
    """Interface between high-level robot controller and actuator systems"""

    def __init__(self, actuator_controllers: Dict[str, MotorController]):
        self.actuator_controllers = actuator_controllers
        self.joint_names = list(actuator_controllers.keys())
        self.num_joints = len(self.joint_names)

        # Joint state storage
        self.joint_positions = np.zeros(self.num_joints)
        self.joint_velocities = np.zeros(self.num_joints)
        self.joint_efforts = np.zeros(self.num_joints)
        self.joint_timestamps = np.zeros(self.num_joints)

        # Control command storage
        self.desired_positions = np.zeros(self.num_joints)
        self.desired_velocities = np.zeros(self.num_joints)
        self.desired_efforts = np.zeros(self.num_joints)
        self.control_modes = np.full(self.num_joints, ControlMode.POSITION.value)

        # Control mode mapping
        self.mode_map = {mode.value: mode for mode in ControlMode}

    def read_joint_states(self) -> Dict[str, float]:
        """Read current joint states from all actuators"""
        states = {}

        for i, joint_name in enumerate(self.joint_names):
            controller = self.actuator_controllers[joint_name]

            state = controller.read_state()
            if state:
                self.joint_positions[i] = state.position
                self.joint_velocities[i] = state.velocity
                self.joint_efforts[i] = state.torque
                self.joint_timestamps[i] = state.timestamp

                states[joint_name] = {
                    'position': state.position,
                    'velocity': state.velocity,
                    'effort': state.torque,
                    'timestamp': state.timestamp
                }

        return states

    def write_joint_commands(self, commands: Dict[str, Dict]):
        """Write joint commands to all actuators"""
        for joint_name, cmd_dict in commands.items():
            if joint_name in self.actuator_controllers:
                controller = self.actuator_controllers[joint_name]

                # Create ActuatorCommand from dictionary
                command = ActuatorCommand(
                    position=cmd_dict.get('position', 0.0),
                    velocity=cmd_dict.get('velocity', 0.0),
                    torque=cmd_dict.get('effort', 0.0),
                    kp=cmd_dict.get('stiffness', 0.0),
                    kd=cmd_dict.get('damping', 0.0),
                    control_mode=ControlMode(cmd_dict.get('mode', 'position')),
                    timestamp=time.time()
                )

                # Send command to controller
                controller.send_command(command)

    def set_joint_positions(self, positions: np.ndarray):
        """Set desired joint positions (for position control mode)"""
        if len(positions) == self.num_joints:
            self.desired_positions[:] = positions
            self._send_position_commands()

    def set_joint_velocities(self, velocities: np.ndarray):
        """Set desired joint velocities (for velocity control mode)"""
        if len(velocities) == self.num_joints:
            self.desired_velocities[:] = velocities
            self._send_velocity_commands()

    def set_joint_efforts(self, efforts: np.ndarray):
        """Set desired joint efforts (for effort control mode)"""
        if len(efforts) == self.num_joints:
            self.desired_efforts[:] = efforts
            self._send_effort_commands()

    def _send_position_commands(self):
        """Send position commands to all actuators"""
        for i, joint_name in enumerate(self.joint_names):
            command = ActuatorCommand(
                position=self.desired_positions[i],
                control_mode=ControlMode.POSITION,
                timestamp=time.time()
            )
            self.actuator_controllers[joint_name].send_command(command)

    def _send_velocity_commands(self):
        """Send velocity commands to all actuators"""
        for i, joint_name in enumerate(self.joint_names):
            command = ActuatorCommand(
                velocity=self.desired_velocities[i],
                control_mode=ControlMode.VELOCITY,
                timestamp=time.time()
            )
            self.actuator_controllers[joint_name].send_command(command)

    def _send_effort_commands(self):
        """Send effort commands to all actuators"""
        for i, joint_name in enumerate(self.joint_names):
            command = ActuatorCommand(
                torque=self.desired_efforts[i],
                control_mode=ControlMode.TORQUE,
                timestamp=time.time()
            )
            self.actuator_controllers[joint_name].send_command(command)

    def get_joint_state_arrays(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Get joint states as numpy arrays"""
        return (self.joint_positions.copy(),
                self.joint_velocities.copy(),
                self.joint_efforts.copy())

    def get_joint_names(self) -> List[str]:
        """Get list of joint names"""
        return self.joint_names.copy()

    def switch_control_mode(self, joint_name: str, mode: ControlMode):
        """Switch control mode for specific joint"""
        if joint_name in self.actuator_controllers:
            # In real implementation, this would send a mode switch command
            # For now, just update internal state
            idx = self.joint_names.index(joint_name)
            self.control_modes[idx] = mode.value

    def get_actuator_diagnostic(self) -> Dict[str, Dict]:
        """Get diagnostic information for all actuators"""
        diagnostics = {}

        for joint_name, controller in self.actuator_controllers.items():
            # Read current state to get diagnostic info
            state = controller.read_state()

            diagnostics[joint_name] = {
                'connected': controller.is_connected,
                'position': state.position if state else 0.0,
                'velocity': state.velocity if state else 0.0,
                'torque': state.torque if state else 0.0,
                'temperature': state.temperature if state else 25.0,
                'current': state.current if state else 0.0,
                'status_flags': state.status_flags if state else 0
            }

        return diagnostics

class WholeBodyController:
    """Coordinate actuator control with whole-body motion planning"""

    def __init__(self, actuator_interface: RobotActuatorInterface):
        self.actuator_interface = actuator_interface
        self.joint_names = actuator_interface.get_joint_names()
        self.num_joints = len(self.joint_names)

        # State estimation
        self.current_positions = np.zeros(self.num_joints)
        self.current_velocities = np.zeros(self.num_joints)
        self.current_efforts = np.zeros(self.num_joints)

        # Desired states
        self.desired_positions = np.zeros(self.num_joints)
        self.desired_velocities = np.zeros(self.num_joints)
        self.desired_accelerations = np.zeros(self.num_joints)

        # Control gains
        self.position_gains = np.full(self.num_joints, 100.0)
        self.velocity_gains = np.full(self.num_joints, 10.0)
        self.feedforward_gains = np.full(self.num_joints, 1.0)

        # Safety limits
        self.max_torques = np.full(self.num_joints, 100.0)
        self.max_velocities = np.full(self.num_joints, 10.0)
        self.max_positions = np.full(self.num_joints, np.pi * 2)
        self.min_positions = np.full(self.num_joints, -np.pi * 2)

    def update_state_estimation(self):
        """Update current state estimates from actuator interface"""
        positions, velocities, efforts = self.actuator_interface.get_joint_state_arrays()

        self.current_positions = positions
        self.current_velocities = velocities
        self.current_efforts = efforts

    def set_desired_trajectory(self, positions: np.ndarray,
                             velocities: np.ndarray = None,
                             accelerations: np.ndarray = None):
        """Set desired trajectory for all joints"""
        if len(positions) == self.num_joints:
            self.desired_positions[:] = positions

            if velocities is not None and len(velocities) == self.num_joints:
                self.desired_velocities[:] = velocities
            else:
                # Estimate velocities if not provided
                self.desired_velocities[:] = (positions - self.current_positions) * self.actuator_interface.control_frequency

            if accelerations is not None and len(accelerations) == self.num_joints:
                self.desired_accelerations[:] = accelerations
            else:
                # Set to zero if not provided
                self.desired_accelerations.fill(0.0)

    def compute_feedforward_torques(self) -> np.ndarray:
        """Compute feedforward torques for trajectory following"""
        # This would typically involve inverse dynamics calculations
        # For now, return zeros as a placeholder
        return np.zeros(self.num_joints)

    def compute_feedback_torques(self) -> np.ndarray:
        """Compute feedback torques based on position and velocity errors"""
        # Position error
        pos_error = self.desired_positions - self.current_positions
        vel_error = self.desired_velocities - self.current_velocities

        # Feedback control: tau = Kp * pos_error + Kv * vel_error
        feedback_torques = (self.position_gains * pos_error +
                           self.velocity_gains * vel_error)

        return feedback_torques

    def compute_total_control_torques(self) -> np.ndarray:
        """Compute total control torques (feedforward + feedback)"""
        feedforward_torques = self.compute_feedforward_torques()
        feedback_torques = self.compute_feedback_torques()

        total_torques = feedforward_torques + feedback_torques

        # Apply safety limits
        total_torques = np.clip(total_torques, -self.max_torques, self.max_torques)

        return total_torques

    def execute_control_step(self):
        """Execute one control step"""
        # Update state estimation
        self.update_state_estimation()

        # Compute control torques
        control_torques = self.compute_total_control_torques()

        # Send commands to actuators
        command_dict = {}
        for i, joint_name in enumerate(self.joint_names):
            command_dict[joint_name] = {
                'position': self.desired_positions[i],
                'velocity': self.desired_velocities[i],
                'effort': control_torques[i],
                'mode': 'torque'
            }

        self.actuator_interface.write_joint_commands(command_dict)

    def set_position_gains(self, gains: np.ndarray):
        """Set position control gains for all joints"""
        if len(gains) == self.num_joints:
            self.position_gains[:] = gains

    def set_velocity_gains(self, gains: np.ndarray):
        """Set velocity control gains for all joints"""
        if len(gains) == self.num_joints:
            self.velocity_gains[:] = gains

    def set_torque_limits(self, limits: np.ndarray):
        """Set torque limits for all joints"""
        if len(limits) == self.num_joints:
            self.max_torques[:] = np.abs(limits)

    def get_control_performance(self) -> Dict:
        """Get control performance metrics"""
        pos_error = self.desired_positions - self.current_positions
        vel_error = self.desired_velocities - self.current_velocities

        return {
            'position_error_rms': np.sqrt(np.mean(pos_error**2)),
            'position_error_max': np.max(np.abs(pos_error)),
            'velocity_error_rms': np.sqrt(np.mean(vel_error**2)),
            'average_torque': np.mean(np.abs(self.current_efforts)),
            'torque_utilization': np.mean(np.abs(self.current_efforts) / self.max_torques),
            'tracking_accuracy': 1.0 - np.mean(np.abs(pos_error) / (np.abs(self.desired_positions) + 1e-6))
        }
```

## 7. Validation and Testing

### 7.1 Actuator Testing Framework

```python
class ActuatorValidationFramework:
    """Framework for validating actuator performance"""

    def __init__(self, actuator_controller: MotorController):
        self.controller = actuator_controller
        self.test_results = {}
        self.performance_monitor = ActuatorPerformanceMonitor()

    def test_static_position_accuracy(self, positions: List[float],
                                    hold_time: float = 5.0) -> Dict:
        """Test static position accuracy at multiple positions"""
        print(f"Testing static position accuracy for actuator: {self.controller.actuator_id}")

        results = {
            'positions': [],
            'commanded_positions': [],
            'actual_positions': [],
            'errors': [],
            'accuracy_metrics': {}
        }

        for target_pos in positions:
            # Command the target position
            cmd = ActuatorCommand(
                position=target_pos,
                control_mode=ControlMode.POSITION,
                timestamp=time.time()
            )
            self.controller.send_command(cmd)

            # Wait for settling time
            time.sleep(hold_time)

            # Read actual position
            state = self.controller.read_state()
            if state:
                error = abs(target_pos - state.position)

                results['positions'].append(target_pos)
                results['commanded_positions'].append(target_pos)
                results['actual_positions'].append(state.position)
                results['errors'].append(error)

                print(f"Target: {target_pos:.3f}, Actual: {state.position:.3f}, Error: {error:.3f}")

        # Calculate accuracy metrics
        errors = np.array(results['errors'])
        results['accuracy_metrics'] = {
            'mean_error': np.mean(errors),
            'std_error': np.std(errors),
            'max_error': np.max(errors),
            'min_error': np.min(errors),
            'rms_error': np.sqrt(np.mean(errors**2)),
            'accuracy_percentage': 1.0 - (np.mean(errors) / np.max(np.abs(results['commanded_positions']))
        }

        self.test_results['static_accuracy'] = results
        return results

    def test_frequency_response(self, frequencies: List[float],
                              amplitude: float = 0.1) -> Dict:
        """Test frequency response of the actuator"""
        print(f"Testing frequency response for actuator: {self.controller.actuator_id}")

        results = {
            'frequencies': frequencies,
            'gain_db': [],
            'phase_deg': [],
            'amplitudes': [],
            'phases': []
        }

        control_freq = 1000  # Hz
        dt = 1.0 / control_freq

        for freq in frequencies:
            # Generate sinusoidal trajectory at this frequency
            duration = 2.0  # seconds
            t = np.arange(0, duration, dt)
            reference_pos = amplitude * np.sin(2 * np.pi * freq * t)
            reference_vel = amplitude * 2 * np.pi * freq * np.cos(2 * np.pi * freq * t)

            # Execute trajectory and record response
            actual_positions = []
            start_time = time.time()

            for i, (ref_pos, ref_vel) in enumerate(zip(reference_pos, reference_vel)):
                # Command position
                cmd = ActuatorCommand(
                    position=ref_pos,
                    velocity=ref_vel,
                    control_mode=ControlMode.POSITION,
                    timestamp=time.time()
                )
                self.controller.send_command(cmd)

                # Read actual position
                state = self.controller.read_state()
                if state:
                    actual_positions.append(state.position)

                # Maintain timing
                elapsed = time.time() - (start_time + i * dt)
                if elapsed < dt:
                    time.sleep(dt - elapsed)

            # Calculate frequency response (simplified)
            if len(actual_positions) == len(reference_pos):
                # Calculate gain and phase (simplified)
                actual_fft = np.fft.fft(actual_positions)
                reference_fft = np.fft.fft(reference_pos)

                # Find the bin corresponding to the test frequency
                freq_bin = int(freq * len(t) / control_freq)
                if freq_bin < len(actual_fft):
                    gain = np.abs(actual_fft[freq_bin]) / np.abs(reference_fft[freq_bin])
                    phase_diff = np.angle(actual_fft[freq_bin]) - np.angle(reference_fft[freq_bin])

                    results['gain_db'].append(20 * np.log10(gain) if gain > 0 else -1000)
                    results['phase_deg'].append(np.degrees(phase_diff))
                else:
                    results['gain_db'].append(0)
                    results['phase_deg'].append(0)
            else:
                results['gain_db'].append(0)
                results['phase_deg'].append(0)

        self.test_results['frequency_response'] = results
        return results

    def test_torque_control(self, torques: List[float], duration: float = 2.0) -> Dict:
        """Test torque control performance"""
        print(f"Testing torque control for actuator: {self.controller.actuator_id}")

        results = {
            'commanded_torques': [],
            'measured_torques': [],
            'torque_errors': [],
            'torque_accuracy': {}
        }

        for target_torque in torques:
            # Command the target torque
            cmd = ActuatorCommand(
                torque=target_torque,
                control_mode=ControlMode.TORQUE,
                timestamp=time.time()
            )
            self.controller.send_command(cmd)

            # Hold for specified duration and sample
            torques_measured = []
            start_time = time.time()

            while time.time() - start_time < duration:
                state = self.controller.read_state()
                if state:
                    torques_measured.append(state.torque)
                    time.sleep(0.01)  # 100 Hz sampling

            if torques_measured:
                avg_measured = np.mean(torques_measured)
                error = abs(target_torque - avg_measured)

                results['commanded_torques'].append(target_torque)
                results['measured_torques'].append(avg_measured)
                results['torque_errors'].append(error)

                print(f"Commanded: {target_torque:.3f}, Measured: {avg_measured:.3f}, Error: {error:.3f}")

        # Calculate torque accuracy metrics
        if results['torque_errors']:
            errors = np.array(results['torque_errors'])
            results['torque_accuracy'] = {
                'mean_error': np.mean(errors),
                'std_error': np.std(errors),
                'max_error': np.max(errors),
                'min_error': np.min(errors),
                'rms_error': np.sqrt(np.mean(errors**2))
            }

        self.test_results['torque_control'] = results
        return results

    def test_dynamic_performance(self, trajectory_generator, duration: float = 10.0) -> Dict:
        """Test dynamic performance with complex trajectory"""
        print(f"Testing dynamic performance for actuator: {self.controller.actuator_id}")

        results = {
            'time': [],
            'commanded_positions': [],
            'commanded_velocities': [],
            'actual_positions': [],
            'actual_velocities': [],
            'position_errors': [],
            'velocity_errors': [],
            'dynamic_metrics': {}
        }

        start_time = time.time()
        control_period = 0.001  # 1kHz

        while time.time() - start_time < duration:
            current_time = time.time() - start_time

            # Get desired state from trajectory generator
            desired_pos, desired_vel, desired_acc = trajectory_generator(current_time)

            # Command the desired position
            cmd = ActuatorCommand(
                position=desired_pos,
                velocity=desired_vel,
                control_mode=ControlMode.POSITION,
                timestamp=time.time()
            )
            self.controller.send_command(cmd)

            # Read actual state
            state = self.controller.read_state()
            if state:
                pos_error = abs(desired_pos - state.position)
                vel_error = abs(desired_vel - state.velocity)

                results['time'].append(current_time)
                results['commanded_positions'].append(desired_pos)
                results['commanded_velocities'].append(desired_vel)
                results['actual_positions'].append(state.position)
                results['actual_velocities'].append(state.velocity)
                results['position_errors'].append(pos_error)
                results['velocity_errors'].append(vel_error)

            # Maintain control rate
            elapsed = time.time() - (start_time + current_time)
            sleep_time = max(0, control_period - elapsed)
            if sleep_time > 0:
                time.sleep(sleep_time)

        # Calculate dynamic performance metrics
        pos_errors = np.array(results['position_errors'])
        vel_errors = np.array(results['velocity_errors'])

        results['dynamic_metrics'] = {
            'position_rms_error': np.sqrt(np.mean(pos_errors**2)),
            'position_max_error': np.max(pos_errors),
            'velocity_rms_error': np.sqrt(np.mean(vel_errors**2)),
            'velocity_max_error': np.max(vel_errors),
            'settling_time': self._calculate_settling_time(results['position_errors']),
            'overshoot_percentage': self._calculate_overshoot(results['commanded_positions'], results['actual_positions'])
        }

        self.test_results['dynamic_performance'] = results
        return results

    def _calculate_settling_time(self, errors: List[float], threshold: float = 0.02) -> float:
        """Calculate settling time to within threshold of final value"""
        if not errors:
            return 0.0

        # For simplicity, assume final error should be within threshold
        final_error = errors[-1] if errors else 0.0
        threshold_value = max(threshold, abs(final_error) * 1.1)  # 10% tolerance

        for i, error in enumerate(reversed(errors)):
            if abs(error) > threshold_value:
                return len(errors) - i - 1  # Return index where error went above threshold

        return 0.0  # If always within threshold

    def _calculate_overshoot(self, desired: List[float], actual: List[float]) -> float:
        """Calculate overshoot percentage"""
        if not desired or not actual:
            return 0.0

        # Find peak value and final value
        final_desired = desired[-1] if desired else 0.0
        peak_actual = max(abs(val) for val in actual)
        initial_val = actual[0] if actual else 0.0

        # Calculate overshoot as percentage of the final desired value
        if abs(final_desired - initial_val) > 1e-6:
            overshoot_pct = (abs(peak_actual - final_desired) / abs(final_desired - initial_val)) * 100
        else:
            overshoot_pct = 0.0

        return min(overshoot_pct, 100.0)  # Cap at 100%

    def run_comprehensive_test_suite(self) -> Dict:
        """Run comprehensive test suite for the actuator"""
        print(f"Running comprehensive test suite for actuator: {self.controller.actuator_id}")

        # Static accuracy test
        static_positions = np.linspace(-np.pi, np.pi, 11).tolist()
        static_results = self.test_static_position_accuracy(static_positions)

        # Torque control test
        test_torques = [-5.0, -2.5, 0.0, 2.5, 5.0]
        torque_results = self.test_torque_control(test_torques)

        # Dynamic performance test with a simple trajectory
        def simple_trajectory(t):
            """Simple sinusoidal trajectory for testing"""
            freq = 0.5  # 0.5 Hz
            amp = 0.5   # 0.5 rad
            pos = amp * np.sin(2 * np.pi * freq * t)
            vel = amp * 2 * np.pi * freq * np.cos(2 * np.pi * freq * t)
            acc = -amp * (2 * np.pi * freq)**2 * np.sin(2 * np.pi * freq * t)
            return pos, vel, acc

        dynamic_results = self.test_dynamic_performance(simple_trajectory, duration=5.0)

        comprehensive_results = {
            'actuator_id': self.controller.actuator_id,
            'static_accuracy': static_results,
            'torque_control': torque_results,
            'dynamic_performance': dynamic_results,
            'overall_grade': self._calculate_overall_grade({
                'static': static_results,
                'torque': torque_results,
                'dynamic': dynamic_results
            })
        }

        return comprehensive_results

    def _calculate_overall_grade(self, test_results: Dict) -> str:
        """Calculate overall grade based on test results"""
        # Simple grading based on error metrics
        static_error = test_results['static']['accuracy_metrics']['mean_error'] if test_results['static']['accuracy_metrics'] else 1.0
        torque_error = test_results['torque']['torque_accuracy']['mean_error'] if test_results['torque']['torque_accuracy'] else 10.0
        dynamic_error = test_results['dynamic']['dynamic_metrics']['position_rms_error'] if test_results['dynamic']['dynamic_metrics'] else 1.0

        # Normalize to 0-1 scale (lower is better)
        static_score = max(0, min(1, 0.1 / (static_error + 1e-6)))
        torque_score = max(0, min(1, 1.0 / (torque_error + 1e-6)))
        dynamic_score = max(0, min(1, 0.1 / (dynamic_error + 1e-6)))

        # Average score
        avg_score = (static_score + torque_score + dynamic_score) / 3.0

        if avg_score > 0.9:
            return "A+"
        elif avg_score > 0.8:
            return "A"
        elif avg_score > 0.7:
            return "B+"
        elif avg_score > 0.6:
            return "B"
        elif avg_score > 0.5:
            return "C+"
        elif avg_score > 0.4:
            return "C"
        else:
            return "F"
```

### 7.2 System Integration Testing

```python
class MultiActuatorIntegrationTest:
    """Test integration of multiple actuators working together"""

    def __init__(self, actuator_controllers: Dict[str, MotorController]):
        self.actuator_controllers = actuator_controllers
        self.joint_names = list(actuator_controllers.keys())
        self.num_joints = len(self.joint_names)
        self.performance_monitors = {
            name: ActuatorPerformanceMonitor() for name in self.joint_names
        }

    def test_coupled_motion(self, trajectory_func, duration: float = 10.0) -> Dict:
        """Test coordinated motion of multiple joints"""
        print("Testing coupled motion of multiple actuators")

        results = {
            'joint_trajectories': {name: [] for name in self.joint_names},
            'individual_performance': {},
            'coordination_metrics': {},
            'synchronization_error': []
        }

        start_time = time.time()
        control_period = 0.001  # 1kHz

        while time.time() - start_time < duration:
            current_time = time.time() - start_time

            # Get desired trajectory for all joints
            desired_positions, desired_velocities = trajectory_func(current_time)

            # Command all actuators
            for i, joint_name in enumerate(self.joint_names):
                if i < len(desired_positions):
                    cmd = ActuatorCommand(
                        position=desired_positions[i],
                        velocity=desired_velocities[i] if i < len(desired_velocities) else 0.0,
                        control_mode=ControlMode.POSITION,
                        timestamp=time.time()
                    )
                    self.actuator_controllers[joint_name].send_command(cmd)

            # Read all states
            actual_positions = []
            for i, joint_name in enumerate(self.joint_names):
                state = self.actuator_controllers[joint_name].read_state()
                if state:
                    actual_positions.append(state.position)
                    # Log performance
                    self.performance_monitors[joint_name].log_performance(
                        joint_name, state, cmd, state.torque
                    )

            # Calculate synchronization error
            if len(actual_positions) == len(desired_positions) and len(actual_positions) > 0:
                pos_error = np.array(desired_positions[:len(actual_positions)]) - np.array(actual_positions)
                sync_error = np.std(pos_error)  # Standard deviation of position errors
                results['synchronization_error'].append(sync_error)

            # Maintain control rate
            elapsed = time.time() - (start_time + current_time)
            sleep_time = max(0, control_period - elapsed)
            if sleep_time > 0:
                time.sleep(sleep_time)

        # Collect individual performance metrics
        for joint_name in self.joint_names:
            results['individual_performance'][joint_name] = (
                self.performance_monitors[joint_name].get_performance_summary(joint_name)
            )

        # Calculate coordination metrics
        sync_errors = np.array(results['synchronization_error'])
        results['coordination_metrics'] = {
            'avg_synchronization_error': np.mean(sync_errors) if len(sync_errors) > 0 else 0.0,
            'max_synchronization_error': np.max(sync_errors) if len(sync_errors) > 0 else 0.0,
            'std_synchronization_error': np.std(sync_errors) if len(sync_errors) > 0 else 0.0,
            'total_test_duration': duration
        }

        return results

    def test_balance_preserving_motion(self) -> Dict:
        """Test motions that preserve balance (for humanoid robots)"""
        # This would implement tests for motions that maintain the robot's center of mass
        # within the support polygon
        print("Testing balance-preserving motions")

        # For a humanoid, this might involve coordinated arm-leg movements
        # that keep the COM within safe bounds
        def balance_preserving_trajectory(t):
            # Example: coordinated arm and leg movements that preserve balance
            # Arms move in opposition to legs to maintain balance
            arm_amplitude = 0.3
            leg_amplitude = 0.2
            frequency = 0.2  # 0.2 Hz

            left_arm = arm_amplitude * np.sin(2 * np.pi * frequency * t)
            right_arm = -arm_amplitude * np.sin(2 * np.pi * frequency * t)
            left_leg = leg_amplitude * np.sin(2 * np.pi * frequency * t + np.pi)  # Opposite phase
            right_leg = -leg_amplitude * np.sin(2 * np.pi * frequency * t + np.pi)  # Opposite phase

            positions = [left_arm, right_arm, left_leg, right_leg]
            velocities = [
                arm_amplitude * 2 * np.pi * frequency * np.cos(2 * np.pi * frequency * t),
                -arm_amplitude * 2 * np.pi * frequency * np.cos(2 * np.pi * frequency * t),
                leg_amplitude * 2 * np.pi * frequency * np.cos(2 * np.pi * frequency * t + np.pi),
                -leg_amplitude * 2 * np.pi * frequency * np.cos(2 * np.pi * frequency * t + np.pi)
            ]

            return positions, velocities

        return self.test_coupled_motion(balance_preserving_trajectory, duration=10.0)

    def test_safety_critical_scenarios(self) -> Dict:
        """Test safety-critical scenarios like emergency stops and overload conditions"""
        print("Testing safety-critical scenarios")

        results = {
            'emergency_stop_response': {},
            'overload_protection': {},
            'collision_detection': {}
        }

        # Test emergency stop response
        start_time = time.time()

        # Send high-torque commands to simulate overload
        for joint_name, controller in self.actuator_controllers.items():
            high_torque_cmd = ActuatorCommand(
                torque=200.0,  # Much higher than normal
                control_mode=ControlMode.TORQUE,
                timestamp=time.time()
            )
            controller.send_command(high_torque_cmd)

        # Wait and observe safety system response
        time.sleep(2.0)

        # Check if safety systems engaged
        final_states = {}
        for joint_name, controller in self.actuator_controllers.items():
            state = controller.read_state()
            final_states[joint_name] = state

        results['overload_protection'] = {
            'final_states': final_states,
            'test_duration': time.time() - start_time,
            'safety_engaged': any(getattr(state, 'status_flags', 0) & 0x01 for state in final_states.values())  # Check for error flags
        }

        # Test emergency stop
        for joint_name, controller in self.actuator_controllers.items():
            # Send emergency stop command
            stop_cmd = ActuatorCommand(
                torque=0.0,
                control_mode=ControlMode.TORQUE,
                timestamp=time.time()
            )
            controller.send_command(stop_cmd)

        results['emergency_stop_response'] = {
            'executed': True,
            'timestamp': time.time()
        }

        return results

    def run_integration_test_suite(self) -> Dict:
        """Run comprehensive integration test suite"""
        print("Running multi-actuator integration test suite")

        results = {
            'coupled_motion_test': self.test_coupled_motion(self._simple_coordinated_trajectory, duration=5.0),
            'balance_preserving_test': self.test_balance_preserving_motion(),
            'safety_scenarios_test': self.test_safety_critical_scenarios(),
            'integration_score': 0.0
        }

        # Calculate integration score based on test results
        coupled_ok = len(results['coupled_motion_test']['synchronization_error']) > 0
        safety_ok = results['safety_scenarios_test']['overload_protection']['safety_engaged']

        score = 0.0
        if coupled_ok:
            sync_error_avg = np.mean(results['coupled_motion_test']['synchronization_error'])
            score += max(0, 100 - sync_error_avg * 1000)  # Lower error = higher score
        if safety_ok:
            score += 50  # Bonus for safety system activation

        results['integration_score'] = min(100, score / 2)  # Normalize to 0-100 scale

        return results

    def _simple_coordinated_trajectory(self, t: float) -> Tuple[List[float], List[float]]:
        """Simple coordinated trajectory for testing"""
        # Simple coordinated movement - all joints move in coordination
        amplitude = 0.2
        frequency = 0.5

        positions = []
        velocities = []

        for i, joint_name in enumerate(self.joint_names):
            phase = i * (2 * np.pi / len(self.joint_names))  # Phase delay between joints
            pos = amplitude * np.sin(2 * np.pi * frequency * t + phase)
            vel = amplitude * 2 * np.pi * frequency * np.cos(2 * np.pi * frequency * t + phase)

            positions.append(pos)
            velocities.append(vel)

        return positions, velocities
```

## 8. Practical Examples and Case Studies

### 8.1 Humanoid Robot Actuator System Example

```python
class HumanoidActuatorSystem:
    """Complete actuator system implementation for a humanoid robot"""

    def __init__(self, robot_config: Dict):
        self.robot_config = robot_config
        self.actuators = {}
        self.control_system = None
        self.safety_system = SafetyMonitor()
        self.performance_monitor = ActuatorPerformanceMonitor()

        # Initialize actuator controllers based on robot configuration
        self._initialize_actuators()

        # Set up control system
        self._setup_control_system()

        # Configure safety limits
        self._configure_safety_limits()

    def _initialize_actuators(self):
        """Initialize all actuators based on robot configuration"""
        for joint_config in self.robot_config.get('joints', []):
            joint_id = joint_config['id']
            actuator_config = joint_config['actuator']

            # Create appropriate actuator controller based on type
            if actuator_config['type'] == 'servo':
                controller = ServoController(joint_id, actuator_config)
            elif actuator_config['type'] == 'series_elastic':
                controller = self._create_series_elastic_controller(joint_id, actuator_config)
            else:
                controller = ServoController(joint_id, actuator_config)  # Default

            # Connect controller
            if controller.connect():
                self.actuators[joint_id] = controller
                print(f"Connected actuator: {joint_id}")
            else:
                print(f"Failed to connect actuator: {joint_id}")

    def _create_series_elastic_controller(self, actuator_id: str, config: Dict):
        """Create controller for series elastic actuator"""
        # SEA controllers might have additional features like force sensing
        class SEAController(ServoController):
            def __init__(self, actuator_id: str, config: Dict):
                super().__init__(actuator_id, config)
                self.spring_deflection = 0.0
                self.output_torque = 0.0

            def read_state(self) -> Optional[ActuatorState]:
                state = super().read_state()
                if state:
                    # Calculate output torque based on spring deflection
                    # This is a simplified model
                    stiffness = config.get('spring_stiffness', 1000.0)
                    self.output_torque = stiffness * self.spring_deflection
                    state.torque = self.output_torque
                return state

            def send_command(self, command: ActuatorCommand) -> bool:
                # For SEA, the control might involve both motor position and desired force
                # This is where the series elastic behavior is implemented
                return super().send_command(command)

        return SEAController(actuator_id, config)

    def _setup_control_system(self):
        """Setup the control system for the robot"""
        # Create actuator interface
        self.actuator_interface = RobotActuatorInterface(self.actuators)

        # Create whole body controller
        self.whole_body_controller = WholeBodyController(self.actuator_interface)

        # Set up safety monitoring
        self.safety_system = SafetyMonitor()

        # Configure safety limits based on robot configuration
        for joint_name, config in self.robot_config.get('joints', []):
            joint_config = config.get('joint_limits', {})
            actuator_config = config.get('actuator', {})

            # Set safety limits
            if 'temperature' in joint_config:
                self.safety_system.set_temperature_limits(
                    joint_name,
                    joint_config['temperature']['min'],
                    joint_config['temperature']['max']
                )

            if 'torque' in actuator_config:
                self.safety_system.set_torque_limits(
                    joint_name,
                    actuator_config['torque']['max']
                )

            if 'velocity' in joint_config:
                self.safety_system.set_velocity_limits(
                    joint_name,
                    joint_config['velocity']['max']
                )

            if 'position' in joint_config:
                self.safety_system.set_position_limits(
                    joint_name,
                    joint_config['position']['min'],
                    joint_config['position']['max']
                )

    def _configure_safety_limits(self):
        """Configure safety limits based on robot configuration"""
        for joint_name, config in self.robot_config.get('joints', []):
            # Additional safety configurations could go here
            pass

    def start_operation(self):
        """Start the actuator system operation"""
        print("Starting humanoid actuator system...")

        # Start the control system
        self.whole_body_controller.execute_control_step()

        print("Actuator system operational")

    def execute_motion_sequence(self, sequence: List[Dict]):
        """Execute a sequence of motions on the robot"""
        for motion in sequence:
            # Extract motion parameters
            positions = motion.get('positions', [])
            velocities = motion.get('velocities', [])
            duration = motion.get('duration', 1.0)
            control_mode = ControlMode(motion.get('control_mode', 'position'))

            # Set desired trajectory
            if len(positions) == len(self.actuator_interface.get_joint_names()):
                self.whole_body_controller.set_desired_trajectory(
                    np.array(positions),
                    np.array(velocities) if len(velocities) == len(positions) else None
                )

            # Execute for the specified duration
            start_time = time.time()
            while time.time() - start_time < duration:
                self.whole_body_controller.execute_control_step()
                time.sleep(0.001)  # 1kHz control

    def execute_balanced_motion(self, target_poses: List[np.ndarray],
                              gait_params: Dict = None) -> bool:
        """Execute a balanced motion sequence that maintains robot stability"""
        print("Executing balanced motion sequence...")

        # This would implement more sophisticated control that considers:
        # - Center of mass position
        # - Zero moment point (ZMP) tracking
        # - Balance feedback control
        # - Stable gait planning

        try:
            # For now, execute a simple sequence with balance checks
            for target_pose in target_poses:
                # Calculate if this pose is stable
                if self._is_pose_stable(target_pose):
                    # Execute the pose
                    self.whole_body_controller.set_desired_trajectory(target_pose)

                    # Monitor for balance
                    for _ in range(100):  # 100ms per pose
                        self.whole_body_controller.execute_control_step()

                        # Check if balance is maintained
                        if not self._check_balance():
                            print("Balance lost during motion, stopping")
                            return False

                        time.sleep(0.01)
                else:
                    print(f"Unstable pose requested: {target_pose}")
                    return False

            return True

        except Exception as e:
            print(f"Error in balanced motion: {e}")
            return False

    def _is_pose_stable(self, pose: np.ndarray) -> bool:
        """Check if a pose is statically stable (simplified)"""
        # This is a simplified check - in reality, you'd calculate COM position
        # and check if it's within the support polygon
        # For now, just return True as a placeholder
        return True

    def _check_balance(self) -> bool:
        """Check if the robot is currently balanced (simplified)"""
        # This would interface with balance sensors (IMU, force sensors)
        # For now, just check if joint positions are within reasonable bounds
        states = self.whole_body_controller.actuator_interface.read_joint_states()

        for joint_name, state_dict in states.items():
            state = state_dict['position']
            # Check if position is reasonable (not too extreme)
            if abs(state) > 5.0:  # 5 radians is quite extreme for most joints
                return False

        return True

    def stop_operation(self):
        """Stop the actuator system safely"""
        print("Stopping humanoid actuator system...")

        # Send zero torque commands to all actuators
        for joint_name in self.actuator_interface.get_joint_names():
            cmd = ActuatorCommand(
                torque=0.0,
                control_mode=ControlMode.TORQUE,
                timestamp=time.time()
            )
            self.actuators[joint_name].send_command(cmd)

        print("Actuator system stopped")

    def get_robot_state(self) -> Dict:
        """Get current robot state for control and monitoring"""
        states = self.actuator_interface.read_joint_states()

        # Calculate additional state information
        joint_positions = np.array([states[jn]['position'] for jn in self.actuator_interface.get_joint_names()])
        joint_velocities = np.array([states[jn]['velocity'] for jn in self.actuator_interface.get_joint_names()])
        joint_efforts = np.array([states[jn]['effort'] for jn in self.actuator_interface.get_joint_names()])

        return {
            'joint_states': states,
            'joint_positions': joint_positions,
            'joint_velocities': joint_velocities,
            'joint_efforts': joint_efforts,
            'timestamp': time.time(),
            'balance_metrics': self._calculate_balance_metrics(states)
        }

    def _calculate_balance_metrics(self, states: Dict) -> Dict:
        """Calculate balance-related metrics"""
        # Simplified balance metrics - in reality, this would use IMU, F/T sensors
        joint_positions = [states[jn]['position'] for jn in self.actuator_interface.get_joint_names()]
        joint_torques = [states[jn]['effort'] for jn in self.actuator_interface.get_joint_names()]

        return {
            'avg_joint_torque': np.mean(np.abs(joint_torques)),
            'max_joint_position': np.max(np.abs(joint_positions)),
            'total_torque_load': np.sum(np.abs(joint_torques))
        }

# Example configuration for a humanoid robot
def create_example_robot_config():
    """Create an example robot configuration"""
    return {
        'name': 'ExampleHumanoid',
        'joints': [
            {
                'id': 'left_hip_yaw',
                'actuator': {
                    'type': 'servo',
                    'interface': 'can',
                    'address': 0x01,
                    'max_torque': 50.0,
                    'max_velocity': 5.0,
                    'position_kp': 500.0,
                    'position_ki': 10.0,
                    'position_kd': 50.0
                },
                'joint_limits': {
                    'position': {'min': -1.5, 'max': 1.5},
                    'velocity': {'max': 5.0},
                    'torque': {'max': 50.0},
                    'temperature': {'min': -10, 'max': 70}
                }
            },
            {
                'id': 'left_hip_roll',
                'actuator': {
                    'type': 'servo',
                    'interface': 'can',
                    'address': 0x02,
                    'max_torque': 75.0,
                    'max_velocity': 4.0,
                    'position_kp': 750.0,
                    'position_ki': 15.0,
                    'position_kd': 75.0
                },
                'joint_limits': {
                    'position': {'min': -0.5, 'max': 0.5},
                    'velocity': {'max': 4.0},
                    'torque': {'max': 75.0},
                    'temperature': {'min': -10, 'max': 70}
                }
            },
            # Add more joints as needed...
        ]
    }

# Example usage
def example_humanoid_actuator_system():
    """Example of setting up and using a humanoid actuator system"""

    # Create robot configuration
    robot_config = create_example_robot_config()

    # Create actuator system
    actuator_system = HumanoidActuatorSystem(robot_config)

    # Start operation
    actuator_system.start_operation()

    # Execute a simple motion sequence
    motion_sequence = [
        {
            'positions': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # Example positions for 6 joints
            'velocities': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            'duration': 2.0,
            'control_mode': 'position'
        },
        {
            'positions': [0.1, 0.1, 0.1, 0.1, 0.1, 0.1],
            'velocities': [0.05, 0.05, 0.05, 0.05, 0.05, 0.05],
            'duration': 1.0,
            'control_mode': 'position'
        }
    ]

    actuator_system.execute_motion_sequence(motion_sequence)

    # Get robot state
    robot_state = actuator_system.get_robot_state()
    print(f"Robot state: {robot_state}")

    # Stop operation
    actuator_system.stop_operation()

if __name__ == "__main__":
    example_humanoid_actuator_system()
```

## 9. Troubleshooting and Maintenance

### 9.1 Diagnostic Tools

```python
class ActuatorDiagnosticSystem:
    """Comprehensive diagnostic system for actuator health monitoring"""

    def __init__(self, actuators: Dict[str, MotorController]):
        self.actuators = actuators
        self.diagnostic_history = {}
        self.calibration_data = {}
        self.wear_indicators = {}

    def run_complete_diagnostic(self) -> Dict[str, Dict]:
        """Run complete diagnostic on all actuators"""
        results = {}

        for actuator_id, controller in self.actuators.items():
            print(f"Running diagnostic on actuator: {actuator_id}")
            results[actuator_id] = self._run_single_actuator_diagnostic(actuator_id, controller)

        self.diagnostic_history[time.time()] = results
        return results

    def _run_single_actuator_diagnostic(self, actuator_id: str, controller: MotorController) -> Dict:
        """Run diagnostic on a single actuator"""
        result = {
            'connection_test': self._test_connection(controller),
            'calibration_check': self._check_calibration(actuator_id),
            'backlash_measurement': self._measure_backlash(controller),
            'friction_analysis': self._analyze_friction(controller),
            'temperature_behavior': self._test_temperature_behavior(controller),
            'torque_accuracy': self._test_torque_accuracy(controller),
            'position_repeatability': self._test_position_repeatability(controller),
            'overall_health': 'unknown'
        }

        # Calculate overall health based on test results
        health_score = self._calculate_health_score(result)
        result['overall_health'] = self._health_score_to_label(health_score)
        result['health_score'] = health_score

        return result

    def _test_connection(self, controller: MotorController) -> Dict:
        """Test communication with actuator"""
        try:
            # Try to read state multiple times
            success_count = 0
            for _ in range(5):
                state = controller.read_state()
                if state:
                    success_count += 1
                time.sleep(0.01)

            return {
                'connected': success_count > 3,  # Require 4 out of 5 successes
                'success_rate': success_count / 5.0,
                'last_state': state.__dict__ if state else None
            }
        except Exception as e:
            return {
                'connected': False,
                'success_rate': 0.0,
                'error': str(e)
            }

    def _check_calibration(self, actuator_id: str) -> Dict:
        """Check if actuator is properly calibrated"""
        # Check if calibration data exists and is recent
        if actuator_id in self.calibration_data:
            cal_data = self.calibration_data[actuator_id]
            age_hours = (time.time() - cal_data.get('timestamp', 0)) / 3600

            return {
                'calibrated': True,
                'age_hours': age_hours,
                'needs_recals': age_hours > 168,  # 1 week
                'calibration_data': cal_data
            }
        else:
            return {
                'calibrated': False,
                'age_hours': float('inf'),
                'needs_recals': True,
                'calibration_data': None
            }

    def _measure_backlash(self, controller: MotorController) -> Dict:
        """Measure mechanical backlash in the actuator"""
        try:
            # Move to a position from both directions and compare
            test_position = 0.0

            # Command to move to position from negative direction
            cmd_neg = ActuatorCommand(position=test_position, control_mode=ControlMode.POSITION)
            controller.send_command(cmd_neg)
            time.sleep(1.0)
            state_neg = controller.read_state()

            # Command to move to position from positive direction
            cmd_pos = ActuatorCommand(position=test_position, control_mode=ControlMode.POSITION)
            controller.send_command(cmd_pos)
            time.sleep(1.0)
            state_pos = controller.read_state()

            if state_neg and state_pos:
                backlash = abs(state_pos.position - state_neg.position)
                return {
                    'backlash_mm': backlash,
                    'threshold_exceeded': backlash > 0.001,  # 1mm threshold
                    'direction_difference': state_pos.position - state_neg.position
                }

            return {'backlash_mm': 0.0, 'threshold_exceeded': False, 'error': 'could_not_measure'}
        except Exception as e:
            return {'error': str(e)}

    def _analyze_friction(self, controller: MotorController) -> Dict:
        """Analyze friction characteristics"""
        try:
            # Move slowly in both directions and measure required torque
            slow_velocity = 0.1  # rad/s

            # Measure torque needed to maintain slow movement in both directions
            cmd_fwd = ActuatorCommand(velocity=slow_velocity, control_mode=ControlMode.VELOCITY)
            controller.send_command(cmd_fwd)
            time.sleep(0.5)
            state_fwd = controller.read_state()

            cmd_bck = ActuatorCommand(velocity=-slow_velocity, control_mode=ControlMode.VELOCITY)
            controller.send_command(cmd_bck)
            time.sleep(0.5)
            state_bck = controller.read_state()

            if state_fwd and state_bck:
                friction_up = abs(state_fwd.torque)
                friction_down = abs(state_bck.torque)
                average_friction = (friction_up + friction_down) / 2.0

                return {
                    'average_friction': average_friction,
                    'friction_asymmetry': abs(friction_up - friction_down),
                    'stiction_estimate': min(friction_up, friction_down)
                }

            return {'error': 'could_not_measure'}
        except Exception as e:
            return {'error': str(e)}

    def _test_temperature_behavior(self, controller: MotorController) -> Dict:
        """Test actuator behavior across temperature range"""
        # This would involve more complex thermal testing in a real system
        # For now, just check if temperature readings are reasonable
        state = controller.read_state()
        if state:
            return {
                'current_temperature': state.temperature,
                'temperature_normal': 10 <= state.temperature <= 50,  # Normal operating range
                'thermal_warning': state.temperature > 40
            }
        return {'error': 'no_temperature_data'}

    def _test_torque_accuracy(self, controller: MotorController) -> Dict:
        """Test torque control accuracy"""
        # This would require force/torque sensors in a real system
        # For now, return a basic test
        return {
            'torque_control_available': True,
            'estimated_accuracy': 'not_tested_without_sensors'
        }

    def _test_position_repeatability(self, controller: MotorController) -> Dict:
        """Test position repeatability"""
        try:
            test_positions = [0.0, 0.5, -0.5, 0.0]  # Return to home to test repeatability
            home_position = None
            final_position = None

            for pos in test_positions:
                cmd = ActuatorCommand(position=pos, control_mode=ControlMode.POSITION)
                controller.send_command(cmd)
                time.sleep(1.0)
                state = controller.read_state()
                if state:
                    if pos == 0.0 and home_position is None:
                        home_position = state.position
                    elif pos == 0.0 and home_position is not None:
                        final_position = state.position

            if home_position is not None and final_position is not None:
                repeatability_error = abs(home_position - final_position)
                return {
                    'repeatability_error': repeatability_error,
                    'acceptable': repeatability_error < 0.001,  # 1mrad
                    'home_drift': repeatability_error
                }

            return {'error': 'repeatability_test_failed'}
        except Exception as e:
            return {'error': str(e)}

    def _calculate_health_score(self, test_results: Dict) -> float:
        """Calculate overall health score from test results"""
        score = 100.0  # Start with perfect score

        # Deduct points for failures
        if not test_results.get('connection_test', {}).get('connected', True):
            score -= 30

        if test_results.get('backlash_measurement', {}).get('threshold_exceeded', False):
            score -= 10

        if test_results.get('temperature_behavior', {}).get('thermal_warning', False):
            score -= 15

        # Additional deductions based on other test results
        if test_results.get('position_repeatability', {}).get('acceptable', True) == False:
            score -= 5

        return max(0, min(100, score))

    def _health_score_to_label(self, score: float) -> str:
        """Convert numerical health score to categorical label"""
        if score >= 90:
            return "excellent"
        elif score >= 75:
            return "good"
        elif score >= 60:
            return "fair"
        elif score >= 40:
            return "poor"
        else:
            return "critical"

    def generate_maintenance_report(self) -> str:
        """Generate a comprehensive maintenance report"""
        diagnostics = self.run_complete_diagnostic()

        report = f"Actuator Health Report - Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n"
        report += "=" * 70 + "\n\n"

        for actuator_id, results in diagnostics.items():
            report += f"Actuator: {actuator_id}\n"
            report += f"  Health: {results['overall_health']} (Score: {results.get('health_score', 0):.1f}/100)\n"

            # Highlight issues
            if not results['connection_test']['connected']:
                report += "  â Connection: Failed\n"
            if results.get('backlash_measurement', {}).get('threshold_exceeded', False):
                backlash = results['backlash_measurement']['backlash_mm']
                report += f"  â ï¸  Backlash: {backlash:.3f} rad (exceeds threshold)\n"
            if results.get('temperature_behavior', {}).get('thermal_warning', False):
                temp = results['temperature_behavior']['current_temperature']
                report += f"  â ï¸  Temperature: {temp:.1f}Â°C (elevated)\n"

            report += "\n"

        # Summary
        health_counts = {}
        for results in diagnostics.values():
            health = results['overall_health']
            health_counts[health] = health_counts.get(health, 0) + 1

        report += "Summary:\n"
        for health, count in health_counts.items():
            report += f"  {health.capitalize()}: {count} actuators\n"

        return report

    def save_calibration(self, actuator_id: str, calibration_params: Dict):
        """Save calibration data for an actuator"""
        self.calibration_data[actuator_id] = {
            'params': calibration_params,
            'timestamp': time.time(),
            'calibrated_by': 'system'
        }

    def predict_maintenance_needs(self) -> Dict[str, Dict]:
        """Predict maintenance needs based on diagnostic history"""
        predictions = {}

        for actuator_id in self.actuators.keys():
            # Analyze trends in diagnostic results
            historical_data = []
            for timestamp, results in self.diagnostic_history.items():
                if actuator_id in results:
                    historical_data.append((timestamp, results[actuator_id]))

            if historical_data:
                # Look for trends indicating wear
                health_scores = [data[1].get('health_score', 100) for _, data in historical_data]

                if len(health_scores) >= 2:
                    # Calculate trend
                    time_values = [data[0] for data in historical_data]
                    scores = health_scores

                    # Simple linear trend
                    if len(scores) > 1:
                        trend = np.polyfit(range(len(scores)), scores, 1)[0]

                        predictions[actuator_id] = {
                            'degradation_trend': trend,
                            'maintenance_due': trend < -2.0,  # Degrading faster than 2 points per test
                            'recommended_action': 'inspect' if trend < -2.0 else 'monitor'
                        }

        return predictions
```

## Conclusion

The practical implementation of actuator systems for humanoid robots requires careful attention to real-time performance, safety, and system integration. The implementations provided in this section demonstrate how to create robust actuator control systems that can handle the demanding requirements of humanoid robot applications.

Key implementation considerations include efficient communication protocols, real-time control algorithms, safety monitoring, and integration with higher-level control systems. The modular design of these systems allows for adaptation to different robot architectures and application requirements.

Successful implementation requires iterative refinement, with continuous validation and adjustment based on real-world performance. The combination of precise control, safety systems, and robust integration enables humanoid robots to achieve the dynamic capabilities required for safe and effective human-robot interaction.