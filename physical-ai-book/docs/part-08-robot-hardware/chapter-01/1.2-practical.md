---
title: 8.2 Humanoid Robot Hardware Implementation
sidebar_position: 32
---

# 8.2 Humanoid Robot Hardware Implementation

## Introduction

This section provides practical implementation examples for humanoid robot hardware systems, focusing on real-world design and integration challenges. We'll cover implementation of actuators, sensors, structural components, power systems, and control architectures with practical examples and code.

## 1. Actuator Control Implementation

### Servo Motor Control System

Let's implement a control system for servo motors commonly used in humanoid robots:

```python
import time
import numpy as np
from typing import Dict, List, Tuple
import threading
from dataclasses import dataclass

@dataclass
class JointConfig:
    """Configuration for a single joint"""
    name: str
    min_position: float
    max_position: float
    max_velocity: float
    max_torque: float
    gear_ratio: float
    encoder_resolution: int

class ServoController:
    """Low-level servo controller interface"""

    def __init__(self, device_id: int, joint_config: JointConfig):
        self.device_id = device_id
        self.config = joint_config
        self.current_position = 0.0
        self.current_velocity = 0.0
        self.current_torque = 0.0
        self.target_position = 0.0
        self.target_velocity = 0.0
        self.target_torque = 0.0

        # PID controller parameters
        self.kp = 800.0   # Position gain
        self.ki = 0.0     # Integral gain
        self.kd = 20.0    # Derivative gain

        # PID state
        self.error_integral = 0.0
        self.last_error = 0.0
        self.last_time = time.time()

    def read_position(self) -> float:
        """Read current joint position from encoder"""
        # Simulated encoder reading
        # In real hardware, this would interface with the actual encoder
        return self.current_position

    def read_torque(self) -> float:
        """Read current joint torque"""
        # Simulated torque reading
        return self.current_torque

    def write_position(self, position: float) -> None:
        """Set target position for position control"""
        # Apply joint limits
        clamped_position = np.clip(position,
                                  self.config.min_position,
                                  self.config.max_position)
        self.target_position = clamped_position

    def write_torque(self, torque: float) -> None:
        """Set target torque for torque control"""
        clamped_torque = np.clip(torque,
                                -self.config.max_torque,
                                self.config.max_torque)
        self.target_torque = clamped_torque

    def update_control(self) -> None:
        """Update control loop - called at regular intervals"""
        current_time = time.time()
        dt = current_time - self.last_time
        self.last_time = current_time

        if dt <= 0:
            return

        # Read current position
        current_pos = self.read_position()

        # Calculate error for position control
        error = self.target_position - current_pos

        # Update integral term
        self.error_integral += error * dt

        # Calculate derivative term
        error_derivative = (error - self.last_error) / dt if dt > 0 else 0.0
        self.last_error = error

        # Calculate control output using PID
        control_output = (self.kp * error +
                         self.ki * self.error_integral +
                         self.kd * error_derivative)

        # Apply torque limits
        control_output = np.clip(control_output,
                                -self.config.max_torque,
                                self.config.max_torque)

        # In real hardware, this would command the motor driver
        self.write_torque(control_output)

        # Update current state (simulation)
        self.current_torque = control_output
        self.current_velocity = (current_pos - self.current_position) / dt if dt > 0 else 0.0
        self.current_position = current_pos

class MultiJointController:
    """Controller for multiple joints"""

    def __init__(self, joint_configs: Dict[str, JointConfig]):
        self.joints = {}
        for name, config in joint_configs.items():
            self.joints[name] = ServoController(len(self.joints), config)

        self.control_thread = None
        self.running = False

    def start_control_loop(self, frequency: float = 1000.0):
        """Start the control loop in a separate thread"""
        self.running = True
        self.control_thread = threading.Thread(target=self._control_loop,
                                              args=(frequency,))
        self.control_thread.daemon = True
        self.control_thread.start()

    def stop_control_loop(self):
        """Stop the control loop"""
        self.running = False
        if self.control_thread:
            self.control_thread.join()

    def _control_loop(self, frequency: float):
        """Main control loop running at specified frequency"""
        dt = 1.0 / frequency
        last_time = time.time()

        while self.running:
            current_time = time.time()
            if current_time - last_time >= dt:
                # Update all joints
                for joint in self.joints.values():
                    joint.update_control()

                last_time = current_time
            else:
                time.sleep(0.001)  # Small sleep to prevent busy waiting

    def set_joint_positions(self, positions: Dict[str, float]):
        """Set target positions for multiple joints"""
        for joint_name, position in positions.items():
            if joint_name in self.joints:
                self.joints[joint_name].write_position(position)

    def get_joint_states(self) -> Dict[str, Dict[str, float]]:
        """Get current state of all joints"""
        states = {}
        for name, joint in self.joints.items():
            states[name] = {
                'position': joint.current_position,
                'velocity': joint.current_velocity,
                'torque': joint.current_torque,
                'target_position': joint.target_position
            }
        return states
```

### Series Elastic Actuator (SEA) Implementation

```python
class SeriesElasticActuator:
    """Implementation of Series Elastic Actuator"""

    def __init__(self, motor_config: Dict, spring_constant: float = 100.0):
        self.motor = self._init_motor(motor_config)
        self.spring_constant = spring_constant  # N*m/rad
        self.spring_deflection = 0.0
        self.motor_position = 0.0
        self.joint_position = 0.0
        self.desired_torque = 0.0

        # Torque control PID
        self.torque_kp = 10.0
        self.torque_ki = 1.0
        self.torque_kd = 0.1

        self.torque_error_integral = 0.0
        self.last_torque_error = 0.0

    def _init_motor(self, config: Dict):
        """Initialize motor controller"""
        # In real implementation, this would initialize the actual motor driver
        return ServoController(0, JointConfig(
            name="sea_motor",
            min_position=-10.0,
            max_position=10.0,
            max_velocity=10.0,
            max_torque=50.0,
            gear_ratio=1.0,
            encoder_resolution=4096
        ))

    def update(self, desired_torque: float):
        """Update SEA control"""
        self.desired_torque = desired_torque

        # Read current positions
        motor_pos = self.motor.read_position()
        joint_pos = self._read_joint_position()  # From joint encoder

        # Calculate spring deflection
        self.spring_deflection = motor_pos - joint_pos

        # Calculate current torque from spring deflection
        current_torque = self.spring_constant * self.spring_deflection

        # Torque control loop
        torque_error = self.desired_torque - current_torque

        # Update integral term
        self.torque_error_integral += torque_error

        # Calculate derivative term
        torque_error_derivative = torque_error - self.last_torque_error
        self.last_torque_error = torque_error

        # Calculate motor position adjustment
        motor_adjustment = (self.torque_kp * torque_error +
                           self.torque_ki * self.torque_error_integral +
                           self.torque_kd * torque_error_derivative)

        # Set new motor target position
        new_motor_pos = joint_pos + self.spring_deflection + motor_adjustment
        self.motor.write_position(new_motor_pos)

        # Update positions for next iteration
        self.motor_position = motor_pos
        self.joint_position = joint_pos

    def _read_joint_position(self) -> float:
        """Read joint position from joint encoder (simulated)"""
        # In real implementation, this would read from the actual joint encoder
        return self.joint_position
```

## 2. Sensor Integration Implementation

### IMU Data Processing

```python
import math
from scipy.spatial.transform import Rotation as R

class IMUProcessor:
    """Process IMU data for humanoid robot state estimation"""

    def __init__(self, sample_rate: float = 100.0):
        self.sample_rate = sample_rate
        self.dt = 1.0 / sample_rate

        # IMU data
        self.accel_raw = np.zeros(3)  # Raw accelerometer data [x, y, z]
        self.gyro_raw = np.zeros(3)   # Raw gyroscope data [x, y, z]
        self.mag_raw = np.zeros(3)    # Raw magnetometer data [x, y, z]

        # Processed data
        self.accel_filtered = np.zeros(3)
        self.gyro_filtered = np.zeros(3)
        self.orientation = np.array([0.0, 0.0, 0.0, 1.0])  # Quaternion [x, y, z, w]

        # Filters
        self.accel_filter = LowPassFilter(cutoff_freq=10.0, sample_rate=sample_rate)
        self.gyro_filter = LowPassFilter(cutoff_freq=10.0, sample_rate=sample_rate)

        # Calibration parameters
        self.accel_bias = np.zeros(3)
        self.gyro_bias = np.zeros(3)
        self.accel_scale = np.ones(3)
        self.gyro_scale = np.ones(3)

        # Gravity vector in world frame
        self.gravity = np.array([0, 0, -9.81])

    def update(self, accel_raw: np.ndarray, gyro_raw: np.ndarray,
               mag_raw: np.ndarray = None):
        """Update with new IMU measurements"""
        # Apply calibration
        accel_cal = (accel_raw - self.accel_bias) * self.accel_scale
        gyro_cal = (gyro_raw - self.gyro_bias) * self.gyro_scale

        # Apply filtering
        self.accel_filtered = self.accel_filter.update(accel_cal)
        self.gyro_filtered = self.gyro_filter.update(gyro_cal)

        # Update orientation using gyroscope integration
        self._integrate_gyro()

        # Optionally use magnetometer for heading correction
        if mag_raw is not None:
            self._correct_with_magnetometer(mag_raw)

    def _integrate_gyro(self):
        """Integrate gyroscope data to update orientation"""
        # Convert gyroscope readings to quaternion derivative
        omega = self.gyro_filtered
        q = self.orientation.copy()

        # Quaternion derivative: q_dot = 0.5 * omega_quat * q
        omega_quat = np.array([omega[0], omega[1], omega[2], 0.0])
        q_dot = 0.5 * self._quat_multiply(omega_quat, q)

        # Integrate: q_new = q_old + q_dot * dt
        q_new = self.orientation + q_dot * self.dt

        # Normalize quaternion
        self.orientation = q_new / np.linalg.norm(q_new)

    def _quat_multiply(self, q1, q2):
        """Multiply two quaternions"""
        w1, x1, y1, z1 = q1
        w2, x2, y2, z2 = q2

        w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2
        x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2
        y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2
        z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2

        return np.array([w, x, y, z])

    def _correct_with_magnetometer(self, mag_raw: np.ndarray):
        """Use magnetometer to correct heading drift"""
        # Convert magnetometer reading to world frame using current orientation
        # This is a simplified implementation
        pass

    def get_euler_angles(self) -> np.ndarray:
        """Get orientation as Euler angles (roll, pitch, yaw)"""
        r = R.from_quat(self.orientation)
        return r.as_euler('xyz', degrees=False)

class LowPassFilter:
    """Simple low-pass filter implementation"""

    def __init__(self, cutoff_freq: float, sample_rate: float):
        self.cutoff_freq = cutoff_freq
        self.sample_rate = sample_rate

        # Calculate filter coefficient
        dt = 1.0 / sample_rate
        rc = 1.0 / (2 * math.pi * cutoff_freq)
        self.alpha = dt / (rc + dt)

        self.filtered_value = 0.0
        self.initialized = False

    def update(self, input_value: float) -> float:
        """Update filter with new input"""
        if not self.initialized:
            self.filtered_value = input_value
            self.initialized = True
        else:
            self.filtered_value = (self.alpha * input_value +
                                  (1 - self.alpha) * self.filtered_value)
        return self.filtered_value
```

### Force/Torque Sensor Processing

```python
class ForceTorqueSensor:
    """6-axis force/torque sensor interface and processing"""

    def __init__(self, sensor_name: str, calibration_matrix: np.ndarray = None):
        self.name = sensor_name
        self.calibration_matrix = calibration_matrix or np.eye(6)

        # Raw sensor readings
        self.raw_readings = np.zeros(6)  # [Fx, Fy, Fz, Mx, My, Mz]

        # Calibrated readings
        self.force_torque = np.zeros(6)  # [Fx, Fy, Fz, Mx, My, Mz]

        # Bias compensation
        self.bias = np.zeros(6)
        self.bias_samples = []
        self.bias_sample_count = 0
        self.max_bias_samples = 100

        # Filtering
        self.filters = [LowPassFilter(10.0, 1000.0) for _ in range(6)]

    def calibrate_bias(self):
        """Calibrate sensor bias with current readings"""
        self.bias_samples.append(self.raw_readings.copy())
        self.bias_sample_count += 1

        if self.bias_sample_count >= self.max_bias_samples:
            self.bias = np.mean(self.bias_samples, axis=0)
            self.bias_samples = []
            self.bias_sample_count = 0

    def update(self, raw_readings: np.ndarray):
        """Update with new raw sensor readings"""
        self.raw_readings = raw_readings

        # Apply bias compensation
        compensated_readings = raw_readings - self.bias

        # Apply calibration matrix
        calibrated_readings = self.calibration_matrix @ compensated_readings

        # Apply filtering
        for i in range(6):
            calibrated_readings[i] = self.filters[i].update(calibrated_readings[i])

        self.force_torque = calibrated_readings

    def get_force_magnitude(self) -> float:
        """Get magnitude of force vector"""
        return np.linalg.norm(self.force_torque[:3])

    def get_torque_magnitude(self) -> float:
        """Get magnitude of torque vector"""
        return np.linalg.norm(self.force_torque[3:])

    def is_contact_detected(self, force_threshold: float = 5.0) -> bool:
        """Check if contact is detected based on force threshold"""
        return self.get_force_magnitude() > force_threshold
```

## 3. Power Management System

```python
class BatteryManagementSystem:
    """Battery Management System for humanoid robot"""

    def __init__(self, capacity_ah: float, nominal_voltage: float):
        self.capacity_ah = capacity_ah  # Amp-hours
        self.nominal_voltage = nominal_voltage  # Volts

        # Battery state
        self.voltage = nominal_voltage
        self.current = 0.0
        self.temperature = 25.0  # Celsius
        self.soc = 1.0  # State of Charge (0-1)
        self.soh = 1.0  # State of Health (0-1)

        # Safety limits
        self.max_current = 30.0  # Amps
        self.min_voltage = 0.8 * nominal_voltage
        self.max_voltage = 1.2 * nominal_voltage
        self.max_temperature = 60.0  # Celsius

        # Power consumption tracking
        self.total_energy_consumed = 0.0  # Wh
        self.last_update_time = time.time()

        # Cell balancing (simplified)
        self.cell_voltages = [nominal_voltage/3.7 * 3.7 for _ in range(10)]  # 10 cells

    def update(self, voltage: float, current: float, temperature: float):
        """Update battery state with new measurements"""
        current_time = time.time()
        dt = current_time - self.last_update_time
        self.last_update_time = current_time

        self.voltage = voltage
        self.current = current
        self.temperature = temperature

        # Update state of charge based on current integration
        if dt > 0:
            # Current integration: dSOC = -I * dt / (capacity * 3600)
            delta_soc = -current * dt / (self.capacity_ah * 3600)
            self.soc = np.clip(self.soc + delta_soc, 0.0, 1.0)

        # Update energy consumed
        power = voltage * current  # Watts
        energy = power * dt / 3600  # Wh
        self.total_energy_consumed += energy

        # Check safety conditions
        self._check_safety_limits()

        # Update cell balancing
        self._update_cell_balancing()

    def _check_safety_limits(self):
        """Check battery safety limits"""
        if self.temperature > self.max_temperature:
            print(f"Warning: Battery temperature too high: {self.temperature}°C")

        if abs(self.current) > self.max_current:
            print(f"Warning: Battery current too high: {self.current}A")

        if self.voltage < self.min_voltage:
            print(f"Warning: Battery voltage too low: {self.voltage}V")

        if self.voltage > self.max_voltage:
            print(f"Warning: Battery voltage too high: {self.voltage}V")

    def _update_cell_balancing(self):
        """Update simplified cell balancing"""
        avg_voltage = self.voltage / len(self.cell_voltages)
        for i in range(len(self.cell_voltages)):
            # Simple balancing - adjust towards average
            self.cell_voltages[i] += (avg_voltage - self.cell_voltages[i]) * 0.001

    def get_remaining_time(self, avg_power: float) -> float:
        """Estimate remaining operational time in hours"""
        remaining_energy = self.soc * self.capacity_ah * self.nominal_voltage  # Wh
        if avg_power > 0:
            return remaining_energy / avg_power
        else:
            return float('inf')

    def is_safe_to_operate(self) -> bool:
        """Check if battery is safe to operate"""
        return (self.min_voltage <= self.voltage <= self.max_voltage and
                abs(self.current) <= self.max_current and
                self.temperature <= self.max_temperature and
                self.soc > 0.1)  # At least 10% charge

class PowerDistribution:
    """Power distribution system for humanoid robot"""

    def __init__(self):
        self.rails = {
            '5V': {'voltage': 5.0, 'current_limit': 10.0},
            '12V': {'voltage': 12.0, 'current_limit': 15.0},
            '24V': {'voltage': 24.0, 'current_limit': 20.0}
        }

        self.loads = {}  # {name: {'rail': rail_name, 'current_draw': A}}
        self.current_draws = {rail: 0.0 for rail in self.rails}

        # Power consumption tracking
        self.total_power_consumption = 0.0

    def register_load(self, name: str, rail: str, nominal_current: float):
        """Register a power load"""
        if rail not in self.rails:
            raise ValueError(f"Unknown power rail: {rail}")

        self.loads[name] = {
            'rail': rail,
            'nominal_current': nominal_current,
            'current_draw': 0.0
        }

    def update_load_current(self, name: str, current: float):
        """Update current draw for a specific load"""
        if name not in self.loads:
            return

        load = self.loads[name]
        rail = load['rail']

        # Update rail current draw
        self.current_draws[rail] -= load['current_draw']  # Remove old value
        load['current_draw'] = current
        self.current_draws[rail] += current  # Add new value

    def get_power_consumption(self) -> Dict[str, float]:
        """Get power consumption by rail"""
        consumption = {}
        for rail, current in self.current_draws.items():
            voltage = self.rails[rail]['voltage']
            consumption[rail] = voltage * current
        return consumption

    def is_overloaded(self) -> bool:
        """Check if any power rail is overloaded"""
        for rail, info in self.rails.items():
            if self.current_draws[rail] > info['current_limit']:
                return True
        return False
```

## 4. Communication Protocols Implementation

### CAN Bus Interface

```python
import struct

class CANMessage:
    """CAN message structure"""

    def __init__(self, id: int, data: bytes, is_extended: bool = True):
        self.id = id
        self.data = data
        self.is_extended = is_extended
        self.timestamp = time.time()

class CANBusInterface:
    """CAN bus interface for distributed control"""

    def __init__(self, bus_id: int = 0):
        self.bus_id = bus_id
        self.listeners = {}  # {message_id: [callbacks]}
        self.message_queue = []

    def send_message(self, msg_id: int, data: bytes):
        """Send CAN message"""
        message = CANMessage(msg_id, data)
        # In real implementation, this would send over actual CAN bus
        print(f"CAN Bus {self.bus_id}: Sending ID {msg_id:03X}, Data: {data.hex()}")

    def register_listener(self, msg_id: int, callback):
        """Register callback for specific message ID"""
        if msg_id not in self.listeners:
            self.listeners[msg_id] = []
        self.listeners[msg_id].append(callback)

    def process_received_message(self, msg_id: int, data: bytes):
        """Process received CAN message"""
        if msg_id in self.listeners:
            for callback in self.listeners[msg_id]:
                callback(msg_id, data)

class JointCANInterface:
    """CAN interface for joint control messages"""

    # Message IDs for joint control
    MSG_ID_POSITION_CMD = 0x200  # Position command
    MSG_ID_TORQUE_CMD = 0x201    # Torque command
    MSG_ID_POSITION_FB = 0x100   # Position feedback
    MSG_ID_TORQUE_FB = 0x101     # Torque feedback
    MSG_ID_STATUS = 0x102        # Status message

    def __init__(self, joint_id: int, can_interface: CANBusInterface):
        self.joint_id = joint_id
        self.can = can_interface

        # Register message handlers
        self.can.register_listener(
            self.MSG_ID_POSITION_FB | (joint_id << 8),
            self._handle_position_feedback
        )
        self.can.register_listener(
            self.MSG_ID_TORQUE_FB | (joint_id << 8),
            self._handle_torque_feedback
        )

        # Joint state
        self.position = 0.0
        self.velocity = 0.0
        self.torque = 0.0
        self.temperature = 25.0
        self.status = 0

    def send_position_command(self, position: float):
        """Send position command to joint"""
        # Pack position as 4-byte float
        data = struct.pack('<f', position)
        msg_id = self.MSG_ID_POSITION_CMD | (self.joint_id << 8)
        self.can.send_message(msg_id, data)

    def send_torque_command(self, torque: float):
        """Send torque command to joint"""
        # Pack torque as 4-byte float
        data = struct.pack('<f', torque)
        msg_id = self.MSG_ID_TORQUE_CMD | (self.joint_id << 8)
        self.can.send_message(msg_id, data)

    def _handle_position_feedback(self, msg_id, data):
        """Handle position feedback message"""
        if len(data) >= 8:
            self.position, self.velocity = struct.unpack('<ff', data[:8])

    def _handle_torque_feedback(self, msg_id, data):
        """Handle torque feedback message"""
        if len(data) >= 8:
            self.torque, self.temperature = struct.unpack('<ff', data[:8])
```

## 5. Safety System Implementation

```python
class SafetySystem:
    """Safety system for humanoid robot"""

    def __init__(self):
        self.emergency_stop = False
        self.safety_limits = {}
        self.faults = []
        self.safety_callbacks = []

        # Joint safety limits
        self.joint_limits = {}

        # Timer for safety checks
        self.last_safety_check = time.time()
        self.safety_check_interval = 0.01  # 10ms

    def add_safety_callback(self, callback):
        """Add safety check callback"""
        self.safety_callbacks.append(callback)

    def check_safety(self) -> bool:
        """Perform safety check"""
        current_time = time.time()
        if current_time - self.last_safety_check < self.safety_check_interval:
            return not self.emergency_stop

        self.last_safety_check = current_time

        # Check emergency stop
        if self.emergency_stop:
            return False

        # Run all safety callbacks
        for callback in self.safety_callbacks:
            if not callback():
                self.trigger_emergency_stop(f"Callback {callback.__name__} failed safety check")
                return False

        # Check joint limits
        if not self._check_joint_limits():
            return False

        # Check power system safety
        if not self._check_power_safety():
            return False

        return True

    def _check_joint_limits(self) -> bool:
        """Check if joints are within safe limits"""
        # This would interface with actual joint position data
        return True

    def _check_power_safety(self) -> bool:
        """Check power system safety"""
        # This would interface with actual power system data
        return True

    def trigger_emergency_stop(self, reason: str = "Unknown safety violation"):
        """Trigger emergency stop"""
        self.emergency_stop = True
        self.faults.append({
            'time': time.time(),
            'reason': reason,
            'type': 'EMERGENCY_STOP'
        })
        print(f"EMERGENCY STOP: {reason}")

    def reset_emergency_stop(self):
        """Reset emergency stop condition"""
        self.emergency_stop = False
        print("Emergency stop reset")

    def get_safety_status(self) -> Dict:
        """Get current safety status"""
        return {
            'emergency_stop': self.emergency_stop,
            'faults': self.faults.copy(),
            'joint_limits_ok': self._check_joint_limits(),
            'power_safe': self._check_power_safety()
        }

class JointLimitChecker:
    """Check joint limits for safety"""

    def __init__(self, joint_controller):
        self.joint_controller = joint_controller
        self.joint_limits = {}  # {joint_name: (min_pos, max_pos)}

    def set_joint_limit(self, joint_name: str, min_pos: float, max_pos: float):
        """Set position limits for a joint"""
        self.joint_limits[joint_name] = (min_pos, max_pos)

    def check_limits(self) -> bool:
        """Check if all joints are within limits"""
        states = self.joint_controller.get_joint_states()

        for joint_name, (min_pos, max_pos) in self.joint_limits.items():
            if joint_name in states:
                pos = states[joint_name]['position']
                if pos < min_pos or pos > max_pos:
                    print(f"Joint {joint_name} limit exceeded: {pos} (limits: {min_pos}, {max_pos})")
                    return False
        return True
```

## 6. Hardware Integration Example

```python
class HumanoidHardwareInterface:
    """Complete hardware interface for humanoid robot"""

    def __init__(self):
        # Initialize subsystems
        self.joint_controller = None
        self.imu_processor = None
        self.ft_sensors = {}
        self.power_system = None
        self.can_interface = None
        self.safety_system = SafetySystem()

        # Robot configuration
        self.joint_configs = self._get_default_joint_configs()

        # Initialize all systems
        self._initialize_hardware()

    def _get_default_joint_configs(self) -> Dict[str, JointConfig]:
        """Get default joint configurations for humanoid"""
        configs = {}

        # Left leg joints
        configs['l_hip_yaw'] = JointConfig(
            name='l_hip_yaw', min_position=-0.5, max_position=0.5,
            max_velocity=5.0, max_torque=100.0, gear_ratio=100.0,
            encoder_resolution=4096
        )
        configs['l_hip_roll'] = JointConfig(
            name='l_hip_roll', min_position=-0.4, max_position=1.0,
            max_velocity=5.0, max_torque=100.0, gear_ratio=100.0,
            encoder_resolution=4096
        )
        configs['l_hip_pitch'] = JointConfig(
            name='l_hip_pitch', min_position=-2.0, max_position=0.5,
            max_velocity=5.0, max_torque=150.0, gear_ratio=100.0,
            encoder_resolution=4096
        )
        configs['l_knee'] = JointConfig(
            name='l_knee', min_position=0.0, max_position=2.3,
            max_velocity=5.0, max_torque=150.0, gear_ratio=100.0,
            encoder_resolution=4096
        )
        configs['l_ankle_pitch'] = JointConfig(
            name='l_ankle_pitch', min_position=-0.8, max_position=0.6,
            max_velocity=5.0, max_torque=50.0, gear_ratio=50.0,
            encoder_resolution=4096
        )
        configs['l_ankle_roll'] = JointConfig(
            name='l_ankle_roll', min_position=-0.4, max_position=0.4,
            max_velocity=5.0, max_torque=30.0, gear_ratio=50.0,
            encoder_resolution=4096
        )

        # Right leg joints (similar configuration)
        configs['r_hip_yaw'] = configs['l_hip_yaw']
        configs['r_hip_roll'] = configs['l_hip_roll']
        configs['r_hip_pitch'] = configs['l_hip_pitch']
        configs['r_knee'] = configs['l_knee']
        configs['r_ankle_pitch'] = configs['l_ankle_pitch']
        configs['r_ankle_roll'] = configs['l_ankle_roll']

        # Left arm joints
        configs['l_shoulder_pitch'] = JointConfig(
            name='l_shoulder_pitch', min_position=-2.0, max_position=2.0,
            max_velocity=3.0, max_torque=50.0, gear_ratio=100.0,
            encoder_resolution=4096
        )
        configs['l_shoulder_roll'] = JointConfig(
            name='l_shoulder_roll', min_position=-0.3, max_position=1.5,
            max_velocity=3.0, max_torque=50.0, gear_ratio=100.0,
            encoder_resolution=4096
        )
        configs['l_elbow'] = JointConfig(
            name='l_elbow', min_position=0.0, max_position=2.5,
            max_velocity=3.0, max_torque=40.0, gear_ratio=100.0,
            encoder_resolution=4096
        )

        # Right arm joints (similar configuration)
        configs['r_shoulder_pitch'] = configs['l_shoulder_pitch']
        configs['r_shoulder_roll'] = configs['l_shoulder_roll']
        configs['r_elbow'] = configs['l_elbow']

        return configs

    def _initialize_hardware(self):
        """Initialize all hardware subsystems"""
        # Initialize joint controller
        self.joint_controller = MultiJointController(self.joint_configs)

        # Initialize IMU processor
        self.imu_processor = IMUProcessor(sample_rate=1000.0)

        # Initialize force/torque sensors
        self.ft_sensors['left_foot'] = ForceTorqueSensor('left_foot')
        self.ft_sensors['right_foot'] = ForceTorqueSensor('right_foot')

        # Initialize power system
        self.power_system = BatteryManagementSystem(
            capacity_ah=10.0,  # 10 Ah battery
            nominal_voltage=24.0  # 24V system
        )

        # Initialize CAN interface
        self.can_interface = CANBusInterface(bus_id=0)

        # Add safety checks
        joint_checker = JointLimitChecker(self.joint_controller)
        for joint_name, config in self.joint_configs.items():
            joint_checker.set_joint_limit(
                joint_name, config.min_position, config.max_position
            )

        self.safety_system.add_safety_callback(joint_checker.check_limits)

    def start_control(self):
        """Start all control systems"""
        self.joint_controller.start_control_loop(frequency=1000.0)
        print("Humanoid hardware interface started")

    def stop_control(self):
        """Stop all control systems"""
        self.joint_controller.stop_control_loop()
        print("Humanoid hardware interface stopped")

    def set_joint_positions(self, positions: Dict[str, float]):
        """Set desired joint positions"""
        if self.safety_system.check_safety():
            self.joint_controller.set_joint_positions(positions)
        else:
            print("Safety check failed - joint commands disabled")

    def get_sensor_data(self) -> Dict:
        """Get current sensor data"""
        return {
            'joint_states': self.joint_controller.get_joint_states(),
            'imu_orientation': self.imu_processor.get_euler_angles(),
            'force_torque': {
                name: {
                    'force_magnitude': sensor.get_force_magnitude(),
                    'torque_magnitude': sensor.get_torque_magnitude(),
                    'raw_data': sensor.force_torque
                }
                for name, sensor in self.ft_sensors.items()
            },
            'power_status': {
                'soc': self.power_system.soc,
                'voltage': self.power_system.voltage,
                'current': self.power_system.current,
                'temperature': self.power_system.temperature
            },
            'safety_status': self.safety_system.get_safety_status()
        }

# Example usage
def main():
    """Example usage of the humanoid hardware interface"""
    print("Initializing humanoid hardware interface...")

    # Create hardware interface
    robot = HumanoidHardwareInterface()

    # Start control systems
    robot.start_control()

    # Example: Set some joint positions
    target_positions = {
        'l_hip_pitch': -0.5,
        'r_hip_pitch': -0.5,
        'l_knee': 1.0,
        'r_knee': 1.0
    }

    print("Setting joint positions...")
    robot.set_joint_positions(target_positions)

    # Get sensor data
    sensor_data = robot.get_sensor_data()
    print(f"Joint states: {list(sensor_data['joint_states'].keys())}")
    print(f"IMU orientation: {sensor_data['imu_orientation']}")
    print(f"Power SOC: {sensor_data['power_status']['soc']:.2%}")

    # Stop control systems
    robot.stop_control()
    print("Hardware interface stopped")

if __name__ == "__main__":
    main()
```

## 7. Thermal Management Implementation

```python
class ThermalManager:
    """Thermal management system for humanoid robot"""

    def __init__(self):
        self.components = {}  # {name: {'temperature': C, 'power': W, 'max_temp': C}}
        self.fans = {}  # {name: {'speed': 0-1, 'component': component_name}}
        self.last_update = time.time()

    def register_component(self, name: str, max_temp: float, thermal_mass: float = 1.0):
        """Register a component for thermal monitoring"""
        self.components[name] = {
            'temperature': 25.0,  # Starting temperature
            'power': 0.0,         # Current power dissipation
            'max_temp': max_temp,
            'thermal_mass': thermal_mass,  # Thermal mass (J/K)
            'thermal_resistance': 10.0     # Thermal resistance (K/W)
        }

    def register_fan(self, name: str, component_name: str):
        """Register a fan for cooling a component"""
        self.fans[name] = {
            'speed': 0.0,
            'component': component_name,
            'max_flow': 0.1  # m³/s
        }

    def update_power(self, component_name: str, power: float):
        """Update power dissipation for a component"""
        if component_name in self.components:
            self.components[component_name]['power'] = power

    def update(self):
        """Update thermal model"""
        current_time = time.time()
        dt = current_time - self.last_update
        self.last_update = current_time

        if dt <= 0:
            return

        # Update temperature for each component
        for name, comp in self.components.items():
            power = comp['power']
            thermal_mass = comp['thermal_mass']
            thermal_res = comp['thermal_resistance']
            current_temp = comp['temperature']

            # Heat transfer to environment (simplified)
            # Assuming ambient temperature of 25°C
            ambient_temp = 25.0
            cooling_effect = 0.0

            # Find associated fans
            for fan_name, fan in self.fans.items():
                if fan['component'] == name:
                    # Fan cooling effect (simplified model)
                    cooling_effect += fan['speed'] * 5.0  # 5 K reduction per 100% fan speed

            # Temperature change due to power dissipation and cooling
            temp_change = (power * thermal_res - (current_temp - ambient_temp) + cooling_effect) * dt / thermal_mass
            new_temp = current_temp + temp_change

            # Apply temperature limits
            comp['temperature'] = np.clip(new_temp, ambient_temp, comp['max_temp'])

            # Check for thermal limits
            if new_temp > comp['max_temp'] * 0.9:
                print(f"Warning: Component {name} temperature high: {new_temp:.1f}°C")

    def get_temperature(self, component_name: str) -> float:
        """Get temperature of a component"""
        if component_name in self.components:
            return self.components[component_name]['temperature']
        return 0.0

    def set_fan_speed(self, fan_name: str, speed: float):
        """Set fan speed (0.0 to 1.0)"""
        if fan_name in self.fans:
            self.fans[fan_name]['speed'] = np.clip(speed, 0.0, 1.0)
```

## Summary

This implementation provides comprehensive hardware control systems for humanoid robots, including:

1. **Actuator Control**: Servo motor and Series Elastic Actuator (SEA) control systems with PID control
2. **Sensor Processing**: IMU and force/torque sensor interfaces with filtering and calibration
3. **Power Management**: Battery Management System (BMS) and power distribution networks
4. **Communication**: CAN bus interface for distributed control
5. **Safety Systems**: Emergency stop, limit checking, and fault detection
6. **Thermal Management**: Component temperature monitoring and cooling control
7. **Integration**: Complete hardware interface combining all subsystems

The code is structured to be modular and extensible, allowing for easy adaptation to specific humanoid robot platforms and requirements. Each component can be customized and integrated with real hardware interfaces as needed.