---
title: 6.5 Physics Simulation Implementation
sidebar_position: 23
---

# 6.5 Physics Simulation Implementation

## Learning Objectives
- Implement rigid body dynamics and multi-body systems
- Design collision detection and response algorithms
- Apply numerical integration methods for physics simulation
- Integrate joint constraints and environmental interactions
- Validate physics simulation accuracy and performance

## Introduction

Physics simulation implementation transforms theoretical concepts into executable code that can model complex robotic systems in real-time. This process involves not only implementing the core physics equations but also addressing practical challenges such as numerical stability, computational efficiency, and integration with existing robotic software stacks. The implementation must balance simulation accuracy with computational performance while ensuring that simulated results remain representative of real-world behavior.

Effective physics simulation implementation requires careful consideration of software architecture, numerical methods, and system integration. The simulation system must interface with real-time operating systems, handle numerical approximations, and maintain stability in the presence of constraint violations and contact events. Implementation choices significantly impact the performance, reliability, and maintainability of the resulting simulation system.

This section provides practical examples of physics simulation implementation using common frameworks and tools in robotics, with a focus on humanoid-specific challenges such as complex contact dynamics, joint constraints, and real-time performance requirements.

## 2. Rigid Body Dynamics Implementation

### Core Rigid Body Class

A fundamental rigid body implementation includes all necessary properties for physics simulation:

```python
import numpy as np
from scipy.spatial.transform import Rotation as R

class RigidBody:
    def __init__(self, mass=1.0, inertia_tensor=None, position=None, orientation=None):
        # Mass properties
        self.mass = mass
        self.mass_inv = 1.0 / mass if mass > 0 else 0.0

        if inertia_tensor is None:
            # Default to identity matrix (unit sphere)
            self.inertia_body = np.eye(3)
        else:
            self.inertia_body = np.array(inertia_tensor)

        # Inverse inertia in body frame
        self.inertia_body_inv = np.linalg.inv(self.inertia_body) if mass > 0 else np.zeros((3, 3))

        # State variables
        self.position = np.array(position) if position is not None else np.zeros(3)
        self.orientation = np.array(orientation) if orientation is not None else np.array([1, 0, 0, 0])  # w, x, y, z
        self.linear_velocity = np.zeros(3)
        self.angular_velocity = np.zeros(3)  # In world frame

        # Accumulated forces and torques
        self.force = np.zeros(3)
        self.torque = np.zeros(3)  # In world frame

        # Derived quantities
        self.linear_momentum = self.mass * self.linear_velocity
        self.angular_momentum = np.zeros(3)  # In world frame

    def get_inertia_world(self):
        """
        Get inertia tensor in world frame using current orientation
        """
        # Convert quaternion to rotation matrix
        r = R.from_quat([self.orientation[1], self.orientation[2], self.orientation[3], self.orientation[0]])
        rotation_matrix = r.as_matrix()

        # Transform inertia tensor to world frame: I_world = R * I_body * R^T
        return rotation_matrix @ self.inertia_body @ rotation_matrix.T

    def get_inertia_world_inv(self):
        """
        Get inverse inertia tensor in world frame
        """
        r = R.from_quat([self.orientation[1], self.orientation[2], self.orientation[3], self.orientation[0]])
        rotation_matrix = r.as_matrix()

        # I_world_inv = R * I_body_inv * R^T
        return rotation_matrix @ self.inertia_body_inv @ rotation_matrix.T

    def apply_force(self, force, point=None):
        """
        Apply force at a specific point (or at center of mass if point not specified)
        """
        self.force += force

        if point is not None:
            # Calculate torque: τ = r × F
            r = point - self.position
            self.torque += np.cross(r, force)

    def apply_torque(self, torque):
        """
        Apply torque in world frame
        """
        self.torque += torque

    def clear_forces(self):
        """
        Clear accumulated forces and torques
        """
        self.force = np.zeros(3)
        self.torque = np.zeros(3)

    def update_kinematics(self, dt):
        """
        Update position and orientation based on velocities
        """
        # Update position
        self.position += self.linear_velocity * dt

        # Update orientation using quaternion derivative
        # q_dot = 0.5 * w_quat * q, where w_quat = [0, ω_x, ω_y, ω_z]
        omega_quat = np.array([0.0, *self.angular_velocity])
        quat_derivative = self._quaternion_multiply(omega_quat, self.orientation) * 0.5

        self.orientation += quat_derivative * dt
        # Normalize quaternion to prevent drift
        self.orientation = self.orientation / np.linalg.norm(self.orientation)

    def _quaternion_multiply(self, q1, q2):
        """
        Multiply two quaternions: q1 * q2
        """
        w1, x1, y1, z1 = q1
        w2, x2, y2, z2 = q2

        w = w1*w2 - x1*x2 - y1*y2 - z1*z2
        x = w1*x2 + x1*w2 + y1*z2 - z1*y2
        y = w1*y2 - x1*z2 + y1*w2 + z1*x2
        z = w1*z2 + x1*y2 - y1*x2 + z1*w2

        return np.array([w, x, y, z])

class RigidBodyDynamics:
    def __init__(self, gravity=np.array([0, 0, -9.81])):
        self.gravity = gravity
        self.bodies = []

    def add_body(self, body):
        """
        Add a rigid body to the simulation
        """
        self.bodies.append(body)

    def integrate_euler(self, dt):
        """
        Integrate rigid body dynamics using Euler integration
        """
        for body in self.bodies:
            # Apply gravity
            gravity_force = body.mass * self.gravity
            body.apply_force(gravity_force)

            # Linear motion: F = ma => a = F/m
            linear_acceleration = body.force * body.mass_inv
            body.linear_velocity += linear_acceleration * dt

            # Angular motion: τ = Iα + ω×(Iω) => α = I⁻¹(τ - ω×(Iω))
            # In world frame: τ = dL/dt = I(dω/dt) + ω×(Iω)
            inertia_world_inv = body.get_inertia_world_inv()

            # Calculate ω×(Iω) term
            inertia_omega = body.get_inertia_world() @ body.angular_velocity
            omega_cross_inertia_omega = np.cross(body.angular_velocity, inertia_omega)

            # Calculate angular acceleration
            angular_acceleration = inertia_world_inv @ (body.torque - omega_cross_inertia_omega)
            body.angular_velocity += angular_acceleration * dt

            # Update kinematics
            body.update_kinematics(dt)

            # Clear forces for next step
            body.clear_forces()

    def integrate_rk4(self, dt):
        """
        Integrate using 4th-order Runge-Kutta method for better accuracy
        """
        # Save current state
        saved_states = []
        for body in self.bodies:
            saved_states.append({
                'position': body.position.copy(),
                'orientation': body.orientation.copy(),
                'linear_velocity': body.linear_velocity.copy(),
                'angular_velocity': body.angular_velocity.copy()
            })

        # Calculate k1 (current derivatives)
        k1 = self._calculate_derivatives()

        # Calculate k2 (half-step state)
        self._apply_derivatives(k1, dt/2)
        k2 = self._calculate_derivatives()

        # Restore and calculate k3
        self._restore_states(saved_states)
        self._apply_derivatives(k2, dt/2)
        k3 = self._calculate_derivatives()

        # Restore and calculate k4
        self._restore_states(saved_states)
        self._apply_derivatives(k3, dt)
        k4 = self._calculate_derivatives()

        # Final integration
        self._restore_states(saved_states)
        weighted_derivatives = {}
        for key in k1:
            weighted_derivatives[key] = (k1[key] + 2*k2[key] + 2*k3[key] + k4[key]) / 6.0

        self._apply_derivatives(weighted_derivatives, dt)

    def _calculate_derivatives(self):
        """
        Calculate state derivatives for RK4 integration
        """
        derivatives = {}
        derivatives['positions'] = []
        derivatives['orientations'] = []
        derivatives['linear_velocities'] = []
        derivatives['angular_velocities'] = []
        derivatives['linear_accelerations'] = []
        derivatives['angular_accelerations'] = []

        for body in self.bodies:
            # Apply gravity
            gravity_force = body.mass * self.gravity
            body.apply_force(gravity_force)

            # Linear acceleration
            linear_acceleration = body.force * body.mass_inv

            # Angular acceleration
            inertia_world_inv = body.get_inertia_world_inv()
            inertia_omega = body.get_inertia_world() @ body.angular_velocity
            omega_cross_inertia_omega = np.cross(body.angular_velocity, inertia_omega)
            angular_acceleration = inertia_world_inv @ (body.torque - omega_cross_inertia_omega)

            derivatives['positions'].append(body.linear_velocity)
            derivatives['linear_velocities'].append(linear_acceleration)
            derivatives['angular_velocities'].append(angular_acceleration)

            # Orientation derivative (quaternion)
            omega_quat = np.array([0.0, *body.angular_velocity])
            quat_derivative = body._quaternion_multiply(omega_quat, body.orientation) * 0.5
            derivatives['orientations'].append(quat_derivative)

            derivatives['angular_accelerations'].append(angular_acceleration)

            # Clear forces for derivative calculation
            body.clear_forces()

        return derivatives

    def _apply_derivatives(self, derivatives, dt):
        """
        Apply derivatives to update state
        """
        for i, body in enumerate(self.bodies):
            body.position += derivatives['positions'][i] * dt
            body.orientation += derivatives['orientations'][i] * dt
            body.orientation = body.orientation / np.linalg.norm(body.orientation)  # Normalize
            body.linear_velocity += derivatives['linear_velocities'][i] * dt
            body.angular_velocity += derivatives['angular_accelerations'][i] * dt

    def _restore_states(self, saved_states):
        """
        Restore saved body states
        """
        for i, body in enumerate(self.bodies):
            body.position = saved_states[i]['position']
            body.orientation = saved_states[i]['orientation']
            body.linear_velocity = saved_states[i]['linear_velocity']
            body.angular_velocity = saved_states[i]['angular_velocity']
```

## 3. Multi-Body System Implementation

### Articulated Body Algorithm

```python
class Joint:
    def __init__(self, joint_type='revolute', axis=np.array([0, 0, 1]), limits=None):
        self.type = joint_type  # 'revolute', 'prismatic', 'fixed', 'ball'
        self.axis = axis / np.linalg.norm(axis) if np.linalg.norm(axis) > 0 else np.array([0, 0, 1])
        self.limits = limits  # [min, max] for position limits
        self.position = 0.0
        self.velocity = 0.0
        self.acceleration = 0.0
        self.torque = 0.0  # Applied torque/force

    def get_motion_subspace(self):
        """
        Get motion subspace matrix S that relates joint velocity to spatial velocity
        """
        if self.type == 'revolute':
            # S = [0; axis] for revolute joint (angular part first in spatial vector)
            return np.array([0, 0, 0, self.axis[0], self.axis[1], self.axis[2]])
        elif self.type == 'prismatic':
            # S = [axis; 0] for prismatic joint (linear part first in spatial vector)
            return np.array([self.axis[0], self.axis[1], self.axis[2], 0, 0, 0])
        else:
            return np.zeros(6)

class Link:
    def __init__(self, mass=1.0, inertia=None, transform=np.eye(4)):
        self.mass = mass
        self.inertia = inertia if inertia is not None else np.eye(3)  # 3x3 inertia tensor
        self.transform = transform  # 4x4 transformation matrix from parent
        self.spatial_inertia = self._compute_spatial_inertia()

    def _compute_spatial_inertia(self):
        """
        Compute 6x6 spatial inertia matrix from mass and 3x3 inertia tensor
        """
        I = self.inertia
        m = self.mass

        # Spatial inertia matrix: [m*I_3x3, 0; 0, I]
        # But we need to account for the cross-coupling terms
        spatial_inertia = np.zeros((6, 6))

        # Upper-left 3x3: m * identity
        spatial_inertia[0:3, 0:3] = m * np.eye(3)

        # Lower-right 3x3: rotational inertia
        spatial_inertia[3:6, 3:6] = I

        return spatial_inertia

class ArticulatedBody:
    def __init__(self, links, joints, base_transform=np.eye(4)):
        self.links = links
        self.joints = joints
        self.base_transform = base_transform
        self.n_dof = len(joints)

        # State variables
        self.q = np.zeros(self.n_dof)  # Joint positions
        self.q_dot = np.zeros(self.n_dof)  # Joint velocities
        self.q_ddot = np.zeros(self.n_dof)  # Joint accelerations
        self.tau = np.zeros(self.n_dof)  # Joint torques

        # Intermediate calculations for ABA
        self.v = [np.zeros(6) for _ in range(self.n_dof + 1)]  # Spatial velocities
        self.a = [np.zeros(6) for _ in range(self.n_dof + 1)]  # Spatial accelerations
        self.p = [np.zeros(6) for _ in range(self.n_dof + 1)]  # Spatial momenta
        self.U = [np.zeros(6) for _ in range(self.n_dof + 1)]  # Articulated inertias
        self.u = np.zeros(self.n_dof)  # Bias forces
        self.I = [np.zeros((6, 6)) for _ in range(self.n_dof + 1)]  # Spatial inertias

    def forward_dynamics_aba(self, tau_external=None):
        """
        Compute forward dynamics using Articulated Body Algorithm (ABA)
        """
        if tau_external is None:
            tau_external = np.zeros(self.n_dof)

        # Initialize base conditions
        self._initialize_base()

        # Forward pass: compute velocities and articulated inertias
        for i in range(self.n_dof):
            self._forward_pass(i)

        # Backward pass: compute articulated inertias and bias forces
        for i in range(self.n_dof - 1, -1, -1):
            self._backward_pass(i, tau_external[i])

        # Forward pass: compute accelerations
        self._compute_accelerations()

        return self.q_ddot

    def _initialize_base(self):
        """
        Initialize base conditions for ABA
        """
        # Base spatial velocity and acceleration
        self.v[0] = np.zeros(6)  # Base velocity
        self.a[0] = np.array([0, 0, 0, -9.81, 0, 0])  # Gravity in spatial form [v_ω]

    def _forward_pass(self, i):
        """
        Forward pass of ABA: compute velocities
        """
        # Joint motion subspace
        S_i = self.joints[i].get_motion_subspace()

        # Transformation from parent to current link
        # In practice, this would involve the link transformation

        # Spatial velocity of current link
        self.v[i + 1] = self.v[i] + S_i * self.q_dot[i]

        # Compute spatial inertia of current link
        self.I[i + 1] = self.links[i].spatial_inertia

    def _backward_pass(self, i, tau_i):
        """
        Backward pass of ABA: compute articulated inertias and bias forces
        """
        # Joint motion subspace
        S_i = self.joints[i].get_motion_subspace()

        # Articulated inertia
        self.U[i] = self.I[i + 1] @ S_i

        # Joint inertia
        d_i = S_i.T @ self.U[i]

        # Bias force
        v_cross = self._spatial_cross_product(self.v[i + 1])
        self.u[i] = tau_i - S_i.T @ (self.I[i + 1] @ (v_cross @ self.U[i]) +
                                   self._spatial_cross_product(self.v[i + 1]) @
                                   self.I[i + 1] @ self.v[i + 1])

    def _compute_accelerations(self):
        """
        Final forward pass to compute joint accelerations
        """
        for i in range(self.n_dof):
            S_i = self.joints[i].get_motion_subspace()

            # Compute joint acceleration
            self.q_ddot[i] = (self.tau[i] - S_i.T @ self.p[i]) / (S_i.T @ self.I[i + 1] @ S_i)

    def _spatial_cross_product(self, v):
        """
        Compute spatial cross product matrix for spatial velocity v
        """
        v_linear = v[0:3]
        v_angular = v[3:6]

        # Cross product matrix for spatial vectors
        X = np.zeros((6, 6))

        # Upper left 3x3: [ω×]
        X[0:3, 0:3] = self._skew_symmetric(v_angular)

        # Upper right 3x3: [v×]
        X[0:3, 3:6] = self._skew_symmetric(v_linear)

        # Lower left 3x3: [ω×]
        X[3:6, 0:3] = self._skew_symmetric(v_angular)

        # Lower right 3x3: [ω×]
        X[3:6, 3:6] = self._skew_symmetric(v_angular)

        return X

    def _skew_symmetric(self, v):
        """
        Create skew-symmetric matrix from vector v
        """
        return np.array([
            [0, -v[2], v[1]],
            [v[2], 0, -v[0]],
            [-v[1], v[0], 0]
        ])

    def inverse_dynamics(self, q_desired, qd_desired, qdd_desired):
        """
        Compute required joint torques using inverse dynamics
        """
        # This would implement the inverse of forward dynamics
        # For now, return placeholder
        return np.zeros(self.n_dof)
```

## 4. Collision Detection Implementation

### Broad-Phase Collision Detection

```python
class BoundingVolumeHierarchy:
    def __init__(self):
        self.root = None
        self.bodies = []

    def build_tree(self, bodies):
        """
        Build BVH tree from list of bodies
        """
        self.bodies = bodies
        if len(bodies) == 0:
            return None

        # Create leaf nodes for each body
        nodes = []
        for i, body in enumerate(bodies):
            node = BVHNode()
            node.bounding_volume = self._compute_bounding_volume(body)
            node.body_index = i
            node.is_leaf = True
            nodes.append(node)

        # Build tree recursively
        self.root = self._build_recursive(nodes)
        return self.root

    def _build_recursive(self, nodes):
        """
        Recursively build BVH tree
        """
        if len(nodes) == 1:
            return nodes[0]

        if len(nodes) == 2:
            # Create internal node
            internal_node = BVHNode()
            internal_node.left = nodes[0]
            internal_node.right = nodes[1]
            # Compute bounding volume that encompasses both children
            internal_node.bounding_volume = self._merge_bounding_volumes(
                nodes[0].bounding_volume,
                nodes[1].bounding_volume
            )
            return internal_node

        # Split nodes based on some heuristic (e.g., longest axis)
        # For simplicity, split down the middle
        mid = len(nodes) // 2
        left_nodes = nodes[:mid]
        right_nodes = nodes[mid:]

        internal_node = BVHNode()
        internal_node.left = self._build_recursive(left_nodes)
        internal_node.right = self._build_recursive(right_nodes)
        internal_node.bounding_volume = self._merge_bounding_volumes(
            internal_node.left.bounding_volume,
            internal_node.right.bounding_volume
        )

        return internal_node

    def _compute_bounding_volume(self, body):
        """
        Compute bounding volume for a body
        """
        # For simplicity, use axis-aligned bounding box
        # In practice, this would be more sophisticated
        center = body.position
        # Assuming some characteristic size
        size = 0.5  # meters
        return {
            'min': center - size,
            'max': center + size,
            'center': center,
            'size': size
        }

    def _merge_bounding_volumes(self, bv1, bv2):
        """
        Merge two bounding volumes
        """
        min_point = np.minimum(bv1['min'], bv2['min'])
        max_point = np.maximum(bv1['max'], bv2['max'])
        center = (min_point + max_point) / 2
        size = np.linalg.norm(max_point - min_point) / 2

        return {
            'min': min_point,
            'max': max_point,
            'center': center,
            'size': size
        }

    def broad_phase_collision_detection(self):
        """
        Perform broad-phase collision detection using BVH
        """
        if self.root is None:
            return []

        potential_collisions = []
        self._traverse_tree(self.root, potential_collisions)
        return potential_collisions

    def _traverse_tree(self, node, collisions):
        """
        Traverse BVH tree to find potential collisions
        """
        if node.is_leaf:
            # This is a body, no further traversal needed
            return

        # Check if left and right subtrees' bounding volumes intersect
        if self._bounding_volumes_intersect(node.left.bounding_volume,
                                          node.right.bounding_volume):
            # Add to potential collisions if both are leaves
            if node.left.is_leaf and node.right.is_leaf:
                collisions.append((node.left.body_index, node.right.body_index))

            # Continue traversal
            if not node.left.is_leaf:
                self._traverse_tree(node.left, collisions)
            if not node.right.is_leaf:
                self._traverse_tree(node.right, collisions)

    def _bounding_volumes_intersect(self, bv1, bv2):
        """
        Check if two bounding volumes intersect (AABB intersection)
        """
        return (bv1['min'][0] <= bv2['max'][0] and bv1['max'][0] >= bv2['min'][0] and
                bv1['min'][1] <= bv2['max'][1] and bv1['max'][1] >= bv2['min'][1] and
                bv1['min'][2] <= bv2['max'][2] and bv1['max'][2] >= bv2['min'][2])

class BVHNode:
    def __init__(self):
        self.bounding_volume = None
        self.left = None
        self.right = None
        self.body_index = -1  # For leaf nodes
        self.is_leaf = False
```

### Narrow-Phase Collision Detection

```python
class CollisionDetector:
    def __init__(self):
        pass

    def detect_collision(self, body1, body2):
        """
        Detect collision between two bodies using GJK algorithm
        """
        # For now, implement a simple sphere-sphere test
        # In practice, this would use GJK or other advanced algorithms
        pos1 = body1.position
        pos2 = body2.position
        dist = np.linalg.norm(pos2 - pos1)

        # Assume spherical shapes with radii
        radius1 = self._get_effective_radius(body1)
        radius2 = self._get_effective_radius(body2)

        if dist < radius1 + radius2:
            # Collision detected
            normal = (pos2 - pos1) / dist if dist > 1e-6 else np.array([1, 0, 0])
            penetration = (radius1 + radius2) - dist

            return {
                'collision': True,
                'normal': normal,
                'penetration': penetration,
                'contact_point1': pos1 + normal * radius1,
                'contact_point2': pos2 - normal * radius2
            }

        return {'collision': False}

    def _get_effective_radius(self, body):
        """
        Get effective radius for collision detection
        In practice, this would be more sophisticated
        """
        # For now, use a fixed radius or compute from inertia
        # A more realistic approach would use bounding sphere of the body
        return 0.1  # 10 cm default

    def gjk_collision_detection(self, shape1, shape2):
        """
        Implement Gilbert-Johnson-Keerthi algorithm for convex shapes
        """
        # Initialize simplex
        simplex = []

        # Initial direction
        direction = shape2.center - shape1.center
        if np.linalg.norm(direction) < 1e-6:
            direction = np.array([1, 0, 0])

        # Get initial point
        support_point = self._gjk_support(shape1, shape2, direction)
        simplex.append(support_point)

        # Invert direction for next iteration
        direction = -direction

        # Main GJK loop
        for _ in range(100):  # Max iterations
            # Get new point in Minkowski difference
            support_point = self._gjk_support(shape1, shape2, direction)

            # If support point is not expanding the simplex, no collision
            if np.dot(support_point, direction) <= 0:
                return False  # No collision

            # Add point to simplex
            simplex.append(support_point)

            # Check if origin is contained in simplex
            if self._gjk_do_simplex(simplex, direction):
                return True  # Collision detected

        return False  # Max iterations reached, assume no collision

    def _gjk_support(self, shape1, shape2, direction):
        """
        Support function for GJK: find point in Minkowski difference farthest in direction
        """
        # Support point in shape1 in direction
        p1 = shape1.support(direction)
        # Support point in shape2 in opposite direction
        p2 = shape2.support(-direction)
        # Minkowski difference
        return p1 - p2

    def _gjk_do_simplex(self, simplex, direction):
        """
        Process simplex and update direction for GJK
        """
        if len(simplex) == 2:
            # Line case
            return self._gjk_line_case(simplex, direction)
        elif len(simplex) == 3:
            # Triangle case
            return self._gjk_triangle_case(simplex, direction)
        elif len(simplex) == 4:
            # Tetrahedron case
            return self._gjk_tetrahedron_case(simplex, direction)

        return False

    def _gjk_line_case(self, simplex, direction):
        """
        Handle line case in GJK
        """
        b, a = simplex  # a is last added point
        ab = b - a
        ao = -a

        if np.dot(ab, ao) > 0:
            # Update direction to be perpendicular to ab towards origin
            direction[:] = np.cross(np.cross(ab, ao), ab)
        else:
            # Origin is not in this direction, replace simplex with point a
            simplex[:] = [a]
            direction[:] = ao

        return False  # Continue algorithm

    def _gjk_triangle_case(self, simplex, direction):
        """
        Handle triangle case in GJK
        """
        c, b, a = simplex  # a is last added point
        ab = b - a
        ac = c - a
        ao = -a

        abc = np.cross(ab, ac)  # Normal to triangle plane

        # Check which direction to move
        if np.dot(np.cross(abc, ac), ao) > 0:
            if np.dot(ac, ao) > 0:
                # Remove b, simplex becomes ac
                simplex[:] = [c, a]
                direction[:] = np.cross(np.cross(ac, ao), ac)
            else:
                if np.dot(ab, ao) > 0:
                    # Remove c, simplex becomes ab
                    simplex[:] = [b, a]
                    direction[:] = np.cross(np.cross(ab, ao), ab)
                else:
                    # Origin is closest to vertex a
                    simplex[:] = [a]
                    direction[:] = ao
        else:
            if np.dot(np.cross(ab, abc), ao) > 0:
                if np.dot(ab, ao) > 0:
                    # Remove c, simplex becomes ab
                    simplex[:] = [b, a]
                    direction[:] = np.cross(np.cross(ab, ao), ab)
                else:
                    # Origin is closest to vertex a
                    simplex[:] = [a]
                    direction[:] = ao
            else:
                if np.dot(abc, ao) > 0:
                    # Remove c, keep triangle abc (need to implement tetrahedron)
                    pass  # Simplified
                else:
                    # Remove b, keep triangle acb
                    pass  # Simplified

        return False  # Continue algorithm

    def _gjk_tetrahedron_case(self, simplex, direction):
        """
        Handle tetrahedron case in GJK
        """
        d, c, b, a = simplex  # a is last added point
        # In 3D, if origin is inside tetrahedron, we have collision
        # This is a simplified implementation
        return True  # Collision detected
```

## 5. Contact Response Implementation

### Sequential Impulse Solver

```python
class ContactSolver:
    def __init__(self, restitution=0.2, friction_coefficient=0.5, max_iterations=10):
        self.restitution = restitution
        self.friction_coefficient = friction_coefficient
        self.max_iterations = max_iterations

    def solve_contacts(self, bodies, contacts, dt):
        """
        Solve contact constraints using sequential impulses
        """
        for _ in range(self.max_iterations):
            for contact in contacts:
                self._solve_single_contact(bodies, contact, dt)

    def _solve_single_contact(self, bodies, contact, dt):
        """
        Solve a single contact constraint
        """
        body1_idx, body2_idx = contact['body_indices']
        body1 = bodies[body1_idx]
        body2 = bodies[body2_idx]
        normal = contact['normal']

        # Calculate relative velocity at contact point
        r1 = contact['point1'] - body1.position
        r2 = contact['point2'] - body2.position

        v1 = body1.linear_velocity + np.cross(body1.angular_velocity, r1)
        v2 = body2.linear_velocity + np.cross(body2.angular_velocity, r2)
        relative_velocity = v2 - v1

        # Velocity along normal
        vel_along_normal = np.dot(relative_velocity, normal)

        # Only resolve if objects are approaching
        if vel_along_normal > 0:
            return

        # Calculate restitution coefficient
        e = self.restitution

        # Calculate impulse magnitude for normal
        mass_sum = body1.mass_inv + body2.mass_inv

        # Angular effects
        r1_cross_n = np.cross(r1, normal)
        r2_cross_n = np.cross(r2, normal)

        # Inertia terms
        body1_inv_inertia = body1.get_inertia_world_inv()
        body2_inv_inertia = body2.get_inertia_world_inv()

        angular_term1 = body1_inv_inertia @ r1_cross_n
        angular_term1 = np.dot(normal, np.cross(angular_term1, r1))
        angular_term2 = body2_inv_inertia @ r2_cross_n
        angular_term2 = np.dot(normal, np.cross(angular_term2, r2))

        denominator = mass_sum + angular_term1 + angular_term2

        if denominator < 1e-6:  # Prevent division by zero
            return

        # Calculate impulse magnitude
        j = -(1 + e) * vel_along_normal / denominator
        impulse = j * normal

        # Apply normal impulse
        body1.linear_velocity -= impulse * body1.mass_inv
        body1.angular_velocity -= body1_inv_inertia @ np.cross(r1, impulse)

        body2.linear_velocity += impulse * body2.mass_inv
        body2.angular_velocity += body2_inv_inertia @ np.cross(r2, impulse)

        # Apply friction
        self._apply_friction(bodies, contact, dt)

    def _apply_friction(self, bodies, contact, dt):
        """
        Apply friction impulses to reduce tangential velocity
        """
        body1_idx, body2_idx = contact['body_indices']
        body1 = bodies[body1_idx]
        body2 = bodies[body2_idx]
        normal = contact['normal']

        r1 = contact['point1'] - body1.position
        r2 = contact['point2'] - body2.position

        v1 = body1.linear_velocity + np.cross(body1.angular_velocity, r1)
        v2 = body2.linear_velocity + np.cross(body2.angular_velocity, r2)
        relative_velocity = v2 - v1

        # Tangential velocity
        tangential_velocity = relative_velocity - np.dot(relative_velocity, normal) * normal
        tangential_speed = np.linalg.norm(tangential_velocity)

        if tangential_speed < 1e-6:
            return

        tangent = tangential_velocity / tangential_speed

        # Calculate friction impulse magnitude
        mass_sum = body1.mass_inv + body2.mass_inv

        r1_cross_t = np.cross(r1, tangent)
        r2_cross_t = np.cross(r2, tangent)

        body1_inv_inertia = body1.get_inertia_world_inv()
        body2_inv_inertia = body2.get_inertia_world_inv()

        angular_term1 = body1_inv_inertia @ r1_cross_t
        angular_term1 = np.dot(tangent, np.cross(angular_term1, r1))
        angular_term2 = body2_inv_inertia @ r2_cross_t
        angular_term2 = np.dot(tangent, np.cross(angular_term2, r2))

        denominator = mass_sum + angular_term1 + angular_term2

        if denominator < 1e-6:
            return

        # Calculate friction impulse
        jt = -tangential_speed / denominator
        friction_magnitude = abs(jt)

        # Clamp friction by Coulomb friction model
        normal_impulse_magnitude = abs(np.dot(relative_velocity, normal))
        max_friction = self.friction_coefficient * normal_impulse_magnitude
        friction_magnitude = min(friction_magnitude, max_friction)

        friction_impulse = friction_magnitude * tangent

        # Apply friction impulse
        body1.linear_velocity -= friction_impulse * body1.mass_inv
        body1.angular_velocity -= body1_inv_inertia @ np.cross(r1, friction_impulse)

        body2.linear_velocity += friction_impulse * body2.mass_inv
        body2.angular_velocity += body2_inv_inertia @ np.cross(r2, friction_impulse)

class ConstraintSolver:
    def __init__(self):
        self.contact_solver = ContactSolver()
        self.joint_constraints = []

    def add_joint_constraint(self, joint):
        """
        Add a joint constraint to the solver
        """
        self.joint_constraints.append(joint)

    def solve_all_constraints(self, bodies, contacts, dt):
        """
        Solve all constraints in the system
        """
        # Solve contacts
        self.contact_solver.solve_contacts(bodies, contacts, dt)

        # Solve joint constraints
        self._solve_joint_constraints(bodies, dt)

    def _solve_joint_constraints(self, bodies, dt):
        """
        Solve joint constraints using constraint forces
        """
        # For each joint constraint, apply corrective forces
        for joint in self.joint_constraints:
            self._solve_single_joint_constraint(bodies, joint, dt)

    def _solve_single_joint_constraint(self, bodies, joint, dt):
        """
        Solve a single joint constraint
        """
        # This would implement specific joint constraint solving
        # based on the joint type and limits
        pass
```

## 6. Numerical Integration Implementation

### Advanced Integration Methods

```python
class Integrator:
    def __init__(self, method='euler'):
        self.method = method
        self.dt = 0.001  # Default time step

    def integrate(self, bodies, forces, dt):
        """
        Integrate the system using the specified method
        """
        if self.method == 'euler':
            return self._integrate_euler(bodies, forces, dt)
        elif self.method == 'rk4':
            return self._integrate_rk4(bodies, forces, dt)
        elif self.method == 'verlet':
            return self._integrate_verlet(bodies, forces, dt)
        elif self.method == 'symplectic':
            return self._integrate_symplectic_euler(bodies, forces, dt)
        else:
            raise ValueError(f"Unknown integration method: {self.method}")

    def _integrate_euler(self, bodies, forces, dt):
        """
        Forward Euler integration (first-order)
        """
        for i, body in enumerate(bodies):
            # Update velocities
            acceleration = forces[i]['force'] / body.mass
            body.linear_velocity += acceleration * dt

            # Update angular velocities
            angular_acceleration = body.get_inertia_world_inv() @ forces[i]['torque']
            body.angular_velocity += angular_acceleration * dt

            # Update positions
            body.position += body.linear_velocity * dt

            # Update orientations using quaternion integration
            omega_quat = np.array([0.0, *body.angular_velocity])
            quat_derivative = body._quaternion_multiply(omega_quat, body.orientation) * 0.5
            body.orientation += quat_derivative * dt
            body.orientation = body.orientation / np.linalg.norm(body.orientation)

    def _integrate_symplectic_euler(self, bodies, forces, dt):
        """
        Semi-implicit Euler (symplectic) - updates velocity first, then position
        Better energy conservation than forward Euler
        """
        for i, body in enumerate(bodies):
            # Update velocities first
            acceleration = forces[i]['force'] / body.mass
            body.linear_velocity += acceleration * dt

            angular_acceleration = body.get_inertia_world_inv() @ forces[i]['torque']
            body.angular_velocity += angular_acceleration * dt

            # Then update positions
            body.position += body.linear_velocity * dt

            # Update orientations
            omega_quat = np.array([0.0, *body.angular_velocity])
            quat_derivative = body._quaternion_multiply(omega_quat, body.orientation) * 0.5
            body.orientation += quat_derivative * dt
            body.orientation = body.orientation / np.linalg.norm(body.orientation)

    def _integrate_rk4(self, bodies, forces, dt):
        """
        4th-order Runge-Kutta integration
        """
        # Save initial state
        initial_states = []
        for body in bodies:
            initial_states.append({
                'position': body.position.copy(),
                'orientation': body.orientation.copy(),
                'linear_velocity': body.linear_velocity.copy(),
                'angular_velocity': body.angular_velocity.copy()
            })

        # Calculate k1
        k1 = self._calculate_derivatives(bodies, forces)

        # Calculate k2
        self._update_states(bodies, k1, dt/2)
        k2 = self._calculate_derivatives(bodies, forces)

        # Restore and calculate k3
        self._restore_states(bodies, initial_states)
        self._update_states(bodies, k2, dt/2)
        k3 = self._calculate_derivatives(bodies, forces)

        # Restore and calculate k4
        self._restore_states(bodies, initial_states)
        self._update_states(bodies, k3, dt)
        k4 = self._calculate_derivatives(bodies, forces)

        # Final integration
        self._restore_states(bodies, initial_states)
        weighted_derivatives = {}
        for key in k1:
            weighted_derivatives[key] = (k1[key] + 2*k2[key] + 2*k3[key] + k4[key]) / 6.0

        self._update_states(bodies, weighted_derivatives, dt)

    def _calculate_derivatives(self, bodies, forces):
        """
        Calculate state derivatives for RK4
        """
        derivatives = {
            'positions': [],
            'orientations': [],
            'linear_velocities': [],
            'angular_velocities': [],
            'linear_accelerations': [],
            'angular_accelerations': []
        }

        for i, body in enumerate(bodies):
            # Linear acceleration
            linear_acceleration = forces[i]['force'] / body.mass

            # Angular acceleration
            angular_acceleration = body.get_inertia_world_inv() @ forces[i]['torque']

            derivatives['positions'].append(body.linear_velocity)
            derivatives['linear_velocities'].append(linear_acceleration)
            derivatives['angular_velocities'].append(angular_acceleration)

            # Orientation derivative
            omega_quat = np.array([0.0, *body.angular_velocity])
            quat_derivative = body._quaternion_multiply(omega_quat, body.orientation) * 0.5
            derivatives['orientations'].append(quat_derivative)

            derivatives['angular_accelerations'].append(angular_acceleration)

        return derivatives

    def _update_states(self, bodies, derivatives, dt):
        """
        Update states using derivatives and time step
        """
        for i, body in enumerate(bodies):
            body.position += derivatives['positions'][i] * dt
            body.orientation += derivatives['orientations'][i] * dt
            body.orientation = body.orientation / np.linalg.norm(body.orientation)
            body.linear_velocity += derivatives['linear_velocities'][i] * dt
            body.angular_velocity += derivatives['angular_accelerations'][i] * dt

    def _restore_states(self, bodies, saved_states):
        """
        Restore saved states
        """
        for i, body in enumerate(bodies):
            body.position = saved_states[i]['position']
            body.orientation = saved_states[i]['orientation']
            body.linear_velocity = saved_states[i]['linear_velocity']
            body.angular_velocity = saved_states[i]['angular_velocity']

class AdaptiveIntegrator:
    def __init__(self, base_integrator, tolerance=1e-6):
        self.base_integrator = base_integrator
        self.tolerance = tolerance

    def integrate_adaptive(self, bodies, forces, dt):
        """
        Adaptive time stepping based on error estimation
        """
        # Try with current dt
        error = self._estimate_error(bodies, forces, dt)

        # Adjust dt based on error
        if error > self.tolerance:
            # Reduce dt
            new_dt = dt * 0.9 * np.sqrt(self.tolerance / error)
            return self.integrate_adaptive(bodies, forces, new_dt)
        elif error < self.tolerance / 4:
            # Increase dt (but not too much)
            new_dt = min(dt * 1.2, dt * np.sqrt(self.tolerance / error))
            self.base_integrator.integrate(bodies, forces, new_dt)
            return new_dt
        else:
            # Accept current dt
            self.base_integrator.integrate(bodies, forces, dt)
            return dt

    def _estimate_error(self, bodies, forces, dt):
        """
        Estimate integration error using step doubling method
        """
        # Save original state
        original_states = []
        for body in bodies:
            original_states.append({
                'position': body.position.copy(),
                'orientation': body.orientation.copy(),
                'linear_velocity': body.linear_velocity.copy(),
                'angular_velocity': body.angular_velocity.copy()
            })

        # Integrate with full step
        full_step_states = self._integrate_and_save_state(bodies, forces, dt)

        # Restore original state
        self._restore_states(bodies, original_states)

        # Integrate with two half steps
        half_step_states = self._integrate_and_save_state(bodies, forces, dt/2)
        half_step_states = self._integrate_and_save_state(bodies, forces, dt/2)

        # Calculate error
        error = self._calculate_state_difference(full_step_states, half_step_states)

        # Restore original state for continuation
        self._restore_states(bodies, original_states)

        return error

    def _integrate_and_save_state(self, bodies, forces, dt):
        """
        Integrate and save the resulting state
        """
        self.base_integrator.integrate(bodies, forces, dt)

        states = []
        for body in bodies:
            states.append({
                'position': body.position.copy(),
                'orientation': body.orientation.copy(),
                'linear_velocity': body.linear_velocity.copy(),
                'angular_velocity': body.angular_velocity.copy()
            })

        return states

    def _calculate_state_difference(self, states1, states2):
        """
        Calculate difference between two sets of states
        """
        total_error = 0.0
        for i in range(len(states1)):
            pos_diff = np.linalg.norm(states1[i]['position'] - states2[i]['position'])
            vel_diff = np.linalg.norm(states1[i]['linear_velocity'] - states2[i]['linear_velocity'])
            total_error += pos_diff + vel_diff

        return total_error
```

## 7. Joint and Constraint Implementation

### Joint Constraint Solving

```python
class JointConstraint:
    def __init__(self, body1_idx, body2_idx, joint_type, anchor_point, axis=None):
        self.body1_idx = body1_idx
        self.body2_idx = body2_idx
        self.type = joint_type  # 'revolute', 'prismatic', 'fixed', 'ball'
        self.anchor_point = np.array(anchor_point)
        self.axis = np.array(axis) if axis is not None else np.array([0, 0, 1])
        self.axis = self.axis / np.linalg.norm(self.axis)

        # Constraint Jacobian
        self.J = np.zeros((6, 12))  # 6 constraints, 12 DOF (6 per body)

    def calculate_constraint_equation(self, bodies):
        """
        Calculate constraint equation C(q) = 0
        """
        body1 = bodies[self.body1_idx]
        body2 = bodies[self.body2_idx]

        if self.type == 'fixed':
            # Position and orientation constraints
            pos_error = (body2.position + self._transform_to_body_frame(body2, self.anchor_point)) - \
                       (body1.position + self._transform_to_body_frame(body1, self.anchor_point))

            # For now, just return position error
            return pos_error
        elif self.type == 'revolute':
            # Revolute joint: maintain position, allow rotation about axis
            pos_error = body2.position - body1.position
            return pos_error
        else:
            # Other joint types
            return np.zeros(3)

    def calculate_jacobian(self, bodies):
        """
        Calculate constraint Jacobian J such that J * [v1, ω1, v2, ω2] = 0
        """
        # This would implement the full Jacobian calculation
        # based on the specific joint type
        pass

    def _transform_to_body_frame(self, body, point):
        """
        Transform point from world to body frame
        """
        # Convert quaternion to rotation matrix
        r = R.from_quat([body.orientation[1], body.orientation[2], body.orientation[3], body.orientation[0]])
        rotation_matrix = r.as_matrix()

        # Transform point
        return rotation_matrix.T @ point

class JointSolver:
    def __init__(self):
        self.constraints = []

    def add_constraint(self, constraint):
        """
        Add a joint constraint to the solver
        """
        self.constraints.append(constraint)

    def solve_constraints(self, bodies, dt):
        """
        Solve all joint constraints using iterative method
        """
        # Use iterative constraint solving
        for iteration in range(5):  # Multiple iterations for convergence
            for constraint in self.constraints:
                self._solve_single_constraint(bodies, constraint, dt)

    def _solve_single_constraint(self, bodies, constraint, dt):
        """
        Solve a single joint constraint
        """
        # Calculate constraint error
        error = constraint.calculate_constraint_equation(bodies)

        # Apply correction forces proportional to error
        correction_magnitude = 0.1  # Stiffness parameter

        # Apply corrections to reduce constraint violation
        body1 = bodies[constraint.body1_idx]
        body2 = bodies[constraint.body2_idx]

        # Simple position-based correction
        correction = correction_magnitude * error

        body1.position -= 0.5 * correction
        body2.position += 0.5 * correction

class JointLimitConstraint:
    def __init__(self, joint_idx, min_limit, max_limit):
        self.joint_idx = joint_idx
        self.min_limit = min_limit
        self.max_limit = max_limit
        self.stiffness = 1000.0  # Spring constant for limit forces

    def apply_limits(self, articulated_body):
        """
        Apply joint limits to the articulated body
        """
        current_pos = articulated_body.q[self.joint_idx]

        # Check if joint is beyond limits
        if current_pos < self.min_limit:
            # Apply spring force to push back
            force = self.stiffness * (self.min_limit - current_pos)
            articulated_body.tau[self.joint_idx] += force
        elif current_pos > self.max_limit:
            # Apply spring force to push back
            force = self.stiffness * (self.max_limit - current_pos)
            articulated_body.tau[self.joint_idx] += force

    def calculate_limit_force(self, position, velocity):
        """
        Calculate force due to joint limits
        """
        force = 0.0

        if position < self.min_limit:
            # Beyond minimum limit
            displacement = self.min_limit - position
            force = self.stiffness * displacement
            # Add damping to prevent oscillation
            force -= 50.0 * velocity  # Damping term
        elif position > self.max_limit:
            # Beyond maximum limit
            displacement = self.max_limit - position
            force = self.stiffness * displacement
            # Add damping to prevent oscillation
            force -= 50.0 * velocity  # Damping term

        return force
```

## 8. Performance Optimization

### Parallel Physics Implementation

```python
import threading
import multiprocessing as mp
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

class ParallelPhysicsEngine:
    def __init__(self, num_threads=4):
        self.num_threads = num_threads
        self.threads = []
        self.thread_bodies = []  # Bodies assigned to each thread
        self.thread_locks = [threading.Lock() for _ in range(num_threads)]

    def partition_bodies(self, bodies):
        """
        Partition bodies among threads
        """
        n_bodies = len(bodies)
        bodies_per_thread = n_bodies // self.num_threads

        self.thread_bodies = []
        for i in range(self.num_threads):
            start_idx = i * bodies_per_thread
            end_idx = start_idx + bodies_per_thread if i < self.num_threads - 1 else n_bodies
            self.thread_bodies.append(bodies[start_idx:end_idx])

    def parallel_integrate(self, dt):
        """
        Perform parallel integration of physics
        """
        with ThreadPoolExecutor(max_workers=self.num_threads) as executor:
            futures = []

            for i in range(self.num_threads):
                future = executor.submit(self._integrate_thread, i, dt)
                futures.append(future)

            # Wait for all threads to complete
            for future in futures:
                future.result()

    def _integrate_thread(self, thread_idx, dt):
        """
        Integration function for a single thread
        """
        with self.thread_locks[thread_idx]:
            bodies = self.thread_bodies[thread_idx]

            # Perform integration on assigned bodies
            for body in bodies:
                # Apply forces (simplified)
                gravity_force = body.mass * np.array([0, 0, -9.81])
                body.apply_force(gravity_force)

                # Update velocities
                acceleration = body.force * body.mass_inv
                body.linear_velocity += acceleration * dt

                # Update positions
                body.position += body.linear_velocity * dt

                # Clear forces
                body.clear_forces()

class OptimizedPhysicsEngine:
    def __init__(self):
        # Pre-allocate arrays to avoid memory allocation during simulation
        self.max_bodies = 1000
        self.n_bodies = 0

        # State arrays
        self.positions = np.zeros((self.max_bodies, 3))
        self.velocities = np.zeros((self.max_bodies, 3))
        self.accelerations = np.zeros((self.max_bodies, 3))
        self.masses = np.ones(self.max_bodies)
        self.mass_inv = np.ones(self.max_bodies)

        # Force arrays
        self.forces = np.zeros((self.max_bodies, 3))

        # Active body mask
        self.active = np.zeros(self.max_bodies, dtype=bool)

    def add_body_optimized(self, position, velocity, mass=1.0):
        """
        Add body using pre-allocated arrays
        """
        if self.n_bodies < self.max_bodies:
            idx = self.n_bodies
            self.positions[idx] = position
            self.velocities[idx] = velocity
            self.masses[idx] = mass
            self.mass_inv[idx] = 1.0 / mass if mass > 0 else 0.0
            self.active[idx] = True
            self.n_bodies += 1
            return idx
        else:
            raise Exception("Maximum number of bodies reached")

    def step_optimized(self, dt):
        """
        Optimized physics step using vectorized operations
        """
        # Apply gravity to all active bodies at once
        active_gravity = np.zeros((self.n_bodies, 3))
        active_gravity[self.active] = self.masses[self.active, np.newaxis] * np.array([0, 0, -9.81])

        # Add external forces
        self.forces[self.active] += active_gravity[self.active]

        # Calculate accelerations
        accelerations = np.zeros((self.n_bodies, 3))
        accelerations[self.active] = self.forces[self.active] * self.mass_inv[self.active, np.newaxis]

        # Update velocities
        self.velocities[self.active] += accelerations[self.active] * dt

        # Update positions
        self.positions[self.active] += self.velocities[self.active] * dt

        # Clear forces for next step
        self.forces[self.active] = 0.0

    def get_body_state(self, idx):
        """
        Get state of a specific body
        """
        if idx < self.n_bodies and self.active[idx]:
            return {
                'position': self.positions[idx].copy(),
                'velocity': self.velocities[idx].copy(),
                'mass': self.masses[idx]
            }
        return None

class SIMDPhysicsEngine:
    def __init__(self):
        # Use NumPy's vectorized operations for SIMD-like performance
        pass

    def integrate_multiple_bodies(self, positions, velocities, forces, masses, dt):
        """
        Integrate multiple bodies simultaneously using vectorized operations
        """
        # Calculate accelerations
        accelerations = forces / masses[:, np.newaxis]

        # Update velocities
        new_velocities = velocities + accelerations * dt

        # Update positions
        new_positions = positions + new_velocities * dt

        return new_positions, new_velocities
```

## 9. Validation and Testing

### Physics Validation Framework

```python
class PhysicsValidator:
    def __init__(self, physics_engine):
        self.engine = physics_engine
        self.results = {}

    def validate_energy_conservation(self, initial_state, time_steps=1000, dt=0.001):
        """
        Validate energy conservation in a closed system
        """
        initial_energy = self._calculate_total_energy(initial_state)

        # Run simulation
        current_state = initial_state.copy()
        for _ in range(time_steps):
            current_state = self.engine.step(current_state, dt)

        final_energy = self._calculate_total_energy(current_state)

        energy_error = abs(final_energy - initial_energy) / initial_energy

        self.results['energy_conservation'] = {
            'initial_energy': initial_energy,
            'final_energy': final_energy,
            'energy_error': energy_error,
            'pass': energy_error < 0.01  # 1% tolerance
        }

        return self.results['energy_conservation']

    def validate_momentum_conservation(self, initial_state, time_steps=1000, dt=0.001):
        """
        Validate momentum conservation in a closed system
        """
        initial_momentum = self._calculate_total_momentum(initial_state)

        # Run simulation
        current_state = initial_state.copy()
        for _ in range(time_steps):
            current_state = self.engine.step(current_state, dt)

        final_momentum = self._calculate_total_momentum(current_state)

        momentum_error = np.linalg.norm(final_momentum - initial_momentum)

        self.results['momentum_conservation'] = {
            'initial_momentum': initial_momentum,
            'final_momentum': final_momentum,
            'momentum_error': momentum_error,
            'pass': momentum_error < 0.001  # Small tolerance
        }

        return self.results['momentum_conservation']

    def validate_analytical_solution(self, test_case, analytical_solution, time_steps=100, dt=0.01):
        """
        Compare simulation results with analytical solutions
        """
        # Run simulation
        simulation_results = []
        current_state = test_case['initial_state'].copy()

        for _ in range(time_steps):
            current_state = self.engine.step(current_state, dt)
            simulation_results.append(current_state.copy())

        # Compare with analytical solution
        analytical_results = []
        for i in range(time_steps):
            t = i * dt
            analytical_state = analytical_solution(t, test_case['initial_state'])
            analytical_results.append(analytical_state)

        # Calculate error
        total_error = 0.0
        for i in range(time_steps):
            error = np.linalg.norm(simulation_results[i] - analytical_results[i])
            total_error += error

        avg_error = total_error / time_steps

        self.results['analytical_validation'] = {
            'average_error': avg_error,
            'max_error': max(np.linalg.norm(sim - ana) for sim, ana in zip(simulation_results, analytical_results)),
            'pass': avg_error < 0.01  # 1% average error tolerance
        }

        return self.results['analytical_validation']

    def _calculate_total_energy(self, state):
        """
        Calculate total energy (kinetic + potential) of the system
        """
        total_energy = 0.0

        # For each body in state
        for body_data in state:
            # Kinetic energy: KE = 0.5 * m * v²
            mass = body_data.get('mass', 1.0)
            velocity = body_data.get('velocity', np.zeros(3))
            ke = 0.5 * mass * np.dot(velocity, velocity)

            # Potential energy: PE = m * g * h
            position = body_data.get('position', np.zeros(3))
            pe = mass * 9.81 * position[2]  # Assuming z is up

            total_energy += ke + pe

        return total_energy

    def _calculate_total_momentum(self, state):
        """
        Calculate total momentum of the system
        """
        total_momentum = np.zeros(3)

        for body_data in state:
            mass = body_data.get('mass', 1.0)
            velocity = body_data.get('velocity', np.zeros(3))
            momentum = mass * velocity
            total_momentum += momentum

        return total_momentum

class PhysicsBenchmark:
    def __init__(self):
        self.benchmark_results = {}

    def benchmark_integration_methods(self, test_scenario, time_limit=1.0):
        """
        Benchmark different integration methods
        """
        methods = ['euler', 'rk4', 'symplectic']
        results = {}

        for method in methods:
            integrator = Integrator(method=method)

            start_time = time.time()
            step_count = 0

            # Run for specified time
            while time.time() - start_time < time_limit:
                # Perform integration step
                # This is a simplified benchmark
                step_count += 1

            results[method] = {
                'steps_per_second': step_count / time_limit,
                'time_elapsed': time.time() - start_time
            }

        self.benchmark_results['integration_methods'] = results
        return results

    def benchmark_collision_detection(self, num_objects=100, time_limit=1.0):
        """
        Benchmark collision detection performance
        """
        # Create test objects
        objects = []
        for i in range(num_objects):
            pos = np.random.rand(3) * 10  # Random positions in 10x10x10 space
            obj = RigidBody(position=pos)
            objects.append(obj)

        detector = CollisionDetector()

        start_time = time.time()
        collision_checks = 0

        while time.time() - start_time < time_limit:
            # Perform collision detection
            for i in range(len(objects)):
                for j in range(i + 1, len(objects)):
                    result = detector.detect_collision(objects[i], objects[j])
                    collision_checks += 1

        self.benchmark_results['collision_detection'] = {
            'collision_checks_per_second': collision_checks / time_limit,
            'objects_count': num_objects,
            'time_elapsed': time.time() - start_time
        }

        return self.benchmark_results['collision_detection']
```

This implementation section provides practical examples of physics simulation for humanoid robots, including rigid body dynamics, multi-body systems, collision detection, contact response, and numerical integration methods. The code demonstrates how theoretical physics concepts are translated into executable implementations that can run on real robotic systems.