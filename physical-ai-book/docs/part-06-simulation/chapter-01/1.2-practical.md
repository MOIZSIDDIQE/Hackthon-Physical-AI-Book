---
title: 6.2 Simulation Implementation
sidebar_position: 20
---

# 6.2 Simulation Implementation

## Learning Objectives
- Implement physics-based simulation engines for humanoid robots
- Design sensor simulation models with realistic characteristics
- Integrate control systems with simulation environments
- Validate simulation accuracy and performance
- Apply simulation implementation techniques to real-world scenarios

## Introduction

Simulation implementation transforms theoretical concepts into executable code that can model complex robotic systems in real-time. This process involves not only implementing the core physics engines but also addressing practical challenges such as numerical stability, computational efficiency, and integration with existing robotic software stacks. The implementation must balance simulation accuracy with computational performance while ensuring that simulated results remain representative of real-world behavior.

Effective simulation implementation requires careful consideration of software architecture, numerical methods, and system integration. The simulation system must interface with real-time operating systems, handle sensor noise and delays, and maintain stability in the presence of numerical approximations. Implementation choices significantly impact the performance, reliability, and maintainability of the resulting simulation system.

This section provides practical examples of simulation implementation using common frameworks and tools in robotics, with a focus on humanoid-specific challenges such as complex contact dynamics, sensor modeling, and real-time performance requirements.

## 2. Physics Engine Implementation

### Rigid Body Dynamics Engine

A core physics engine implements the fundamental equations of motion for rigid bodies:

```python
import numpy as np
from scipy.spatial.transform import Rotation as R
import time

class RigidBody:
    def __init__(self, mass=1.0, inertia=np.eye(3), position=np.zeros(3), orientation=np.array([0, 0, 0, 1])):
        self.mass = mass
        self.inertia = inertia  # In body frame
        self.inertia_inv = np.linalg.inv(inertia)

        # State variables
        self.position = position.copy()
        self.orientation = orientation.copy()  # Quaternion [w, x, y, z]
        self.linear_velocity = np.zeros(3)
        self.angular_velocity = np.zeros(3)  # In world frame

        # Forces and torques (accumulated per step)
        self.force = np.zeros(3)
        self.torque = np.zeros(3)  # In world frame

        # Derived quantities
        self.linear_momentum = mass * self.linear_velocity
        self.angular_momentum = self.orientation_world_to_body(self.orientation) @ self.angular_velocity

    def orientation_world_to_body(self, q):
        """
        Convert world frame inertia to body frame using quaternion
        """
        r = R.from_quat([q[1], q[2], q[3], q[0]])  # [x, y, z, w] format for scipy
        return r.as_matrix().T @ self.inertia @ r.as_matrix()

    def update_dynamics(self, dt):
        """
        Update rigid body dynamics using Newton-Euler equations
        """
        # Linear motion: F = ma -> a = F/m
        linear_acceleration = self.force / self.mass
        self.linear_velocity += linear_acceleration * dt
        self.position += self.linear_velocity * dt

        # Angular motion: τ = Iα + ω×(Iω) -> α = I⁻¹(τ - ω×(Iω))
        # In world frame: τ = dL/dt = I(dω/dt) + ω×(Iω)
        omega_cross_Iomega = np.cross(self.angular_velocity,
                                    self.orientation_world_to_body(self.orientation) @ self.angular_velocity)
        angular_acceleration = (self.inertia_inv @
                               (self.orientation_world_to_body(self.orientation).T @
                                (self.torque - omega_cross_Iomega)))
        self.angular_velocity += angular_acceleration * dt

        # Update orientation using quaternion derivative
        omega_quat = np.array([0, *self.angular_velocity])
        q_dot = 0.5 * self.quaternion_multiply(omega_quat, self.orientation)
        self.orientation += q_dot * dt
        self.orientation = self.orientation / np.linalg.norm(self.orientation)  # Normalize

        # Clear forces and torques for next step
        self.force = np.zeros(3)
        self.torque = np.zeros(3)

    def quaternion_multiply(self, q1, q2):
        """
        Multiply two quaternions
        """
        w1, x1, y1, z1 = q1
        w2, x2, y2, z2 = q2
        w = w1*w2 - x1*x2 - y1*y2 - z1*z2
        x = w1*x2 + x1*w2 + y1*z2 - z1*y2
        y = w1*y2 - x1*z2 + y1*w2 + z1*x2
        z = w1*z2 + x1*y2 - y1*x2 + z1*w2
        return np.array([w, x, y, z])

    def apply_force(self, force, point=None):
        """
        Apply force at a point (if point not specified, applies at center of mass)
        """
        self.force += force
        if point is not None:
            # Calculate torque: τ = r × F
            r = point - self.position
            self.torque += np.cross(r, force)

    def apply_torque(self, torque):
        """
        Apply torque in world frame
        """
        self.torque += torque

class PhysicsEngine:
    def __init__(self, gravity=np.array([0, 0, -9.81]), dt=0.001):
        self.gravity = gravity
        self.dt = dt
        self.bodies = []
        self.contact_solver = ContactSolver()

    def add_body(self, body):
        """
        Add a rigid body to the simulation
        """
        self.bodies.append(body)

    def step(self):
        """
        Perform one simulation step
        """
        # Apply gravity to all bodies
        for body in self.bodies:
            body.apply_force(body.mass * self.gravity)

        # Update dynamics
        for body in self.bodies:
            body.update_dynamics(self.dt)

        # Handle collisions and contacts
        self.contact_solver.solve_contacts(self.bodies, self.dt)

class ArticulatedBody:
    def __init__(self, joints, links):
        self.joints = joints  # List of joint objects
        self.links = links    # List of link objects (rigid bodies)
        self.n_dof = len(joints)

        # Joint state
        self.q = np.zeros(self.n_dof)  # Joint positions
        self.q_dot = np.zeros(self.n_dof)  # Joint velocities
        self.q_ddot = np.zeros(self.n_dof)  # Joint accelerations

        # Applied joint torques
        self.tau = np.zeros(self.n_dof)

    def forward_kinematics(self):
        """
        Compute positions and orientations of all links
        """
        # This would implement the forward kinematics equations
        # For each joint, compute the transformation from base
        pass

    def jacobian(self, joint_idx):
        """
        Compute Jacobian matrix for a specific joint
        """
        # This would compute the geometric Jacobian
        # relating joint velocities to end-effector velocities
        pass

    def inverse_dynamics(self, q, q_dot, q_ddot):
        """
        Compute required joint torques for desired accelerations
        using recursive Newton-Euler algorithm
        """
        # Implement the articulated body algorithm
        # Forward pass: compute velocities and accelerations
        # Backward pass: compute forces and torques

        # Initialize for base
        v_base = np.zeros(6)  # [linear_vel, angular_vel]
        a_base = np.array([0, 0, 0, self.gravity[0], self.gravity[1], self.gravity[2]])

        # Forward pass: compute velocities and accelerations
        for i in range(self.n_dof):
            # Compute joint motion contribution
            S_i = self.joint_motion_vector(i, q[i])
            v_i = self.forward_velocity(i, v_base if i == 0 else v_prev, S_i * q_dot[i])
            a_i = self.forward_acceleration(i, a_base if i == 0 else a_prev, S_i * q_ddot[i], v_i)

            v_prev = v_i
            a_prev = a_i

        # Backward pass: compute forces and torques
        f_next = np.zeros(6)  # Wrench on next link
        for i in range(self.n_dof - 1, -1, -1):
            # Compute forces and torques on this link
            f_i = self.backward_force(i, a_i, f_next)
            self.tau[i] = self.joint_torque(i, f_i)

            f_next = self.link_wrench(i, f_i)

        return self.tau

    def joint_motion_vector(self, joint_idx, joint_pos):
        """
        Compute joint motion vector (spatial velocity due to unit joint velocity)
        """
        # For revolute joint: S = [0; axis_of_rotation] (angular part first)
        # For prismatic joint: S = [axis_of_translation; 0] (linear part first)
        pass

    def forward_velocity(self, joint_idx, v_prev, S_q_dot):
        """
        Compute spatial velocity of current link
        """
        pass

    def forward_acceleration(self, joint_idx, a_prev, S_q_ddot, v_current):
        """
        Compute spatial acceleration of current link
        """
        pass

    def backward_force(self, joint_idx, a_current, f_next):
        """
        Compute wrench on current link
        """
        pass

    def joint_torque(self, joint_idx, f_current):
        """
        Compute required joint torque from link wrench
        """
        pass

    def link_wrench(self, joint_idx, f_current):
        """
        Compute wrench transmitted to next link
        """
        pass
```

## 3. Contact and Collision Handling

### Collision Detection and Response

```python
class CollisionDetector:
    def __init__(self):
        self.broad_phase_pairs = []
        self.narrow_phase_results = []

    def broad_phase(self, bodies):
        """
        Identify potentially colliding pairs using bounding volumes
        """
        pairs = []
        n = len(bodies)

        # Simple O(n²) broad phase - in practice, use spatial partitioning
        for i in range(n):
            for j in range(i + 1, n):
                # Check if bounding spheres overlap
                pos_i = bodies[i].position
                pos_j = bodies[j].position
                dist = np.linalg.norm(pos_i - pos_j)

                # Approximate bounding sphere radius
                radius_i = np.cbrt(np.prod(np.sqrt(np.diag(bodies[i].inertia))))
                radius_j = np.cbrt(np.prod(np.sqrt(np.diag(bodies[j].inertia))))

                if dist < radius_i + radius_j:
                    pairs.append((i, j))

        return pairs

    def narrow_phase(self, bodies, pairs):
        """
        Perform detailed collision detection for potential pairs
        """
        contacts = []

        for i, j in pairs:
            body_i = bodies[i]
            body_j = bodies[j]

            # Simple sphere-sphere collision detection
            # In practice, use GJK, Minkowski Portal Refinement, or other algorithms
            pos_i = body_i.position
            pos_j = body_j.position
            dist = np.linalg.norm(pos_j - pos_i)

            # Assume spherical shapes with radii
            radius_i = 0.1  # Example radius
            radius_j = 0.1

            if dist < radius_i + radius_j:
                # Collision detected
                normal = (pos_j - pos_i) / dist if dist > 1e-6 else np.array([1, 0, 0])
                penetration = (radius_i + radius_j) - dist

                contact = {
                    'body1': i,
                    'body2': j,
                    'normal': normal,
                    'penetration': penetration,
                    'point1': pos_i + normal * radius_i,
                    'point2': pos_j - normal * radius_j
                }
                contacts.append(contact)

        return contacts

class ContactSolver:
    def __init__(self, friction_coefficient=0.5, restitution=0.2):
        self.friction_coefficient = friction_coefficient
        self.restitution = restitution

    def solve_contacts(self, bodies, dt):
        """
        Solve contact constraints using impulse-based method
        """
        detector = CollisionDetector()
        pairs = detector.broad_phase(bodies)
        contacts = detector.narrow_phase(bodies, pairs)

        for contact in contacts:
            self.resolve_contact(bodies, contact, dt)

    def resolve_contact(self, bodies, contact, dt):
        """
        Resolve a single contact using impulse-based collision response
        """
        body1 = bodies[contact['body1']]
        body2 = bodies[contact['body2']]
        normal = contact['normal']

        # Calculate relative velocity at contact point
        r1 = contact['point1'] - body1.position
        r2 = contact['point2'] - body2.position

        v1 = body1.linear_velocity + np.cross(body1.angular_velocity, r1)
        v2 = body2.linear_velocity + np.cross(body2.angular_velocity, r2)
        relative_velocity = v2 - v1

        # Velocity along normal
        vel_along_normal = np.dot(relative_velocity, normal)

        # Do not resolve if objects are moving apart
        if vel_along_normal > 0:
            return

        # Calculate impulse magnitude for restitution
        e = self.restitution
        inv_mass1 = 1.0 / body1.mass
        inv_mass2 = 1.0 / body2.mass

        # Calculate cross products for angular effects
        r1_cross_n = np.cross(r1, normal)
        r2_cross_n = np.cross(r2, normal)

        # Calculate inverse inertia terms
        inv_inertia1 = body1.inertia_inv
        inv_inertia2 = body2.inertia_inv

        angular_term1 = inv_inertia1 @ r1_cross_n
        angular_term1 = np.cross(angular_term1, r1)
        angular_term2 = inv_inertia2 @ r2_cross_n
        angular_term2 = np.cross(angular_term2, r2)

        denominator = (inv_mass1 + inv_mass2 +
                      np.dot(normal, angular_term1) +
                      np.dot(normal, angular_term2))

        if denominator < 1e-6:  # Prevent division by zero
            return

        # Calculate impulse magnitude
        j = -(1 + e) * vel_along_normal / denominator
        impulse = j * normal

        # Apply impulse to bodies
        body1.linear_velocity -= impulse * inv_mass1
        body1.angular_velocity -= inv_inertia1 @ np.cross(r1, impulse)

        body2.linear_velocity += impulse * inv_mass2
        body2.angular_velocity += inv_inertia2 @ np.cross(r2, impulse)

        # Apply friction
        self.apply_friction(bodies, contact, dt)

    def apply_friction(self, bodies, contact, dt):
        """
        Apply friction impulses to reduce tangential velocity
        """
        body1 = bodies[contact['body1']]
        body2 = bodies[contact['body2']]
        normal = contact['normal']

        r1 = contact['point1'] - body1.position
        r2 = contact['point2'] - body2.position

        v1 = body1.linear_velocity + np.cross(body1.angular_velocity, r1)
        v2 = body2.linear_velocity + np.cross(body2.angular_velocity, r2)
        relative_velocity = v2 - v1

        # Tangential velocity
        tangent_velocity = relative_velocity - np.dot(relative_velocity, normal) * normal
        tangent_speed = np.linalg.norm(tangent_velocity)

        if tangent_speed < 1e-6:
            return

        tangent = tangent_velocity / tangent_speed

        # Calculate friction impulse magnitude
        inv_mass1 = 1.0 / body1.mass
        inv_mass2 = 1.0 / body2.mass

        r1_cross_t = np.cross(r1, tangent)
        r2_cross_t = np.cross(r2, tangent)

        inv_inertia1 = body1.inertia_inv
        inv_inertia2 = body2.inertia_inv

        angular_term1 = inv_inertia1 @ r1_cross_t
        angular_term1 = np.cross(angular_term1, r1)
        angular_term2 = inv_inertia2 @ r2_cross_t
        angular_term2 = np.cross(angular_term2, r2)

        denominator = (inv_mass1 + inv_mass2 +
                      np.dot(tangent, angular_term1) +
                      np.dot(tangent, angular_term2))

        if denominator < 1e-6:
            return

        # Calculate friction impulse
        jt = -tangent_speed / denominator
        friction_magnitude = abs(jt)

        # Clamp friction by Coulomb friction model
        max_friction = self.friction_coefficient * abs(np.dot(relative_velocity, normal))
        friction_magnitude = min(friction_magnitude, max_friction)

        friction_impulse = friction_magnitude * tangent

        # Apply friction impulse
        body1.linear_velocity -= friction_impulse * inv_mass1
        body1.angular_velocity -= inv_inertia1 @ np.cross(r1, friction_impulse)

        body2.linear_velocity += friction_impulse * inv_mass2
        body2.angular_velocity += inv_inertia2 @ np.cross(r2, friction_impulse)
```

## 4. Sensor Simulation Implementation

### IMU Sensor Simulation

```python
class IMUSensor:
    def __init__(self, position=np.zeros(3), orientation=np.array([0, 0, 0, 1]),
                 noise_params=None, bias_params=None):
        self.position = position  # Position relative to body frame
        self.orientation = orientation  # Orientation relative to body frame
        self.body_frame_orientation = np.array([0, 0, 0, 1])  # Current orientation relative to world

        # Noise parameters
        if noise_params is None:
            noise_params = {
                'gyro_noise_density': 1.0e-4,      # rad/s/sqrt(Hz)
                'gyro_random_walk': 1.0e-5,        # rad/s^2/sqrt(Hz)
                'accel_noise_density': 1.0e-3,     # m/s^2/sqrt(Hz)
                'accel_random_walk': 1.0e-4,       # m/s^3/sqrt(Hz)
            }
        self.noise_params = noise_params

        # Bias parameters
        if bias_params is None:
            bias_params = {
                'gyro_bias_init': np.random.normal(0, 1e-3, 3),  # Initial bias
                'gyro_bias_walk': 1.0e-6,           # Bias random walk
                'accel_bias_init': np.random.normal(0, 1e-2, 3), # Initial bias
                'accel_bias_walk': 1.0e-5,          # Bias random walk
            }
        self.bias_params = bias_params

        # Internal state
        self.gyro_bias = self.bias_params['gyro_bias_init'].copy()
        self.accel_bias = self.bias_params['accel_bias_init'].copy()

        # Previous values for integration
        self.prev_angular_velocity = np.zeros(3)
        self.prev_linear_acceleration = np.zeros(3)

        # Time tracking
        self.last_update_time = 0.0
        self.dt = 0.01  # Default update rate (100 Hz)

    def update(self, body_state, current_time):
        """
        Update IMU measurements based on body state
        """
        # Extract body state
        body_position = body_state['position']
        body_orientation = body_state['orientation']  # quaternion [w, x, y, z]
        body_angular_velocity = body_state['angular_velocity']  # in world frame
        body_linear_acceleration = body_state['linear_acceleration']  # in world frame

        # Calculate IMU frame state
        # Transform angular velocity to IMU frame
        imu_angular_velocity = self.transform_vector_to_imu_frame(
            body_angular_velocity, body_orientation
        )

        # Transform linear acceleration to IMU frame
        imu_linear_acceleration = self.transform_vector_to_imu_frame(
            body_linear_acceleration, body_orientation
        )

        # Add gravity to acceleration (IMU measures proper acceleration)
        gravity_world = np.array([0, 0, -9.81])
        gravity_imu = self.transform_vector_to_imu_frame(gravity_world, body_orientation)
        imu_linear_acceleration += gravity_imu

        # Apply noise and bias
        gyro_measurement = self.add_noise_and_bias(
            imu_angular_velocity,
            self.noise_params['gyro_noise_density'],
            self.noise_params['gyro_random_walk'],
            self.gyro_bias,
            current_time - self.last_update_time
        )

        accel_measurement = self.add_noise_and_bias(
            imu_linear_acceleration,
            self.noise_params['accel_noise_density'],
            self.noise_params['accel_random_walk'],
            self.accel_bias,
            current_time - self.last_update_time
        )

        # Update bias (random walk)
        self.update_bias(current_time - self.last_update_time)

        self.last_update_time = current_time

        return {
            'angular_velocity': gyro_measurement,
            'linear_acceleration': accel_measurement,
            'orientation': self.orientation,  # Could also integrate from gyro
            'timestamp': current_time
        }

    def transform_vector_to_imu_frame(self, vector, body_orientation):
        """
        Transform a vector from world frame to IMU frame
        """
        # First transform to body frame
        r_body = R.from_quat([body_orientation[1], body_orientation[2], body_orientation[3], body_orientation[0]])
        vector_body = r_body.inv().apply(vector)

        # Then transform to IMU frame (assuming IMU orientation relative to body)
        r_imu = R.from_quat([self.orientation[1], self.orientation[2], self.orientation[3], self.orientation[0]])
        vector_imu = r_imu.inv().apply(vector_body)

        return vector_imu

    def add_noise_and_bias(self, true_value, noise_density, random_walk, bias, dt):
        """
        Add noise and bias to measurements
        """
        # Add bias
        measurement = true_value + bias

        # Add white noise
        noise_std = noise_density / np.sqrt(dt) if dt > 0 else 0
        white_noise = np.random.normal(0, noise_std, 3)
        measurement += white_noise

        # In practice, also add quantization effects and other imperfections
        return measurement

    def update_bias(self, dt):
        """
        Update bias using random walk model
        """
        # Gyro bias random walk
        gyro_walk = np.random.normal(0, self.bias_params['gyro_bias_walk'] * np.sqrt(dt), 3)
        self.gyro_bias += gyro_walk

        # Accel bias random walk
        accel_walk = np.random.normal(0, self.bias_params['accel_bias_walk'] * np.sqrt(dt), 3)
        self.accel_bias += accel_walk

class JointEncoder:
    def __init__(self, resolution=2**16, noise_std=1e-4, delay=0.001):
        self.resolution = resolution  # Number of counts per revolution
        self.noise_std = noise_std    # Noise standard deviation in radians
        self.delay = delay            # Sensor delay in seconds

        # Internal state
        self.position_buffer = []  # Buffer for delayed readings
        self.velocity_buffer = []  # Buffer for delayed velocity readings

    def update(self, true_position, true_velocity, current_time):
        """
        Update joint encoder measurements
        """
        # Add quantization noise (simulate discrete encoder)
        quantized_position = self.quantize_position(true_position)

        # Add measurement noise
        noisy_position = quantized_position + np.random.normal(0, self.noise_std)

        # Store in buffer for delay simulation
        self.position_buffer.append((current_time, noisy_position))
        self.velocity_buffer.append((current_time, true_velocity + np.random.normal(0, self.noise_std * 10)))

        # Return delayed measurement
        delayed_position = self.get_delayed_value(self.position_buffer, current_time, self.delay)
        delayed_velocity = self.get_delayed_value(self.velocity_buffer, current_time, self.delay)

        return {
            'position': delayed_position,
            'velocity': delayed_velocity,
            'timestamp': current_time - self.delay if delayed_position is not None else current_time
        }

    def quantize_position(self, position):
        """
        Simulate encoder quantization
        """
        # Convert to counts
        counts = np.round(position * self.resolution / (2 * np.pi))
        # Convert back to radians
        quantized_position = counts * (2 * np.pi) / self.resolution
        return quantized_position

    def get_delayed_value(self, buffer, current_time, delay):
        """
        Get value from buffer with specified delay
        """
        target_time = current_time - delay

        # Find closest value in buffer
        for i in range(len(buffer) - 1, -1, -1):
            if buffer[i][0] <= target_time:
                return buffer[i][1]

        # If no value found, return the most recent
        return buffer[-1][1] if buffer else 0.0

class ForceTorqueSensor:
    def __init__(self, noise_params=None, range_limits=None, bandwidth=100.0):
        if noise_params is None:
            noise_params = {
                'force_noise_std': 0.1,      # Newtons
                'torque_noise_std': 0.01,    # N*m
                'offset_drift_rate': 0.001   # Per second
            }
        self.noise_params = noise_params

        if range_limits is None:
            range_limits = {
                'max_force': 1000.0,   # Newtons
                'max_torque': 100.0    # N*m
            }
        self.range_limits = range_limits

        self.bandwidth = bandwidth  # Hz
        self.offset_drift = np.zeros(6)  # [Fx, Fy, Fz, Tx, Ty, Tz]

    def update(self, true_wrench, current_time):
        """
        Update force/torque sensor measurements
        """
        # Add noise
        noise = np.concatenate([
            np.random.normal(0, self.noise_params['force_noise_std'], 3),
            np.random.normal(0, self.noise_params['torque_noise_std'], 3)
        ])

        # Add offset drift
        drift = np.random.normal(0, self.noise_params['offset_drift_rate'] * 0.001, 6)
        self.offset_drift += drift

        # Apply measurement
        measured_wrench = true_wrench + noise + self.offset_drift

        # Apply range limits
        measured_wrench = np.clip(
            measured_wrench,
            [-self.range_limits['max_force']] * 3 + [-self.range_limits['max_torque']] * 3,
            [self.range_limits['max_force']] * 3 + [self.range_limits['max_torque']] * 3
        )

        # Apply bandwidth filtering (simplified)
        # In practice, use a proper low-pass filter
        alpha = 1.0 / (1.0 + 1.0/(2*np.pi*self.bandwidth*0.001))  # Simplified filter
        if not hasattr(self, 'filtered_wrench'):
            self.filtered_wrench = measured_wrench
        else:
            self.filtered_wrench = alpha * measured_wrench + (1 - alpha) * self.filtered_wrench

        return {
            'force': self.filtered_wrench[:3],
            'torque': self.filtered_wrench[3:],
            'timestamp': current_time
        }
```

## 5. Control System Integration

### Simulation-Reality Interface

```python
import queue
import threading
import time

class SimulationControlInterface:
    def __init__(self, robot_model, simulation_dt=0.001, control_dt=0.001):
        self.robot_model = robot_model
        self.simulation_dt = simulation_dt
        self.control_dt = control_dt

        # Communication queues
        self.command_queue = queue.Queue(maxsize=10)
        self.state_queue = queue.Queue(maxsize=10)

        # Robot state
        self.current_positions = np.zeros(robot_model.n_joints)
        self.current_velocities = np.zeros(robot_model.n_joints)
        self.current_efforts = np.zeros(robot_model.n_joints)

        # Control commands
        self.desired_positions = np.zeros(robot_model.n_joints)
        self.desired_velocities = np.zeros(robot_model.n_joints)
        self.desired_efforts = np.zeros(robot_model.n_joints)

        # Simulation control
        self.simulation_running = False
        self.control_running = False

        # Timing
        self.last_control_update = time.time()

    def start_simulation(self):
        """
        Start the simulation loop
        """
        self.simulation_running = True
        sim_thread = threading.Thread(target=self.simulation_loop)
        sim_thread.start()

    def start_control_interface(self):
        """
        Start the control interface loop
        """
        self.control_running = True
        control_thread = threading.Thread(target=self.control_interface_loop)
        control_thread.start()

    def simulation_loop(self):
        """
        Main simulation loop
        """
        while self.simulation_running:
            start_time = time.time()

            # Update robot dynamics
            self.update_robot_dynamics()

            # Update sensors
            sensor_data = self.update_sensors()

            # Publish state to control system
            state_msg = {
                'positions': self.current_positions.copy(),
                'velocities': self.current_velocities.copy(),
                'efforts': self.current_efforts.copy(),
                'sensor_data': sensor_data,
                'timestamp': time.time()
            }

            try:
                self.state_queue.put_nowait(state_msg)
            except queue.Full:
                # Drop message if queue is full
                pass

            # Sleep to maintain simulation rate
            elapsed = time.time() - start_time
            sleep_time = max(0, self.simulation_dt - elapsed)
            time.sleep(sleep_time)

    def control_interface_loop(self):
        """
        Control interface loop that communicates with external controllers
        """
        while self.control_running:
            # Check for new commands from controller
            try:
                command = self.command_queue.get_nowait()
                self.desired_positions = command.get('positions', self.desired_positions)
                self.desired_velocities = command.get('velocities', self.desired_velocities)
                self.desired_efforts = command.get('efforts', self.desired_efforts)
            except queue.Empty:
                pass

            # Sleep to match control rate
            time.sleep(self.control_dt)

    def update_robot_dynamics(self):
        """
        Update robot dynamics based on control commands
        """
        # Simple PD control for demonstration
        kp = 100.0  # Position gain
        kd = 10.0   # Velocity gain

        for i in range(len(self.current_positions)):
            # Compute control effort
            pos_error = self.desired_positions[i] - self.current_positions[i]
            vel_error = self.desired_velocities[i] - self.current_velocities[i]

            # PD control law
            effort = kp * pos_error + kd * vel_error

            # Apply control effort to dynamics (simplified)
            acceleration = effort / self.robot_model.joint_inertias[i]
            self.current_velocities[i] += acceleration * self.simulation_dt
            self.current_positions[i] += self.current_velocities[i] * self.simulation_dt

    def update_sensors(self):
        """
        Update all sensors and return sensor data
        """
        # Update IMU
        imu_data = {
            'position': np.array([0, 0, 0]),  # Simplified
            'orientation': np.array([0, 0, 0, 1]),
            'angular_velocity': np.array([0, 0, 0]),
            'linear_acceleration': np.array([0, 0, -9.81])  # Gravity
        }

        # Update joint encoders
        encoder_data = {}
        for i in range(len(self.current_positions)):
            encoder_data[f'joint_{i}'] = {
                'position': self.current_positions[i],
                'velocity': self.current_velocities[i]
            }

        # Update force/torque sensors
        force_data = {}
        for i in range(len(self.current_positions)):
            force_data[f'joint_{i}'] = {
                'force': np.array([0, 0, 0]),
                'torque': np.array([0, 0, 0])
            }

        return {
            'imu': imu_data,
            'encoders': encoder_data,
            'forces': force_data
        }

    def send_command(self, command):
        """
        Send command to the robot
        """
        try:
            self.command_queue.put_nowait(command)
            return True
        except queue.Full:
            return False

    def get_state(self, timeout=0.1):
        """
        Get current robot state
        """
        try:
            return self.state_queue.get(timeout=timeout)
        except queue.Empty:
            return None

class HardwareInLoopSimulator:
    def __init__(self, robot_model, real_hardware_interface=None):
        self.robot_model = robot_model
        self.real_hardware = real_hardware_interface

        # Simulation components
        self.physics_engine = PhysicsEngine()
        self.sensor_simulator = SensorSimulator()
        self.control_interface = SimulationControlInterface(robot_model)

        # Synchronization
        self.simulation_time = 0.0
        self.real_time = time.time()

    def run_hardware_in_loop(self):
        """
        Run hardware-in-the-loop simulation
        """
        # Start simulation
        self.control_interface.start_simulation()

        while True:
            # Get state from real hardware
            if self.real_hardware:
                real_state = self.real_hardware.get_state()
            else:
                real_state = self.control_interface.get_state()

            # Update simulation to match real state
            if real_state:
                self.update_simulation_from_real_state(real_state)

            # Run simulation step
            self.physics_engine.step()

            # Get sensor data from simulation
            sim_sensor_data = self.sensor_simulator.get_sensor_data()

            # Send to real controller
            if self.real_hardware:
                self.real_hardware.send_sensor_data(sim_sensor_data)

            # Get commands from real controller
            if self.real_hardware:
                commands = self.real_hardware.get_commands()
            else:
                commands = self.generate_test_commands()

            # Apply commands to simulation
            self.apply_commands_to_simulation(commands)

            # Synchronize timing
            self.synchronize_timing()

    def update_simulation_from_real_state(self, real_state):
        """
        Update simulation to match real robot state
        """
        # Set joint positions and velocities to match real robot
        self.robot_model.set_joint_positions(real_state['positions'])
        self.robot_model.set_joint_velocities(real_state['velocities'])

    def apply_commands_to_simulation(self, commands):
        """
        Apply commands to the simulation
        """
        # Apply joint commands to simulation model
        for joint_idx, cmd in enumerate(commands):
            self.physics_engine.bodies[joint_idx].apply_torque(cmd['torque'])

    def synchronize_timing(self):
        """
        Synchronize simulation time with real time
        """
        # Implement time synchronization logic
        # This ensures simulation runs at same rate as real hardware
        pass

    def generate_test_commands(self):
        """
        Generate test commands for simulation-only mode
        """
        # For testing without real hardware
        commands = []
        for i in range(self.robot_model.n_joints):
            commands.append({
                'torque': np.random.normal(0, 10),  # Random test torques
                'position': 0.0,
                'velocity': 0.0
            })
        return commands
```

## 6. Real-Time Performance Optimization

### Efficient Simulation Implementation

```python
import numba
from numba import jit
import numpy as np

@jit(nopython=True)
def fast_rigid_body_update(position, velocity, acceleration, dt):
    """
    Fast rigid body update using Numba JIT compilation
    """
    new_velocity = velocity + acceleration * dt
    new_position = position + new_velocity * dt
    return new_position, new_velocity

class OptimizedPhysicsEngine:
    def __init__(self, gravity=np.array([0, 0, -9.81]), dt=0.001):
        self.gravity = gravity
        self.dt = dt

        # Pre-allocate arrays for efficiency
        self.n_bodies = 0
        self.positions = np.zeros((100, 3))  # Pre-allocate for up to 100 bodies
        self.velocities = np.zeros((100, 3))
        self.accelerations = np.zeros((100, 3))
        self.masses = np.ones(100)
        self.forces = np.zeros((100, 3))

        # Active bodies mask
        self.active = np.zeros(100, dtype=np.bool_)

        # Performance metrics
        self.step_times = []
        self.last_step_time = 0.0

    def add_body_optimized(self, position, velocity, mass=1.0):
        """
        Add a body to the optimized engine
        """
        if self.n_bodies < 100:
            idx = self.n_bodies
            self.positions[idx] = position
            self.velocities[idx] = velocity
            self.masses[idx] = mass
            self.active[idx] = True
            self.n_bodies += 1
            return idx
        else:
            raise Exception("Maximum number of bodies reached")

    def step_optimized(self):
        """
        Optimized simulation step using vectorized operations
        """
        start_time = time.time()

        # Apply gravity to all active bodies
        active_gravity = np.zeros((self.n_bodies, 3))
        for i in range(self.n_bodies):
            if self.active[i]:
                self.forces[i] += self.masses[i] * self.gravity

        # Update positions and velocities using vectorized operations
        for i in range(self.n_bodies):
            if self.active[i]:
                # Compute acceleration
                acceleration = self.forces[i] / self.masses[i]

                # Update using optimized function
                self.positions[i], self.velocities[i] = fast_rigid_body_update(
                    self.positions[i], self.velocities[i], acceleration, self.dt
                )

                # Clear forces for next step
                self.forces[i] = np.zeros(3)

        self.last_step_time = time.time() - start_time
        self.step_times.append(self.last_step_time)

        # Keep only recent step times for performance monitoring
        if len(self.step_times) > 1000:
            self.step_times = self.step_times[-1000:]

    def get_performance_metrics(self):
        """
        Get performance metrics for the simulation
        """
        if len(self.step_times) == 0:
            return {
                'avg_step_time': 0,
                'min_step_time': 0,
                'max_step_time': 0,
                'std_step_time': 0
            }

        return {
            'avg_step_time': np.mean(self.step_times),
            'min_step_time': np.min(self.step_times),
            'max_step_time': np.max(self.step_times),
            'std_step_time': np.std(self.step_times),
            'current_step_time': self.last_step_time
        }

class MultiThreadedSimulator:
    def __init__(self, n_threads=4):
        self.n_threads = n_threads
        self.threads = []
        self.simulation_partitions = []

        # Thread synchronization
        self.barrier = threading.Barrier(n_threads)
        self.lock = threading.Lock()

    def partition_simulation(self, bodies, n_partitions):
        """
        Partition simulation bodies across threads
        """
        partition_size = len(bodies) // n_partitions
        partitions = []

        for i in range(n_partitions):
            start_idx = i * partition_size
            end_idx = start_idx + partition_size if i < n_partitions - 1 else len(bodies)
            partitions.append(bodies[start_idx:end_idx])

        return partitions

    def run_parallel_step(self, dt):
        """
        Run simulation step in parallel across multiple threads
        """
        # Partition bodies across threads
        partitions = self.partition_simulation(self.bodies, self.n_threads)

        # Start threads
        for i, partition in enumerate(partitions):
            thread = threading.Thread(
                target=self.thread_simulation_step,
                args=(i, partition, dt)
            )
            self.threads.append(thread)
            thread.start()

        # Wait for all threads to complete
        for thread in self.threads:
            thread.join()

        # Clear threads list
        self.threads = []

    def thread_simulation_step(self, thread_id, partition, dt):
        """
        Simulation step for a single thread
        """
        # Perform physics calculations for this partition
        for body in partition:
            # Update dynamics for this body
            body.update_dynamics(dt)

        # Wait at barrier to synchronize with other threads
        self.barrier.wait()
```

## 7. Simulation Validation and Verification

### Validation Framework

```python
class SimulationValidator:
    def __init__(self, simulation_model, real_robot_data=None):
        self.simulation_model = simulation_model
        self.real_robot_data = real_robot_data
        self.validation_results = {}
        self.error_metrics = {}

    def validate_dynamics(self, test_trajectories):
        """
        Validate simulation dynamics against known solutions
        """
        errors = []

        for trajectory in test_trajectories:
            # Run simulation with trajectory
            sim_result = self.run_simulation_trajectory(trajectory)

            # Compare with analytical solution or experimental data
            if 'analytical_solution' in trajectory:
                analytical_result = trajectory['analytical_solution']
                error = self.compute_error(sim_result, analytical_result)
                errors.append(error)
            elif self.real_robot_data:
                # Compare with real robot data
                real_result = self.get_real_robot_response(trajectory)
                error = self.compute_error(sim_result, real_result)
                errors.append(error)

        self.error_metrics['dynamics'] = {
            'mean_error': np.mean(errors),
            'max_error': np.max(errors),
            'std_error': np.std(errors)
        }

        return self.error_metrics['dynamics']

    def validate_stability(self, equilibrium_points):
        """
        Validate stability around equilibrium points
        """
        stability_results = []

        for eq_point in equilibrium_points:
            # Perturb the equilibrium and check stability
            perturbed_state = eq_point + np.random.normal(0, 0.01, len(eq_point))

            # Run simulation from perturbed state
            stability = self.check_local_stability(perturbed_state)
            stability_results.append(stability)

        self.error_metrics['stability'] = {
            'stable_points': sum(stability_results),
            'total_points': len(stability_results),
            'stability_ratio': sum(stability_results) / len(stability_results)
        }

        return self.error_metrics['stability']

    def validate_energy_conservation(self, conservative_system):
        """
        Validate energy conservation in conservative systems
        """
        initial_energy = self.compute_system_energy(conservative_system.initial_state)

        # Run simulation for some time
        final_state = self.run_energy_conservation_test(conservative_system)
        final_energy = self.compute_system_energy(final_state)

        energy_error = abs(final_energy - initial_energy) / initial_energy

        self.error_metrics['energy'] = {
            'initial_energy': initial_energy,
            'final_energy': final_energy,
            'energy_error': energy_error,
            'energy_conservation_valid': energy_error < 0.01  # 1% threshold
        }

        return self.error_metrics['energy']

    def run_simulation_trajectory(self, trajectory):
        """
        Run simulation with given trajectory and return results
        """
        # Reset simulation to initial state
        self.simulation_model.reset()

        # Apply trajectory commands
        results = []
        for command in trajectory['commands']:
            state = self.simulation_model.update(command)
            results.append(state)

        return results

    def compute_error(self, sim_result, reference_result):
        """
        Compute error between simulation and reference
        """
        # Compute appropriate error metric based on result type
        if isinstance(sim_result, np.ndarray) and isinstance(reference_result, np.ndarray):
            return np.linalg.norm(sim_result - reference_result)
        else:
            # For more complex data structures, implement specific comparison
            return 0.0

    def check_local_stability(self, perturbed_state):
        """
        Check if system returns to equilibrium after small perturbation
        """
        # Run simulation from perturbed state
        # Check if state converges back to equilibrium
        # Return True if stable, False otherwise
        pass

    def compute_system_energy(self, state):
        """
        Compute total energy of the system
        """
        # Calculate kinetic + potential energy
        pass

    def run_energy_conservation_test(self, system):
        """
        Run test to check energy conservation
        """
        pass

class MonteCarloValidator:
    def __init__(self, simulation_model, n_trials=1000):
        self.simulation_model = simulation_model
        self.n_trials = n_trials
        self.results = []

    def run_monte_carlo_validation(self, parameter_ranges, test_function):
        """
        Run Monte Carlo validation over parameter ranges
        """
        for i in range(self.n_trials):
            # Sample parameters randomly
            params = self.sample_parameters(parameter_ranges)

            # Run simulation with these parameters
            result = test_function(self.simulation_model, params)

            self.results.append({
                'parameters': params,
                'result': result,
                'trial': i
            })

        # Analyze results
        return self.analyze_monte_carlo_results()

    def sample_parameters(self, parameter_ranges):
        """
        Sample parameters from given ranges
        """
        params = {}
        for param_name, (min_val, max_val) in parameter_ranges.items():
            params[param_name] = np.random.uniform(min_val, max_val)
        return params

    def analyze_monte_carlo_results(self):
        """
        Analyze Monte Carlo results
        """
        # Compute statistics over all trials
        results_array = np.array([r['result'] for r in self.results])

        return {
            'mean': np.mean(results_array),
            'std': np.std(results_array),
            'min': np.min(results_array),
            'max': np.max(results_array),
            'percentiles': np.percentile(results_array, [5, 25, 50, 75, 95])
        }
```

## 8. Performance Monitoring and Optimization

### Simulation Performance Tools

```python
import psutil
import time
from collections import deque
import matplotlib.pyplot as plt

class SimulationPerformanceMonitor:
    def __init__(self):
        self.metrics = {
            'step_times': deque(maxlen=1000),
            'cpu_usage': deque(maxlen=1000),
            'memory_usage': deque(maxlen=1000),
            'realism_ratio': deque(maxlen=1000),  # Real-time factor
        }

        self.start_time = time.time()
        self.simulation_start_time = time.time()
        self.step_count = 0
        self.last_monitor_time = time.time()

    def record_step_time(self, step_time):
        """
        Record simulation step time
        """
        self.metrics['step_times'].append(step_time)
        self.step_count += 1

    def record_performance_snapshot(self):
        """
        Record current performance snapshot
        """
        current_time = time.time()

        # CPU and memory usage
        cpu_percent = psutil.cpu_percent()
        memory_percent = psutil.virtual_memory().percent

        self.metrics['cpu_usage'].append(cpu_percent)
        self.metrics['memory_usage'].append(memory_percent)

        # Real-time factor
        elapsed_real = current_time - self.start_time
        elapsed_sim = time.time() - self.simulation_start_time  # This would be actual sim time
        realism_ratio = elapsed_sim / elapsed_real if elapsed_real > 0 else 0
        self.metrics['realism_ratio'].append(realism_ratio)

    def get_performance_report(self):
        """
        Generate performance report
        """
        if len(self.metrics['step_times']) == 0:
            return "No performance data collected yet."

        avg_step_time = np.mean(self.metrics['step_times'])
        max_step_time = np.max(self.metrics['step_times'])
        deadline_misses = sum(1 for t in self.metrics['step_times'] if t > 0.001)  # Assuming 1kHz

        report = f"""
Simulation Performance Report:
==============================
- Average step time: {avg_step_time*1000:.2f} ms
- Maximum step time: {max_step_time*1000:.2f} ms
- Deadline misses: {deadline_misses}
- Average CPU usage: {np.mean(self.metrics['cpu_usage']):.1f}%
- Average memory usage: {np.mean(self.metrics['memory_usage']):.1f}%
- Real-time factor: {np.mean(self.metrics['realism_ratio']):.2f}
- Total steps: {self.step_count}
        """

        return report

    def plot_performance(self):
        """
        Plot performance metrics
        """
        fig, axes = plt.subplots(2, 2, figsize=(12, 8))

        # Step times
        if self.metrics['step_times']:
            axes[0, 0].plot(list(self.metrics['step_times']))
            axes[0, 0].set_title('Step Times')
            axes[0, 0].set_ylabel('Time (s)')

        # CPU usage
        if self.metrics['cpu_usage']:
            axes[0, 1].plot(list(self.metrics['cpu_usage']))
            axes[0, 1].set_title('CPU Usage')
            axes[0, 1].set_ylabel('Percentage')

        # Memory usage
        if self.metrics['memory_usage']:
            axes[1, 0].plot(list(self.metrics['memory_usage']))
            axes[1, 0].set_title('Memory Usage')
            axes[1, 0].set_ylabel('Percentage')

        # Real-time factor
        if self.metrics['realism_ratio']:
            axes[1, 1].plot(list(self.metrics['realism_ratio']))
            axes[1, 1].set_title('Real-time Factor')
            axes[1, 1].set_ylabel('Factor')

        plt.tight_layout()
        plt.show()

class AdaptiveSimulator:
    def __init__(self, base_simulator):
        self.base_simulator = base_simulator
        self.performance_monitor = SimulationPerformanceMonitor()
        self.adaptation_enabled = True

        # Adaptation parameters
        self.target_step_time = 0.001  # 1ms target
        self.fidelity_levels = ['low', 'medium', 'high']
        self.current_fidelity = 'medium'

    def run_adaptive_simulation(self, max_steps=None):
        """
        Run simulation with adaptive fidelity based on performance
        """
        step_count = 0

        while max_steps is None or step_count < max_steps:
            start_time = time.time()

            # Run simulation step
            self.base_simulator.step()

            step_time = time.time() - start_time
            self.performance_monitor.record_step_time(step_time)

            # Check performance and adapt if necessary
            if self.adaptation_enabled:
                self.adapt_fidelity(step_time)

            # Record performance metrics periodically
            if step_count % 100 == 0:
                self.performance_monitor.record_performance_snapshot()

            step_count += 1

    def adapt_fidelity(self, current_step_time):
        """
        Adapt simulation fidelity based on performance
        """
        if current_step_time > self.target_step_time * 1.5 and self.current_fidelity != 'low':
            # Performance too slow, reduce fidelity
            if self.current_fidelity == 'high':
                self.current_fidelity = 'medium'
                self.reduce_fidelity()
            elif self.current_fidelity == 'medium':
                self.current_fidelity = 'low'
                self.reduce_fidelity()

        elif current_step_time < self.target_step_time * 0.7 and self.current_fidelity != 'high':
            # Performance too fast, increase fidelity
            if self.current_fidelity == 'low':
                self.current_fidelity = 'medium'
                self.increase_fidelity()
            elif self.current_fidelity == 'medium':
                self.current_fidelity = 'high'
                self.increase_fidelity()

    def reduce_fidelity(self):
        """
        Reduce simulation fidelity to improve performance
        """
        # Examples of fidelity reduction:
        # - Reduce physics update rate
        # - Simplify collision geometry
        # - Reduce number of simulation substeps
        # - Use simpler contact models
        pass

    def increase_fidelity(self):
        """
        Increase simulation fidelity to improve accuracy
        """
        # Examples of fidelity increase:
        # - Increase physics update rate
        # - Use more detailed collision geometry
        # - Increase number of simulation substeps
        # - Use more accurate contact models
        pass
```

This implementation section provides practical examples of simulation systems for humanoid robots, including physics engines, collision detection, sensor simulation, control system integration, and performance optimization techniques. The code demonstrates how theoretical simulation concepts are translated into executable implementations that can run on real robotic systems.